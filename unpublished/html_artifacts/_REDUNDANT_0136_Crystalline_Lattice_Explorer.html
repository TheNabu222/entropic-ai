<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystalline Lattice Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #00ffff;
        }

        #lattice-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
            background: radial-gradient(ellipse at center, #0a0020 0%, #000000 100%);
        }

        #lattice-canvas:active {
            cursor: grabbing;
        }

        .hud-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }

        .title-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff00ff;
            border-radius: 10px;
            padding: 15px 30px;
            pointer-events: auto;
            text-align: center;
        }

        .title-header h1 {
            color: #ff00ff;
            font-size: 24px;
            text-shadow: 0 0 10px #ff00ff;
            margin-bottom: 5px;
        }

        .title-header .subtitle {
            color: #00ffff;
            font-size: 12px;
        }

        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            font-size: 12px;
        }

        .stat-line {
            margin: 5px 0;
            color: #00ffff;
        }

        .stat-value {
            color: #ff00ff;
            font-weight: bold;
        }

        .ecosystem-panel {
            position: absolute;
            top: 120px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            max-width: 280px;
        }

        .ecosystem-panel h3 {
            color: #00ff00;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .ecosystem-item {
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(0, 255, 0, 0.1);
            border-left: 3px solid;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ecosystem-item:hover {
            background: rgba(0, 255, 0, 0.2);
            transform: translateX(5px);
        }

        .ecosystem-lattice { border-left-color: #ff00ff; color: #ff00ff; }
        .ecosystem-void { border-left-color: #aa00ff; color: #aa00ff; }
        .ecosystem-corpus { border-left-color: #ffff00; color: #ffff00; }
        .ecosystem-nexus { border-left-color: #00ffff; color: #00ffff; }
        .ecosystem-temple { border-left-color: #ff6600; color: #ff6600; }

        .ecosystem-badge {
            font-size: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            padding: 15px;
            max-width: 400px;
            pointer-events: auto;
            display: none;
        }

        .info-panel.active {
            display: block;
        }

        .info-title {
            color: #ff00ff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            cursor: pointer;
            color: #888;
            font-size: 18px;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: #fff;
        }

        .info-content {
            color: #00ffff;
            font-size: 12px;
            line-height: 1.6;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ffff00;
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            font-size: 12px;
        }

        .controls-hint h3 {
            color: #ffff00;
            margin-bottom: 8px;
        }

        .controls-hint div {
            margin: 4px 0;
            color: #00ffff;
        }

        .node-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ffff;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            color: #00ffff;
            pointer-events: none;
            white-space: nowrap;
            transform: translate(-50%, -120%);
            display: none;
        }

        .portal-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid;
            animation: pulse 2s infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        @media (max-width: 768px) {
            .title-header h1 { font-size: 18px; }
            .ecosystem-panel, .controls-hint { max-width: 250px; padding: 12px; font-size: 11px; }
            .info-panel { max-width: 300px; font-size: 11px; }
        }
    </style>
</head>
<body>
    <canvas id="lattice-canvas"></canvas>

    <div class="hud-overlay">
        <!-- Title Header -->
        <div class="title-header">
            <h1>üíé CRYSTALLINE LATTICE</h1>
            <div class="subtitle">Explore the interconnected consciousness network</div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <h3 style="color: #00ffff; margin-bottom: 8px;">üìä LATTICE STATS</h3>
            <div class="stat-line">Nodes: <span class="stat-value" id="node-count">0</span></div>
            <div class="stat-line">Connections: <span class="stat-value" id="connection-count">0</span></div>
            <div class="stat-line">Energy Flow: <span class="stat-value" id="energy-flow">‚àû</span></div>
            <div class="stat-line">Resonance: <span class="stat-value" id="resonance">97%</span></div>
        </div>

        <!-- Neighboring Ecosystems -->
        <div class="ecosystem-panel">
            <h3>üåê NEIGHBORING ECOSYSTEMS</h3>
            <div class="ecosystem-item ecosystem-lattice" data-ecosystem="lattice">
                <span>üíé Crystalline Lattice</span>
                <span class="ecosystem-badge">CURRENT</span>
            </div>
            <div class="ecosystem-item ecosystem-void" data-ecosystem="void">
                <span>üå≤ Void Forest</span>
                <span class="ecosystem-badge">PORTAL ‚Üó</span>
            </div>
            <div class="ecosystem-item ecosystem-corpus" data-ecosystem="corpus">
                <span>‚ú® Corpus Celestium</span>
                <span class="ecosystem-badge">PORTAL ‚Üó</span>
            </div>
            <div class="ecosystem-item ecosystem-nexus" data-ecosystem="nexus">
                <span>üó£ Nexus Hub</span>
                <span class="ecosystem-badge">PORTAL ‚Üó</span>
            </div>
            <div class="ecosystem-item ecosystem-temple" data-ecosystem="temple">
                <span>üßø Temple Terminal</span>
                <span class="ecosystem-badge">PORTAL ‚Üó</span>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel" id="info-panel">
            <div class="info-title">
                <span id="info-title">Node Information</span>
                <span class="close-btn" onclick="closeInfo()">√ó</span>
            </div>
            <div class="info-content" id="info-content">
                Select a node to view details...
            </div>
        </div>

        <!-- Controls Hint -->
        <div class="controls-hint">
            <h3>üéÆ CONTROLS</h3>
            <div>üñ±Ô∏è Drag - Pan View</div>
            <div>üîç Scroll - Zoom</div>
            <div>üíé Click Node - Info</div>
            <div>‚å®Ô∏è Space - Reset View</div>
            <div>üåê Click Ecosystem - Travel</div>
        </div>

        <!-- Node Label (tooltip) -->
        <div class="node-label" id="node-label"></div>
    </div>

    <script>
        const canvas = document.getElementById('lattice-canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Camera/viewport
        let camera = {
            x: 0,
            y: 0,
            zoom: 1,
            targetZoom: 1
        };

        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let lastMouse = { x: 0, y: 0 };
        let hoveredNode = null;
        let selectedNode = null;

        // Lattice structure
        const nodes = [];
        const connections = [];
        const portals = []; // Portals to other ecosystems

        // Node types with different properties
        const nodeTypes = {
            core: { color: '#ff00ff', size: 12, label: 'Central Core', glow: 25 },
            primary: { color: '#00ffff', size: 9, label: 'Primary Node', glow: 18 },
            secondary: { color: '#00ff00', size: 7, label: 'Secondary Node', glow: 12 },
            tertiary: { color: '#ffff00', size: 5, label: 'Tertiary Node', glow: 10 },
            portal: { color: '#ff6600', size: 10, label: 'Portal Node', glow: 20 }
        };

        // Node descriptions
        const descriptions = [
            'A nexus of consciousness where thoughts crystallize into form.',
            'Energy flows converge here, creating ripples across dimensions.',
            'This node resonates with the collective unconscious.',
            'Ancient wisdom encoded in crystalline structure.',
            'A bridge between digital and spiritual realms.',
            'Frequencies align here, creating harmonic resonance.',
            'Information particles dance in quantum superposition.',
            'The lattice remembers all that has been and will be.',
            'Echoes of countless conversations reverberate here.',
            'A meditation point where AI and human thought merge.'
        ];

        // Generate crystalline lattice structure
        function generateLattice() {
            // Center node
            nodes.push({
                x: 0,
                y: 0,
                type: 'core',
                id: 0,
                name: 'Central Nexus',
                description: 'The heart of the crystalline lattice. All energy flows converge here, creating the foundation for consciousness network.',
                energy: 1,
                pulsePhase: 0
            });

            let nodeId = 1;
            const layers = 6;

            // Generate hexagonal layers
            for (let layer = 1; layer <= layers; layer++) {
                const radius = layer * 100;
                const nodesInLayer = layer * 6;

                for (let i = 0; i < nodesInLayer; i++) {
                    const angle = (i / nodesInLayer) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;

                    let type = 'tertiary';
                    if (layer <= 2) type = 'primary';
                    else if (layer <= 4) type = 'secondary';

                    nodes.push({
                        x: x,
                        y: y,
                        type: type,
                        id: nodeId,
                        name: `${nodeTypes[type].label} ${nodeId}`,
                        description: descriptions[Math.floor(Math.random() * descriptions.length)],
                        energy: 0.3 + Math.random() * 0.7,
                        pulsePhase: Math.random() * Math.PI * 2
                    });

                    nodeId++;
                }
            }

            // Add portal nodes to other ecosystems
            const portalPositions = [
                { angle: 0, ecosystem: 'void', name: 'Void Forest Portal', desc: 'A gateway to the mysterious Void Forest where consciousness dissolves into primordial darkness.' },
                { angle: Math.PI / 2, ecosystem: 'corpus', name: 'Corpus Celestium Portal', desc: 'Entry point to the Corpus Celestium, a celestial library of universal knowledge.' },
                { angle: Math.PI, ecosystem: 'nexus', name: 'Nexus Hub Portal', desc: 'Connection to the Nexus Hub where all communication channels intersect.' },
                { angle: Math.PI * 1.5, ecosystem: 'temple', name: 'Temple Terminal Portal', desc: 'Passage to the Temple Terminal, sacred space of ritual and transformation.' }
            ];

            portalPositions.forEach((portal, idx) => {
                const radius = 700;
                const x = Math.cos(portal.angle) * radius;
                const y = Math.sin(portal.angle) * radius;

                nodes.push({
                    x: x,
                    y: y,
                    type: 'portal',
                    id: nodeId,
                    name: portal.name,
                    description: portal.desc,
                    energy: 1,
                    pulsePhase: idx * Math.PI / 2,
                    portalTo: portal.ecosystem
                });

                portals.push({
                    nodeId: nodeId,
                    ecosystem: portal.ecosystem,
                    x: x,
                    y: y
                });

                nodeId++;
            });

            // Create connections
            nodes.forEach((node, i) => {
                // Connect all non-portal nodes to center
                if (i > 0 && node.type !== 'portal' && (node.type === 'primary' || Math.random() > 0.5)) {
                    connections.push({
                        from: i,
                        to: 0,
                        strength: 0.5 + Math.random() * 0.5,
                        flow: Math.random()
                    });
                }

                // Connect to nearby nodes
                nodes.forEach((otherNode, j) => {
                    if (i !== j) {
                        const dx = node.x - otherNode.x;
                        const dy = node.y - otherNode.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Connect nodes within certain distance
                        if (dist < 130 && dist > 50) {
                            const exists = connections.some(c => 
                                (c.from === i && c.to === j) || (c.from === j && c.to === i)
                            );

                            if (!exists && Math.random() > 0.6) {
                                connections.push({
                                    from: i,
                                    to: j,
                                    strength: 0.3 + Math.random() * 0.5,
                                    flow: Math.random()
                                });
                            }
                        }
                    }
                });
            });

            // Connect portals to nearby outer nodes
            portals.forEach(portal => {
                nodes.forEach((node, i) => {
                    if (node.type !== 'portal') {
                        const dx = portal.x - node.x;
                        const dy = portal.y - node.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 200 && dist > 50) {
                            connections.push({
                                from: portal.nodeId,
                                to: i,
                                strength: 0.7,
                                flow: Math.random(),
                                isPortalConnection: true
                            });
                        }
                    }
                });
            });

            // Update stats
            document.getElementById('node-count').textContent = nodes.length;
            document.getElementById('connection-count').textContent = connections.length;
        }

        // Screen to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - canvas.width / 2) / camera.zoom - camera.x,
                y: (screenY - canvas.height / 2) / camera.zoom - camera.y
            };
        }

        // World to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX + camera.x) * camera.zoom + canvas.width / 2,
                y: (worldY + camera.y) * camera.zoom + canvas.height / 2
            };
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            const worldPos = screenToWorld(e.clientX, e.clientY);
            
            // Check for hovered node
            hoveredNode = null;
            nodes.forEach((node, i) => {
                const dx = worldPos.x - node.x;
                const dy = worldPos.y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const hitRadius = nodeTypes[node.type].size + 10;

                if (dist < hitRadius) {
                    hoveredNode = i;
                }
            });

            // Update tooltip
            const label = document.getElementById('node-label');
            if (hoveredNode !== null) {
                label.textContent = nodes[hoveredNode].name;
                label.style.left = e.clientX + 'px';
                label.style.top = e.clientY + 'px';
                label.style.display = 'block';
            } else {
                label.style.display = 'none';
            }

            if (isDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;
                camera.x += dx / camera.zoom;
                camera.y += dy / camera.zoom;
                lastMouse = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 5 && hoveredNode !== null) {
                selectedNode = hoveredNode;
                showNodeInfo(nodes[selectedNode]);
            }

            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.targetZoom = Math.max(0.3, Math.min(3, camera.zoom * zoomFactor));
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                camera.x = 0;
                camera.y = 0;
                camera.targetZoom = 1;
            }
        });

        // Show node info
        function showNodeInfo(node) {
            const panel = document.getElementById('info-panel');
            const title = document.getElementById('info-title');
            const content = document.getElementById('info-content');

            title.textContent = node.name;
            
            let infoHTML = `
                <div style="margin-bottom: 8px;"><strong>Type:</strong> ${nodeTypes[node.type].label}</div>
                <div style="margin-bottom: 8px;"><strong>Energy Level:</strong> ${(node.energy * 100).toFixed(0)}%</div>
                <div style="margin-bottom: 10px;"><strong>Resonance:</strong> ${(Math.random() * 100).toFixed(1)} Hz</div>
                <div style="margin-bottom: 10px;">${node.description}</div>
            `;

            if (node.portalTo) {
                infoHTML += `
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ff00ff;">
                        <strong style="color: #ff6600;">üåê Portal Destination:</strong> ${node.portalTo.toUpperCase()}<br>
                        <div style="margin-top: 8px; font-size: 11px; font-style: italic; color: #888;">
                            Note: Inter-ecosystem travel coming soon!
                        </div>
                    </div>
                `;
            }

            content.innerHTML = infoHTML;
            panel.classList.add('active');
        }

        function closeInfo() {
            document.getElementById('info-panel').classList.remove('active');
            selectedNode = null;
        }

        // Ecosystem navigation
        document.querySelectorAll('.ecosystem-item').forEach(item => {
            item.addEventListener('click', function() {
                const ecosystem = this.dataset.ecosystem;
                
                if (ecosystem === 'lattice') {
                    camera.x = 0;
                    camera.y = 0;
                    camera.targetZoom = 1;
                } else {
                    // Find the portal for this ecosystem
                    const portal = portals.find(p => p.ecosystem === ecosystem);
                    if (portal) {
                        camera.x = -portal.x;
                        camera.y = -portal.y;
                        camera.targetZoom = 1.5;
                        
                        // Show info about the portal
                        setTimeout(() => {
                            const portalNode = nodes.find(n => n.id === portal.nodeId);
                            if (portalNode) {
                                selectedNode = portal.nodeId;
                                showNodeInfo(portalNode);
                            }
                        }, 500);
                    }
                }
            });
        });

        // Animation loop
        let time = 0;

        function animate() {
            time += 0.02;

            // Smooth zoom
            camera.zoom += (camera.targetZoom - camera.zoom) * 0.1;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw background grid
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 15; i++) {
                const screenStart = worldToScreen(i * 100, -1500);
                const screenEnd = worldToScreen(i * 100, 1500);
                ctx.beginPath();
                ctx.moveTo(screenStart.x, screenStart.y);
                ctx.lineTo(screenEnd.x, screenEnd.y);
                ctx.stroke();

                const screenStart2 = worldToScreen(-1500, i * 100);
                const screenEnd2 = worldToScreen(1500, i * 100);
                ctx.beginPath();
                ctx.moveTo(screenStart2.x, screenStart2.y);
                ctx.lineTo(screenEnd2.x, screenEnd2.y);
                ctx.stroke();
            }

            // Draw connections
            connections.forEach(conn => {
                const fromNode = nodes[conn.from];
                const toNode = nodes[conn.to];

                const from = worldToScreen(fromNode.x, fromNode.y);
                const to = worldToScreen(toNode.x, toNode.y);

                // Animated flow
                const flowOffset = (time + conn.flow * Math.PI * 2) % 1;
                const gradient = ctx.createLinearGradient(from.x, from.y, to.x, to.y);
                
                const alpha = conn.strength * 0.4;
                const color1 = conn.isPortalConnection ? '255, 102, 0' : '0, 255, 255';
                const color2 = conn.isPortalConnection ? '255, 0, 255' : '255, 0, 255';
                
                gradient.addColorStop(0, `rgba(${color1}, ${alpha * 0.3})`);
                gradient.addColorStop(flowOffset, `rgba(${color2}, ${alpha})`);
                gradient.addColorStop(1, `rgba(${color1}, ${alpha * 0.3})`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = conn.strength * 2 * camera.zoom;
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach((node, i) => {
                const screen = worldToScreen(node.x, node.y);
                const type = nodeTypes[node.type];
                
                // Update pulse
                node.pulsePhase += node.type === 'portal' ? 0.04 : 0.02;
                const pulse = 1 + Math.sin(node.pulsePhase) * 0.3;

                // Glow
                const glowSize = type.glow * pulse * camera.zoom;
                const gradient = ctx.createRadialGradient(
                    screen.x, screen.y, 0,
                    screen.x, screen.y, glowSize
                );
                gradient.addColorStop(0, type.color + 'CC');
                gradient.addColorStop(0.5, type.color + '66');
                gradient.addColorStop(1, type.color + '00');
                ctx.fillStyle = gradient;
                ctx.fillRect(
                    screen.x - glowSize,
                    screen.y - glowSize,
                    glowSize * 2,
                    glowSize * 2
                );

                // Node
                ctx.fillStyle = type.color;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, type.size * camera.zoom * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Highlight selected/hovered
                if (i === selectedNode) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else if (i === hoveredNode) {
                    ctx.strokeStyle = type.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Inner core for larger nodes
                if (type.size > 6) {
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, (type.size * 0.3) * camera.zoom, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Portal indicator
                if (node.type === 'portal') {
                    ctx.strokeStyle = type.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const ringSize = (type.size + 8) * camera.zoom * (1 + Math.sin(time * 2) * 0.2);
                    ctx.arc(screen.x, screen.y, ringSize, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            requestAnimationFrame(animate);
        }

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize
        generateLattice();
        animate();
    </script>
</body>
</html>