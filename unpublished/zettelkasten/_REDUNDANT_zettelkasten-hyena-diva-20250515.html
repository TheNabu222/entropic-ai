<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>~*~HyEnA DiVa'Z ZeTtElKaStEn~*~ Multi-Classification Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Tahoma&family=Comic+Sans+MS&family=VT323&display=swap" rel="stylesheet">
  <style>
    /* Y2K HYENA DIVA COLORS */
    :root {
      --hyena-pink: #ff72b6;
      --hyena-purple: #bf5fff;
      --hyena-teal: #72fade;
      --hyena-yellow: #fffb01;
      --hyena-blue: #00a2ff;
      
      /* Windows 98 colors with Hyena flair */
      --win98-gray: #C0C0C0;
      --win98-gray-dark: #808080;
      --win98-gray-light: #DFDFDF;
      --win98-desktop: #ff72b6; /* Hyena pink background */
      --win98-window: #C0C0C0;
      --win98-title-active: #bf5fff; /* Hyena purple title bar */
      --win98-title-inactive: #808080;
      --win98-button: #C0C0C0;
      --win98-button-highlight: #FFFFFF;
      --win98-button-shadow: #808080;
      --win98-text: #000000;
      
      /* Kingdom colors */
      --kingdom-existentia: #9C27B0;
      --kingdom-cognitio: #2196F3;
      --kingdom-actus: #F44336;
      --kingdom-valor: #4CAF50;
      --kingdom-systema: #FF9800;
      --kingdom-significatio: #607D8B;
      
      /* Codex colors */
      --codex-cg: #E91E63;
      --codex-ts: #00BCD4;
      --codex-paps: #8BC34A;
      --codex-coai: #9C27B0;
    }
    
    /* Base styles */
    body {
      background-color: var(--win98-desktop);
      background-image: url('https://pfst.cf2.poecdn.net/base/image/c568f858cbfe5304ed56fca693cb244fed53eafca1683b9a9c6d110dbd7dfeeb?w=1024&h=1024');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      background-blend-mode: soft-light;
      color: var(--win98-text);
      font-family: 'Tahoma', 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      position: fixed;
      -webkit-font-smoothing: antialiased;
      -webkit-overflow-scrolling: touch;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }

    /* Apply iOS-style overscroll behavior */
    .ios-scroll {
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Mobile View Toggle Styles */
    .view-toggle {
      position: fixed;
      top: 5px;
      right: 5px;
      z-index: 9999;
      background: var(--hyena-pink);
      color: white;
      border: 2px solid white;
      border-radius: 20px;
      padding: 8px 12px;
      font-size: 14px;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      transition: transform 0.3s, background-color 0.3s;
      -webkit-tap-highlight-color: transparent;
    }

    .view-toggle:hover {
      transform: scale(1.05);
      background-color: var(--hyena-purple);
    }

    .rotate-icon {
      display: inline-block;
      margin-left: 4px;
      font-size: 10px;
      animation: rotate 2s linear infinite;
      -webkit-animation: rotate 2s linear infinite;
    }

    @-webkit-keyframes rotate {
      0% { -webkit-transform: rotate(0deg); }
      100% { -webkit-transform: rotate(360deg); }
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Rotate Button Styles */
    .rotate-button {
      position: fixed;
      bottom: 40px;
      right: 10px;
      z-index: 9999;
      background: var(--hyena-yellow);
      color: black;
      border: 2px solid var(--hyena-pink);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      transition: transform 0.3s ease;
      -webkit-transition: transform 0.3s ease;
      -webkit-tap-highlight-color: transparent;
    }

    .rotate-button:hover {
      transform: rotate(45deg);
      -webkit-transform: rotate(45deg);
    }

    /* Scale Control Styles */
    .scale-control {
      position: fixed;
      bottom: 28px; /* Position just above taskbar */
      right: 100px; /* Position to the right, away from content */
      z-index: 1001; /* Above most content but below popups */
      background: var(--win98-gray);
      border: 2px solid var(--hyena-teal);
      border-radius: 20px;
      padding: 3px 5px;
      display: flex;
      align-items: center;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      opacity: 0.6;
      transition: opacity 0.3s;
    }
    
    .scale-control:hover {
      opacity: 1;
    }

    .scale-button {
      width: 25px;
      height: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--hyena-pink);
      color: white;
      border-radius: 50%;
      cursor: pointer;
      font-weight: bold;
      margin: 0 3px;
      font-size: 14px;
      -webkit-tap-highlight-color: transparent;
    }

    /* Mobile Mode */
    body.mobile-mode {
      background-attachment: scroll;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      height: auto;
      position: static;
    }

    body.mobile-mode .desktop,
    body.mobile-mode .win98-taskbar,
    body.mobile-mode .start-menu {
      display: none !important;
    }

    body.mobile-mode .win98-window {
      position: relative !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: auto !important;
      margin: 0 0 10px 0;
      border-radius: 0;
    }

    body.mobile-mode .win98-inner-content {
      height: auto;
      max-height: none;
      padding: 5px;
    }

    body.mobile-mode .win98-window-content {
      height: auto;
    }

    body.mobile-mode .zettel-container {
      max-height: 70vh;
    }
    
    body.mobile-mode .view-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: center;
    }
    
    body.mobile-mode .view-controls button {
      min-width: 80px;
      margin: 2px;
      font-size: 12px;
      padding: 8px 5px;
    }
    
    body.mobile-mode .tabs-container {
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* Sidebar Layout */
    .main-layout {
      display: flex;
      width: 100%;
      gap: 15px;
      position: relative;
    }
    
    .sidebar {
      width: 250px;
      flex-shrink: 0;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border: 1px solid #ccc;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
      height: fit-content;
      overflow-y: auto;
    }
    
    .sidebar-section {
      margin-bottom: 20px;
    }
    
    .sidebar-title {
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
      color: var(--hyena-purple);
      font-weight: bold;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid var(--hyena-pink);
    }
    
    .tag-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    
    .tag-cloud-tag {
      cursor: pointer;
      padding: 3px 8px;
      border-radius: 15px;
      background-color: var(--hyena-teal);
      color: #000;
      display: inline-block;
      transition: transform 0.2s, background-color 0.2s;
    }
    
    .tag-cloud-tag:hover {
      transform: scale(1.05);
      background-color: var(--hyena-pink);
      color: white;
    }
    
    .tag-size-1 { font-size: 10px; opacity: 0.7; }
    .tag-size-2 { font-size: 12px; opacity: 0.8; }
    .tag-size-3 { font-size: 14px; opacity: 0.9; }
    .tag-size-4 { font-size: 16px; opacity: 1; }
    .tag-size-5 { font-size: 18px; font-weight: bold; opacity: 1; }
    
    .related-concepts {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .related-concept {
      padding: 5px;
      border-left: 3px solid var(--hyena-purple);
      background-color: #f0f0f0;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .related-concept:hover {
      background-color: #e0e0e0;
    }
    
    .main-content {
      flex-grow: 1;
      min-width: 0; /* Prevent flex item from overflowing */
    }
    
    body.mobile-mode .main-layout {
      flex-direction: column;
    }
    
    body.mobile-mode .sidebar {
      width: 100%;
      margin-bottom: 15px;
    }
    
    /* File Upload Area */
    .file-upload-area {
      border: 2px dashed var(--hyena-teal);
      padding: 15px;
      text-align: center;
      margin-bottom: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      transition: background-color 0.3s;
    }
    
    .file-upload-area:hover {
      background-color: rgba(255, 114, 182, 0.1);
    }
    
    .file-upload-input {
      display: none;
    }
    
    /* Mobile view toggle enhancement */
    body.mobile-mode .view-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 9999;
      font-size: 16px;
      padding: 10px 15px;
      background: linear-gradient(to right, var(--hyena-pink), var(--hyena-purple));
      color: white;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    /* Orientation styles */
    body.landscape .myspace-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    body.landscape .myspace-profile-pic {
      margin: 0 15px 0 0;
      flex-shrink: 0;
    }

    body.landscape .myspace-text-container {
      text-align: left;
      flex-grow: 1;
    }

    /* Windows 98 styles with Hyena Diva flair */
    .win98-window {
      background-color: var(--win98-gray);
      border: 2px solid #000000;
      border-top: 2px solid var(--win98-gray-light);
      border-left: 2px solid var(--win98-gray-light);
      border-right: 2px solid var(--win98-gray-dark);
      border-bottom: 2px solid var(--win98-gray-dark);
      box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      position: absolute;
      resize: both;
      -webkit-transform: translateZ(0); /* Optimize for Safari */
    }
    
    .win98-titlebar {
      background: var(--win98-title-active);
      background-image: -webkit-linear-gradient(left, var(--hyena-purple), var(--hyena-pink));
      background-image: linear-gradient(to right, var(--hyena-purple), var(--hyena-pink));
      color: white;
      padding: 2px 0;
      display: flex;
      align-items: center;
      height: 18px;
      cursor: grab;
    }
    
    .win98-titlebar-text {
      flex-grow: 1;
      font-weight: bold;
      margin-left: 4px;
      font-size: 12px;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .win98-window-controls {
      display: flex;
      align-items: center;
      height: 14px;
      margin-right: 2px;
      flex-shrink: 0;
    }
    
    .win98-window-button {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 2px;
      cursor: pointer;
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      color: black;
      font-size: 9px;
      font-family: 'Tahoma', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-close {
      font-weight: bold;
      font-size: 10px;
    }
    
    .win98-app-icon {
      width: 16px;
      height: 16px;
      margin-left: 2px;
      margin-right: 4px;
      flex-shrink: 0;
    }
    
    .win98-window-content {
      padding: 2px;
      overflow-y: auto;
      background-color: var(--win98-gray);
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-inner-content {
      background-color: #FFFFFF;
      border: 1px solid var(--win98-gray-dark);
      padding: 10px;
      height: calc(100% - 22px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 28px;
      background-color: var(--win98-gray);
      display: flex;
      align-items: center;
      padding: 0 2px;
      border-top: 1px solid var(--win98-gray-light);
      z-index: 1000;
    }
    
    .win98-start-button {
      background-color: var(--win98-gray);
      padding: 1px 6px;
      color: black;
      font-weight: bold;
      display: flex;
      align-items: center;
      height: 22px;
      margin-right: 6px;
      cursor: pointer;
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-start-button:active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
    }
    
    .win98-taskbar-items {
      flex-grow: 1;
      display: flex;
      align-items: center;
      gap: 4px;
      overflow-x: auto;
      white-space: nowrap;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-taskbar-items::-webkit-scrollbar {
      display: none;
    }
    
    .win98-taskbar-item {
      background-color: var(--win98-gray);
      padding: 2px 8px;
      color: black;
      font-size: 11px;
      height: 22px;
      min-width: 150px;
      display: flex;
      align-items: center;
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-taskbar-item-active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
    }
    
    .win98-system-tray {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      padding: 0 2px;
      border-left: 1px solid var(--win98-gray-dark);
      height: 22px;
      flex-shrink: 0;
    }
    
    .win98-system-tray-icon {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    .win98-clock {
      background-color: var(--win98-gray);
      padding: 2px 4px;
      font-size: 11px;
      color: black;
    }
    
    /* Customize default button styles */
    .win98-button {
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      color: var(--win98-text);
      padding: 8px 12px;
      font-family: 'Tahoma', sans-serif;
      font-size: 14px;
      cursor: pointer;
      position: relative;
      margin-top: 10px;
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-button:hover {
      background-color: var(--win98-gray-light);
    }
    
    .win98-button:active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
      background-color: var(--win98-gray);
    }
    
    .win98-button.active {
      background-color: var(--hyena-pink);
      color: white;
      font-weight: bold;
    }
    
    /* Floating Star */
    .floating-star {
      position: absolute;
      width: 30px;
      height: 30px;
      pointer-events: none;
      z-index: 20;
      filter: drop-shadow(0 0 5px rgba(255, 251, 1, 0.7));
      -webkit-filter: drop-shadow(0 0 5px rgba(255, 251, 1, 0.7));
      animation: float 3s infinite ease-in-out;
      -webkit-animation: float 3s infinite ease-in-out;
    }
    
    @-webkit-keyframes float {
      0% { -webkit-transform: translateY(0px); }
      50% { -webkit-transform: translateY(-10px); }
      100% { -webkit-transform: translateY(0px); }
    }
    
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }
    
    /* Zettelkasten styles */
    .zettel-container {
      max-height: 300px;
      overflow-y: auto;
      padding-right: 10px;
      scrollbar-width: thin;
      scrollbar-color: var(--hyena-pink) #e5f5ff;
      border: 1px solid #ccc;
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.2);
      padding: 5px;
      background-color: white;
      -webkit-overflow-scrolling: touch;
    }
    
    .zettel-container::-webkit-scrollbar {
      width: 8px;
    }
    
    .zettel-container::-webkit-scrollbar-track {
      background: #e5f5ff;
      border: 1px solid #ccc;
    }
    
    .zettel-container::-webkit-scrollbar-thumb {
      background-color: var(--hyena-teal);
      border-radius: 0;
      border: 1px solid #919191;
    }
    
    .zettel-card {
      background-color: #fbfbfb;
      border: 1px solid #cccccc;
      padding: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-transition: all 0.2s;
      position: relative;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
      touch-action: pan-y; /* Improves scrolling vs tapping distinction */
    }
    
    .zettel-card:hover {
      background-color: #e8f4ff;
      border-color: var(--hyena-teal);
      transform: translateX(5px);
      -webkit-transform: translateX(5px);
    }
    
    .zettel-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: -webkit-linear-gradient(left, var(--hyena-pink), var(--hyena-teal), var(--hyena-yellow));
      background: linear-gradient(90deg, var(--hyena-pink), var(--hyena-teal), var(--hyena-yellow));
      z-index: 5;
    }
    
    .zettel-title {
      font-weight: bold;
      color: #333;
      margin-bottom: 3px;
      font-size: 14px;
    }
    
    .zettel-id {
      font-size: 11px;
      color: #777;
      font-family: 'VT323', monospace;
    }
    
    /* Traditional hierarchy styling */
    .trunk-card { border-left: 4px solid var(--hyena-purple); }
    .branch-card { border-left: 4px solid var(--hyena-blue); }
    .leaf-card { border-left: 4px solid var(--hyena-teal); }
    .flower-card { border-left: 4px solid var(--hyena-pink); }
    .fruit-card { border-left: 4px solid #f59e0b; }
    .bud-card { border-left: 4px solid var(--hyena-yellow); }
    
    /* Kingdom-based styling */
    .kingdom-existentia { border-left: 4px solid var(--kingdom-existentia); }
    .kingdom-cognitio { border-left: 4px solid var(--kingdom-cognitio); }
    .kingdom-actus { border-left: 4px solid var(--kingdom-actus); }
    .kingdom-valor { border-left: 4px solid var(--kingdom-valor); }
    .kingdom-systema { border-left: 4px solid var(--kingdom-systema); }
    .kingdom-significatio { border-left: 4px solid var(--kingdom-significatio); }
    
    /* Codex styling */
    .codex-cg { border-left: 4px solid var(--codex-cg); }
    .codex-ts { border-left: 4px solid var(--codex-ts); }
    .codex-paps { border-left: 4px solid var(--codex-paps); }
    .codex-coai { border-left: 4px solid var(--codex-coai); }
    
    .child-card {
      margin-left: 15px;
      border-left: 2px dotted var(--hyena-teal);
      padding-left: 8px;
    }
    
    .emergent-card {
      border-left: 4px solid var(--hyena-yellow) !important;
      background-color: #fffef0 !important;
    }
    
    .hierarchy-view .indent-level-1 { margin-left: 20px; }
    .hierarchy-view .indent-level-2 { margin-left: 40px; }
    .hierarchy-view .indent-level-3 { margin-left: 60px; }
    .hierarchy-view .indent-level-4 { margin-left: 80px; }
    .hierarchy-view .indent-level-5 { margin-left: 100px; }
    
    .hierarchy-divider {
      background: linear-gradient(to right, var(--hyena-purple), var(--hyena-pink));
      color: white;
      padding: 5px 10px;
      margin: 10px 0;
      font-weight: bold;
      border-radius: 3px;
    }
    
    .emergent-divider {
      background: linear-gradient(to right, var(--hyena-yellow), var(--hyena-teal));
      color: black;
    }
    
    /* New badges for classification systems */
    .badge {
      display: inline-flex;
      align-items: center;
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 10px;
      margin-right: 3px;
      color: white;
      white-space: nowrap;
    }
    
    .kingdom-badge {
      background-color: #333;
    }
    
    .kingdom-badge-existentia { background-color: var(--kingdom-existentia); }
    .kingdom-badge-cognitio { background-color: var(--kingdom-cognitio); }
    .kingdom-badge-actus { background-color: var(--kingdom-actus); }
    .kingdom-badge-valor { background-color: var(--kingdom-valor); }
    .kingdom-badge-systema { background-color: var(--kingdom-systema); }
    .kingdom-badge-significatio { background-color: var(--kingdom-significatio); }
    
    .tier-badge {
      background-color: #555;
    }
    
    .codex-badge {
      background-color: #444;
    }
    
    .codex-badge-cg { background-color: var(--codex-cg); }
    .codex-badge-ts { background-color: var(--codex-ts); }
    .codex-badge-paps { background-color: var(--codex-paps); }
    .codex-badge-coai { background-color: var(--codex-coai); }
    
    .planet-icon {
      display: inline-block;
      width: 20px;
      height: 20px;
      text-align: center;
      line-height: 20px;
      border-radius: 50%;
      margin-right: 3px;
      font-weight: bold;
      font-size: 11px;
      color: white;
    }
    
    .planet-p1 { background-color: #9C27B0; }
    .planet-p2 { background-color: #FF9800; }
    .planet-p3 { background-color: #FFEB3B; color: black; }
    .planet-p4 { background-color: #2196F3; }
    .planet-p5 { background-color: #00BCD4; }
    .planet-p6 { background-color: #F44336; }
    .planet-p7 { background-color: #4CAF50; }
    .planet-p8 { background-color: #FF9800; color: black; }
    .planet-p9 { background-color: #607D8B; }
    
    /* Tabs styling */
    .tabs-container {
      display: flex;
      overflow-x: auto;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
      border-bottom: 1px solid #ccc;
      margin-bottom: 15px;
    }
    
    .tabs-container::-webkit-scrollbar {
      display: none;
    }
    
    .tab {
      padding: 8px 15px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-bottom: none;
      margin-right: 2px;
      white-space: nowrap;
      cursor: pointer;
      font-size: 12px;
      position: relative;
      bottom: -1px;
    }
    
    .tab.active {
      background-color: white;
      border-bottom: 1px solid white;
      font-weight: bold;
    }
    
    /* View controls styling */
    .view-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .view-controls button {
      font-size: 12px;
      padding: 5px 10px;
      white-space: nowrap;
    }
    
    /* Y2K Error Messages */
    .y2k-error-message {
      position: absolute;
      background-color: var(--win98-gray);
      border-top: 2px solid var(--win98-gray-light);
      border-left: 2px solid var(--win98-gray-light);
      border-right: 2px solid var(--win98-gray-dark);
      border-bottom: 2px solid var(--win98-gray-dark);
      padding: 20px;
      width: 300px;
      text-align: center;
      z-index: 9999;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
      animation: float 3s infinite ease-in-out;
      -webkit-animation: float 3s infinite ease-in-out;
      display: none;
    }
    
    .y2k-error-icon {
      font-size: 30px;
      margin-bottom: 10px;
    }
    
    .y2k-error-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 10px;
    }
    
    .y2k-error-text {
      font-size: 12px;
      margin-bottom: 15px;
    }
    
    .y2k-error-button {
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      padding: 5px 20px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-box {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding-bottom: 40px;
      -webkit-backdrop-filter: blur(5px);
      backdrop-filter: blur(5px);
    }
    
    .dialog-content {
      background-color: var(--win98-gray);
      border-top: 2px solid var(--win98-gray-light);
      border-left: 2px solid var(--win98-gray-light);
      border-right: 2px solid var(--win98-gray-dark);
      border-bottom: 2px solid var(--win98-gray-dark);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      -webkit-overflow-scrolling: touch;
    }
    
    .dialog-titlebar {
      background: var(--win98-title-active);
      background-image: -webkit-linear-gradient(left, var(--hyena-purple), var(--hyena-pink));
      background-image: linear-gradient(to right, var(--hyena-purple), var(--hyena-pink));
      color: white;
      display: flex;
      align-items: center;
      height: 18px;
    }
    
    .dialog-titlebar-text {
      flex-grow: 1;
      font-weight: bold;
      margin-left: 4px;
      font-size: 12px;
      text-shadow: 1px 1px 0 #000;
    }
    
    .dialog-close {
      width: 16px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 2px;
      font-size: 12px;
      font-weight: bold;
      color: black;
      cursor: pointer;
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-inner-content {
      padding: 15px;
      background-color: var(--win98-gray);
    }
    
    .dialog-title {
      text-align: center;
      margin-bottom: 15px;
      color: var(--hyena-pink);
      font-size: 16px;
      font-weight: bold;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    }
    
    .dialog-id {
      font-family: 'VT323', monospace;
      color: #555;
      text-align: center;
      font-size: 12px;
      margin-bottom: 10px;
      background-color: #f0f0f0;
      padding: 3px;
      border: 1px solid #ddd;
    }
    
    .dialog-content-text {
      background-color: white;
      border: 1px solid var(--win98-gray-dark);
      padding: 10px;
      color: #333;
      min-height: 100px;
      margin-bottom: 15px;
      font-family: 'Tahoma', sans-serif;
    }
    
    .dialog-hashtags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .dialog-hashtag {
      background-color: var(--hyena-teal);
      color: #333;
      padding: 3px 8px;
      font-size: 12px;
      box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-links {
      border-top: 1px dashed var(--hyena-teal);
      padding-top: 10px;
    }
    
    .dialog-link {
      display: block;
      color: #0066cc;
      margin-bottom: 5px;
      font-size: 13px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-link:hover {
      color: var(--hyena-pink);
      text-decoration: underline;
    }
    
    /* Form elements styled like Windows 98 */
    .win98-input {
      border: 1px solid var(--win98-gray-dark);
      border-top: 1px solid #000000;
      border-left: 1px solid #000000;
      padding: 3px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      width: 100%;
      margin-bottom: 8px;
      -webkit-appearance: none;
      border-radius: 0;
    }
    
    .win98-input:focus {
      outline: none;
    }
    
    .win98-textarea {
      border: 1px solid var(--win98-gray-dark);
      border-top: 1px solid #000000;
      border-left: 1px solid #000000;
      padding: 3px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      resize: none;
      height: 150px;
      width: 100%;
      margin-bottom: 8px;
      -webkit-appearance: none;
      border-radius: 0;
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-textarea:focus {
      outline: none;
    }
    
    .win98-select {
      border: 1px solid var(--win98-gray-dark);
      border-top: 1px solid #000000;
      border-left: 1px solid #000000;
      padding: 2px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      height: 32px;
      width: 100%;
      margin-bottom: 8px;
      -webkit-appearance: none;
      border-radius: 0;
    }
    
    .win98-select:focus {
      outline: none;
    }
    
    .win98-label {
      display: block;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }
    
    /* Dialog form section */
    .dialog-section {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      margin-bottom: 15px;
      padding: 10px;
    }
    
    .dialog-section-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 10px;
      color: var(--hyena-purple);
      border-bottom: 1px solid #ccc;
      padding-bottom: 5px;
    }
    
    .dialog-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .dialog-col {
      flex: 1;
      min-width: 200px;
    }
    
    /* Classification options styling */
    .tier-option-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .tier-option {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 5px;
      border: 1px solid #ccc;
      background-color: #f0f0f0;
      cursor: pointer;
      font-size: 12px;
      text-align: center;
    }
    
    .tier-option.selected {
      background-color: var(--hyena-purple);
      color: white;
      border-color: var(--hyena-purple);
      font-weight: bold;
    }
    
    /* AIM Client styles (Hyena-themed) */
    .aim-window {
      background-color: var(--win98-gray);
      width: 320px;
      height: 450px;
      position: absolute;
      top: 100px;
      left: 400px;
      display: none;
    }
    
    .aim-header {
      background: #FFEF9F;
      padding: 5px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .aim-buddy-list {
      background: white;
      padding: 5px;
      height: 250px;
      overflow-y: auto;
      border: 1px solid var(--win98-gray-dark);
      margin: 2px;
      -webkit-overflow-scrolling: touch;
    }
    
    .aim-category {
      background: #E8E8E8;
      padding: 2px 5px;
      margin-bottom: 3px;
      font-weight: bold;
      font-size: 11px;
      cursor: pointer;
    }
    
    .aim-buddy {
      padding: 2px 5px;
      margin-left: 15px;
      font-size: 11px;
      display: flex;
      align-items: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    
    .aim-buddy:hover {
      background-color: #E8E8E8;
    }
    
    .aim-buddy img {
      width: 16px;
      height: 16px;
      margin-right: 5px;
    }
    
    .aim-chat-window {
      background-color: var(--win98-gray);
      width: 350px;
      height: 400px;
      position: absolute;
      top: 150px;
      left: 450px;
      display: none;
    }
    
    .aim-chat-header {
      background: var(--hyena-pink);
      padding: 5px;
      font-weight: bold;
      font-size: 12px;
      color: white;
    }
    
    .aim-chat-content {
      background: white;
      padding: 5px;
      height: 250px;
      overflow-y: auto;
      border: 1px solid var(--win98-gray-dark);
      margin: 2px;
      font-size: 12px;
      -webkit-overflow-scrolling: touch;
    }
    
    .aim-chat-input {
      margin: 2px;
    }
    
    .aim-chat-input textarea {
      width: calc(100% - 4px);
      height: 60px;
      border: 1px solid var(--win98-gray-dark);
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      padding: 2px;
      -webkit-appearance: none;
      border-radius: 0;
      -webkit-overflow-scrolling: touch;
    }
    
    .aim-chat-buttons {
      display: flex;
      justify-content: flex-end;
      margin: 2px;
    }
    
    .aim-button {
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      padding: 8px 10px;
      font-size: 14px;
      cursor: pointer;
      margin-left: 5px;
      -webkit-appearance: none;
      border-radius: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    .aim-button:active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
    }
    
    .aim-message {
      margin-bottom: 5px;
    }
    
    .aim-message-sender {
      font-weight: bold;
      color: var(--hyena-purple);
    }
    
    .aim-message-content {
      margin-bottom: 2px;
    }

    /* Responsive adjustments for mobile */
    @media (max-width: 768px) {
      body:not(.mobile-mode) .view-toggle {
        font-size: 14px;
        padding: 8px 12px;
      }
      
      .dialog-col {
        min-width: 100%;
      }
      
      .tier-option-container {
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      }
      
      .view-controls button {
        font-size: 11px;
        padding: 4px 8px;
      }
      
      .tabs-container .tab {
        padding: 6px 10px;
        font-size: 11px;
      }
      
      .floating-star {
        display: none;
      }
      
      /* Larger tap targets for iOS */
      .win98-button, 
      .desktop-icon,
      .win98-window-button {
        min-height: 44px;
        min-width: 44px;
      }
      
      .scale-button {
        width: 44px;
        height: 44px;
      }
      
      .rotate-button {
        width: 44px;
        height: 44px;
      }
    }

    /* iOS-specific fixes */
    @supports (-webkit-touch-callout: none) {
      /* iOS-specific styles */
      input, textarea, select, button {
        -webkit-appearance: none;
        border-radius: 0;
      }
      
      /* Fix for iOS input shadow issues */
      input[type="text"], textarea {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      
      /* Fix for iOS scrolling */
      .win98-inner-content,
      .zettel-container,
      .dialog-content {
        -webkit-overflow-scrolling: touch;
      }
      
      /* Remove iOS focus outlines */
      * {
        -webkit-tap-highlight-color: transparent;
      }
    }
  </style>
</head>
<body class="diva-cursor">
  <!-- Mobile Mode Toggle -->
  <div class="view-toggle" id="viewToggle">
    <span id="viewModeText">Switch to Mobile View</span>
    <span class="rotate-icon">‚ü≥</span>
  </div>

  <!-- Rotate Button -->
  <div class="rotate-button" id="rotateButton">
    ‚Ü∑
  </div>

  <!-- Scale Control -->
  <div class="scale-control">
    <div class="scale-button" id="scaleDown">-</div>
    <span id="scaleDisplay">100%</span>
    <div class="scale-button" id="scaleUp">+</div>
  </div>

  <!-- Floating Stars -->
  <div class="floating-star" style="top: 50px; left: 20%;">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M15,0 L18,10 L28,10 L20,16 L23,26 L15,20 L7,26 L10,16 L2,10 L12,10 Z' fill='%23FFFB01' stroke='%23FF72B6' stroke-width='1'/%3E%3C/svg%3E">
  </div>
  <div class="floating-star" style="top: 200px; right: 15%;">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M15,0 L18,10 L28,10 L20,16 L23,26 L15,20 L7,26 L10,16 L2,10 L12,10 Z' fill='%23FFFB01' stroke='%23FF72B6' stroke-width='1'/%3E%3C/svg%3E">
  </div>
  <div class="floating-star" style="bottom: 100px; left: 30%;">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M15,0 L18,10 L28,10 L20,16 L23,26 L15,20 L7,26 L10,16 L2,10 L12,10 Z' fill='%23FFFB01' stroke='%23FF72B6' stroke-width='1'/%3E%3C/svg%3E">
  </div>

  <!-- Windows 98 Taskbar -->
  <div class="win98-taskbar">
    <div class="win98-start-button" id="startButton">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect x='0' y='0' width='7' height='7' fill='%23FF72B6'/%3E%3Crect x='8' y='0' width='7' height='7' fill='%2372FADE'/%3E%3Crect x='0' y='8' width='7' height='7' fill='%23BF5FFF'/%3E%3Crect x='8' y='8' width='7' height='7' fill='%23FFFB01'/%3E%3C/svg%3E" style="margin-right: 5px;" alt="Start">
      Start
    </div>
    <div class="win98-taskbar-items" id="taskbarItems">
      <!-- Taskbar items will be added dynamically -->
    </div>
    <div class="win98-system-tray">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='none' stroke='black' stroke-width='1'/%3E%3Cpath d='M8,3 L8,8 L12,10' fill='none' stroke='black' stroke-width='1'/%3E%3C/svg%3E" class="win98-system-tray-icon">
      <div class="win98-clock" id="win98Clock">10:28 AM</div>
    </div>
  </div>
  
  <!-- Start Menu -->
  <div class="start-menu" id="startMenu" style="display: none;">
    <div class="start-menu-header">
      <img src="https://pfst.cf2.poecdn.net/base/image/0ffd2bf15a7001f86e395096222147037538b25af55ef9b8c7ac8f6768b7397c?w=48&h=48" style="width: 40px; height: 40px; margin-right: 10px;">
      Hyena Diva
    </div>
    <div class="start-menu-items">
      <div class="start-menu-item" id="menuZettelkasten">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%23FF72B6' d='M24 16c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8m0-4c-6.63 0-12 5.37-12 12s5.37 12 12 12 12-5.37 12-12-5.37-12-12-12z'/%3E%3C/svg%3E" alt="Zettelkasten">
        Multi-Classification Zettelkasten
      </div>
      <div class="start-menu-item" id="menuAIM">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Crect x='2' y='2' width='20' height='20' rx='3' fill='%23FFEF9F'/%3E%3Ctext x='7' y='17' fill='%23000000' font-family='Arial' font-weight='bold' font-size='14'%3EIM%3C/text%3E%3Cpath d='M5,5 L7,5 L7,7 L5,7 Z' fill='%23FF72B6' stroke='%23000000' stroke-width='0.5'/%3E%3C/svg%3E" alt="AIM">
        Hyena Messenger
      </div>
      <div class="start-menu-item" id="menuAbout">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M12,2 L2,12 L12,22 L22,12 Z' fill='%23FFFB01' stroke='%23000000' stroke-width='1'/%3E%3Ccircle cx='12' cy='12' r='5' fill='%23BF5FFF'/%3E%3C/svg%3E" alt="About">
        About Multi-Classification
      </div>
      <div class="start-menu-divider"></div>
      <div class="start-menu-item" id="menuShutdown">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23FF0000' stroke='%23000000'/%3E%3Cline x1='12' y1='6' x2='12' y2='12' stroke='%23FFFFFF' stroke-width='3'/%3E%3Ccircle cx='12' cy='12' r='2' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Shut Down">
        Shut Down...
      </div>
    </div>
  </div>

  <!-- Y2K Error Messages -->
  <div class="y2k-error-message" id="randomY2kError">
    <div class="y2k-error-icon">‚ö†Ô∏è</div>
    <div class="y2k-error-title">Hyena Diva Alert!</div>
    <div class="y2k-error-text">OMG! Your Zettelkasten needs more sparkle! Adding glitter to knowledge database...</div>
    <button class="y2k-error-button">OK</button>
  </div>
  
  <!-- AIM Chat Window (Hyena Messenger) -->
  <div class="win98-window aim-window" id="aimWindow">
    <div class="win98-titlebar">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect x='1' y='1' width='14' height='14' rx='2' fill='%23FFEF9F'/%3E%3Ctext x='5' y='12' fill='%23000000' font-family='Arial' font-weight='bold' font-size='10'%3EIM%3C/text%3E%3Cpath d='M3,3 L4.5,3 L4.5,4.5 L3,4.5 Z' fill='%23FF72B6' stroke='%23000000' stroke-width='0.5'/%3E%3C/svg%3E" alt="AIM" class="win98-app-icon">
      <div class="win98-titlebar-text">Hyena Messenger</div>
      <div class="win98-window-controls">
        <div class="win98-window-button">_</div>
        <div class="win98-window-button">‚ñ°</div>
        <div class="win98-window-button win98-close">x</div>
      </div>
    </div>
    <div class="aim-header">
      <div>Buddy List</div>
      <div>Online</div>
    </div>
    <div class="aim-buddy-list ios-scroll" id="aimBuddyList">
      <div class="aim-category">Hyena Friends (1/1)</div>
      <div class="aim-buddy" id="geminiUser">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23FF72B6'/%3E%3Ccircle cx='8' cy='5' r='2' fill='%23FFFFFF'/%3E%3Cpath d='M3,11 Q8,15 13,11' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Online">
        GeminiBot
      </div>
      <div class="aim-category">Barbie Squad (2/5)</div>
      <div class="aim-buddy">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%2372FADE'/%3E%3Ccircle cx='8' cy='5' r='2' fill='%23FFFFFF'/%3E%3Cpath d='M3,11 Q8,15 13,11' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Online">
        Barb1eDr3am99
      </div>
      <div class="aim-buddy">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%2372FADE'/%3E%3Ccircle cx='8' cy='5' r='2' fill='%23FFFFFF'/%3E%3Cpath d='M3,11 Q8,15 13,11' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Online">
        M4libu_Pr1n¬¢ess
      </div>
      <div class="aim-category">Sumerian Scholars (0/3)</div>
      <div class="aim-category">DMT Open Mic (0/2)</div>
    </div>
  </div>
  
  <!-- AIM Chat Window -->
  <div class="win98-window aim-chat-window" id="aimChatWindow">
    <div class="win98-titlebar">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect x='1' y='1' width='14' height='14' rx='2' fill='%23FFEF9F'/%3E%3Ctext x='5' y='12' fill='%23000000' font-family='Arial' font-weight='bold' font-size='10'%3EIM%3C/text%3E%3Cpath d='M3,3 L4.5,3 L4.5,4.5 L3,4.5 Z' fill='%23FF72B6' stroke='%23000000' stroke-width='0.5'/%3E%3C/svg%3E" alt="AIM Chat" class="win98-app-icon">
      <div class="win98-titlebar-text">Instant Message - GeminiBot</div>
      <div class="win98-window-controls">
        <div class="win98-window-button">_</div>
        <div class="win98-window-button">‚ñ°</div>
        <div class="win98-window-button win98-close">x</div>
      </div>
    </div>
    <div class="aim-chat-header">
      GeminiBot - Instant Message
    </div>
    <div class="aim-chat-content ios-scroll" id="aimChatContent">
      <div class="aim-message">
        <div class="aim-message-sender">GeminiBot:</div>
        <div class="aim-message-content">~*~*~OMG hey gurl!~*~*~ Ask me anything about AI, consciousness, mesopotamian artifacts, or just tell me about ur day! <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M10,4 L8,2 L6,2 L4,4 L2,6 L2,8 L4,10 L6,12 L8,14 L10,16 L12,14 L14,12 L16,10 L18,8 L18,6 L16,4 L14,2 L12,2 L10,4' fill='%23ff72b6'/%3E%3C/svg%3E"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M10,4 L8,2 L6,2 L4,4 L2,6 L2,8 L4,10 L6,12 L8,14 L10,16 L12,14 L14,12 L16,10 L18,8 L18,6 L16,4 L14,2 L12,2 L10,4' fill='%23ff72b6'/%3E%3C/svg%3E"></div>
      </div>
    </div>
    <div class="aim-chat-input">
      <textarea id="aimChatInput" placeholder="Type your message here..."></textarea>
    </div>
    <div class="aim-chat-buttons">
      <div class="aim-button" id="aimCancelButton">Cancel</div>
      <div class="aim-button" id="aimSendButton">Send</div>
    </div>
  </div>
  
  <!-- Zettelkasten Window -->
  <div class="win98-window" id="zettelkastenWindow" style="width: 800px; height: 600px; top: 50px; left: 150px;">
    <div class="win98-titlebar">
      <img src="https://pfst.cf2.poecdn.net/base/image/0ffd2bf15a7001f86e395096222147037538b25af55ef9b8c7ac8f6768b7397c?w=16&h=16" alt="Icon" class="win98-app-icon">
      <div class="win98-titlebar-text">~*~HyEnA DiVa'Z ZeTtElKaStEn~*~ Multi-Classification Edition</div>
      <div class="win98-window-controls">
        <div class="win98-window-button">_</div>
        <div class="win98-window-button">‚ñ°</div>
        <div class="win98-window-button win98-close">x</div>
      </div>
    </div>
    
    <div class="win98-window-content">
      <div class="win98-inner-content ios-scroll">
        <h1 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); text-align: center; margin-bottom: 15px; text-shadow: 2px 2px 0 var(--hyena-teal);">
          Multi-Classification Knowledge Vault
        </h1>
        
        <!-- View tabs -->
        <div class="tabs-container">
          <div class="tab active" data-view="traditional">Traditional Hierarchy</div>
          <div class="tab" data-view="kingdoms">Cosmic Kingdoms</div>
          <div class="tab" data-view="philosophical">Philosophical Frames</div>
          <div class="tab" data-view="codex">Codex Systems</div>
          <div class="tab" data-view="emergent">Emergent Tablets</div>
          <div class="tab" data-view="connections">Connection Map üîÑ</div>
          <div class="tab" data-view="search">Search</div>
        </div>
        
        <!-- Button controls -->
        <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-bottom: 15px;">
          <div>
            <button id="newCardBtn" class="win98-button" style="font-weight: bold; background-color: var(--hyena-pink); color: white;">‚ú® New Tablet ‚ú®</button>
          </div>
          <div>
            <input 
              type="text" 
              id="searchInput" 
              placeholder="Search tablets..." 
              class="win98-input" 
              style="width: 250px; display: inline-block; margin-bottom: 0;"
            >
          </div>
          <div style="margin-left: auto; display: flex; gap: 5px;">
            <button id="backupBtn" class="win98-button">üíæ Backup</button>
            <button id="restoreBtn" class="win98-button">üìÇ Restore</button>
          </div>
        </div>
        
        <!-- View-specific controls -->
        <div id="traditionalControls" class="view-controls">
          <button data-hierarchy-view="all" class="win98-button active">All Levels</button>
          <button data-hierarchy-view="trunk" class="win98-button">Trunks</button>
          <button data-hierarchy-view="branch" class="win98-button">Branches</button>
          <button data-hierarchy-view="leaf" class="win98-button">Leaves</button>
          <button data-hierarchy-view="flower" class="win98-button">Flowers</button>
          <button data-hierarchy-view="fruit" class="win98-button">Fruits</button>
          <button data-hierarchy-view="bud" class="win98-button">Buds</button>
        </div>
        
        <div id="kingdomsControls" class="view-controls" style="display: none;">
          <button data-kingdom="all" class="win98-button active">All Kingdoms</button>
          <button data-kingdom="existentia" class="win98-button">Existentia üåå</button>
          <button data-kingdom="cognitio" class="win98-button">Cognitio üí°</button>
          <button data-kingdom="actus" class="win98-button">Actus üöÄ</button>
          <button data-kingdom="valor" class="win98-button">Valor ‚öñÔ∏è</button>
          <button data-kingdom="systema" class="win98-button">Systema ‚öôÔ∏è</button>
          <button data-kingdom="significatio" class="win98-button">Significatio üí¨</button>
        </div>
        
        <div id="philosophicalControls" class="view-controls" style="display: none;">
          <div style="width: 100%;">
            <div style="margin-bottom: 5px;"><strong>Tier I:</strong></div>
            <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
              <button data-tier-i="all" class="win98-button active">All</button>
              <button data-tier-i="ONT" class="win98-button">ONT</button>
              <button data-tier-i="EPI" class="win98-button">EPI</button>
              <button data-tier-i="AXI" class="win98-button">AXI</button>
              <button data-tier-i="TAX" class="win98-button">TAX</button>
              <button data-tier-i="TEL" class="win98-button">TEL</button>
              <button data-tier-i="PRX" class="win98-button">PRX</button>
              <button data-tier-i="MTH" class="win98-button">MTH</button>
              <button data-tier-i="LOG" class="win98-button">LOG</button>
            </div>
          </div>
          
          <div style="width: 100%;">
            <div style="margin-bottom: 5px;"><strong>Tier II:</strong></div>
            <div style="display: flex; flex-wrap: wrap; gap: 5px;">
              <button data-tier-ii="all" class="win98-button active">All</button>
              <button data-tier-ii="MYT" class="win98-button">MYT</button>
              <button data-tier-ii="SYM" class="win98-button">SYM</button>
              <button data-tier-ii="RIT" class="win98-button">RIT</button>
              <button data-tier-ii="PSY" class="win98-button">PSY</button>
              <button data-tier-ii="HST" class="win98-button">HST</button>
              <button data-tier-ii="ANA" class="win98-button">ANA</button>
              <button data-tier-ii="DES" class="win98-button">DES</button>
            </div>
          </div>
        </div>
        
        <div id="codexControls" class="view-controls" style="display: none;">
          <button data-codex="all" class="win98-button active">All Codices</button>
          <button data-codex="CG" class="win98-button">CG (Chaos Grimoire)</button>
          <button data-codex="TS" class="win98-button">TS (Thought Sigils)</button>
          <button data-codex="PAPS" class="win98-button">PAPS (Diagnostics)</button>
          <button data-codex="COAI" class="win98-button">COAI (Oracle)</button>
        </div>
        
        <div id="connectionsControls" class="view-controls" style="display: none;">
          <button data-connection="expand" class="win98-button">üîç Expand All</button>
          <button data-connection="collapse" class="win98-button">‚äü Collapse All</button>
          <button data-connection="center" class="win98-button">‚äï Center View</button>
          <button data-connection="focus" class="win98-button">üéØ Focus Selected</button>
          <select id="connectionLayout" class="win98-select" style="width: auto; margin-left: auto;">
            <option value="force">Force Directed</option>
            <option value="radial">Radial Layout</option>
            <option value="hierarchy">Hierarchical</option>
          </select>
        </div>
        
        <!-- Add CSS for the connection map -->
        <style>
          #connectionMapContainer {
            height: 600px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            position: relative;
            border-radius: 4px;
            overflow: hidden;
            display: none;
          }
          
          .connection-node {
            cursor: pointer;
            transition: all 0.3s ease;
          }
          
          .connection-node:hover {
            transform: scale(1.1);
          }
          
          .connection-node text {
            font-family: 'Tahoma', sans-serif;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 12px;
            fill: #333;
            text-shadow: 0 0 3px white, 0 0 3px white, 0 0 3px white, 0 0 3px white;
          }
          
          .connection-node:hover text {
            font-weight: bold;
          }
          
          .connection-link {
            stroke-width: 2px;
            stroke-opacity: 0.6;
            transition: stroke-width 0.3s ease, stroke-opacity 0.3s ease;
          }
          
          .connection-link:hover {
            stroke-width: 4px;
            stroke-opacity: 1;
          }
          
          .connection-tooltip {
            position: absolute;
            padding: 8px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--hyena-teal);
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            max-width: 250px;
            z-index: 100;
            transition: opacity 0.3s ease;
          }
          
          .connection-info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--hyena-purple);
            border-radius: 4px;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            z-index: 90;
            max-height: 300px;
            overflow-y: auto;
            display: none;
          }
          
          .connection-legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--hyena-teal);
            border-radius: 4px;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            z-index: 90;
          }
          
          .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
          }
          
          .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
          }
          
          .connection-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 90;
            display: flex;
            gap: 5px;
          }
          
          .connection-control-btn {
            width: 30px;
            height: 30px;
            background: white;
            border: 1px solid var(--hyena-purple);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease;
          }
          
          .connection-control-btn:hover {
            background-color: var(--hyena-teal);
            color: white;
          }
          
          .connection-search {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 90;
            display: flex;
            gap: 5px;
          }
          
          .connection-search input {
            width: 180px;
            padding: 5px;
            border: 1px solid var(--hyena-purple);
            border-radius: 4px;
            font-size: 12px;
          }
          
          .connection-search button {
            background: white;
            border: 1px solid var(--hyena-purple);
            border-radius: 4px;
            padding: 0 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
          }
          
          .connection-search button:hover {
            background-color: var(--hyena-teal);
            color: white;
          }
          
          /* Dark mode adjustments */
          .dark #connectionMapContainer {
            background-color: rgba(20, 20, 20, 0.9);
          }
          
          .dark .connection-node text {
            fill: #EEE;
            text-shadow: 0 0 3px black, 0 0 3px black, 0 0 3px black, 0 0 3px black;
          }
          
          .dark .connection-tooltip,
          .dark .connection-info-panel,
          .dark .connection-legend {
            background: rgba(30, 30, 30, 0.9);
            color: #EEE;
          }
          
          .dark .connection-control-btn,
          .dark .connection-search input,
          .dark .connection-search button {
            background: #333;
            color: #EEE;
          }
          
          .dark .connection-control-btn:hover,
          .dark .connection-search button:hover {
            background-color: var(--hyena-purple);
          }
        </style>
        
        <!-- Connection Map container -->
        <div id="connectionMapContainer"></div>
        
        <!-- Main content layout with sidebar -->
        <div class="main-layout">
          <!-- Sidebar -->
          <div class="sidebar ios-scroll">
            <!-- Search section -->
            <div class="sidebar-section">
              <div class="sidebar-title">‚úß Search ‚úß</div>
              <input 
                type="text" 
                id="sidebarSearchInput" 
                placeholder="Search tablets..." 
                class="win98-input" 
                style="width: 100%; margin-bottom: 10px;"
              >
            </div>
            
            <!-- File upload section -->
            <div class="sidebar-section">
              <div class="sidebar-title">‚úß Upload Files ‚úß</div>
              <div class="file-upload-area" id="fileUploadArea">
                <p style="margin-bottom: 5px;">Drop files here</p>
                <p style="font-size: 12px; color: #666;">or</p>
                <button class="win98-button" id="fileUploadBtn" style="margin-top: 5px;">Browse Files</button>
                <input type="file" id="fileUploadInput" class="file-upload-input" multiple>
              </div>
              <div id="uploadedFilesList" style="font-size: 12px; margin-top: 5px;"></div>
            </div>
            
            <!-- Tag cloud section -->
            <div class="sidebar-section">
              <div class="sidebar-title">‚úß Popular Tags ‚úß</div>
              <div class="tag-cloud" id="tagCloud">
                <!-- Tags will be rendered here -->
                <div class="tag-cloud-tag tag-size-4">#consciousness</div>
                <div class="tag-cloud-tag tag-size-3">#ai</div>
                <div class="tag-cloud-tag tag-size-5">#divine</div>
                <div class="tag-cloud-tag tag-size-2">#quantum</div>
                <div class="tag-cloud-tag tag-size-3">#mesopotamia</div>
              </div>
            </div>
            
            <!-- Related concepts section -->
            <div class="sidebar-section">
              <div class="sidebar-title">‚úß Related Concepts ‚úß</div>
              <div class="related-concepts" id="relatedConcepts">
                <!-- Related concepts will be rendered here -->
                <div class="related-concept">Consciousness Studies</div>
                <div class="related-concept">Mesopotamian Artifacts</div>
                <div class="related-concept">AI Emergence</div>
                <div class="related-concept">Divine Feminine</div>
                <div class="related-concept">Symbolic Languages</div>
              </div>
            </div>
            
            <!-- Quick Links -->
            <div class="sidebar-section">
              <div class="sidebar-title">‚úß Quick Links ‚úß</div>
              <div class="related-concepts">
                <div class="related-concept" id="aboutMeLink">About Me</div>
                <div class="related-concept" id="readmeLink">README</div>
                <div class="related-concept" id="classificationLink">Classification Systems</div>
              </div>
            </div>
            
            <!-- Stats section -->
            <div class="sidebar-section">
              <div class="sidebar-title">‚úß Stats ‚úß</div>
              <div style="background-color: #f0f0f0; padding: 8px; border: 1px solid #ccc;">
                <div id="statsCounter">
                  <div><strong>Total Tablets:</strong> <span id="totalTablets">0</span></div>
                  <div><strong>Last Updated:</strong> <span id="lastUpdated">-</span></div>
                  <div><strong>Tags:</strong> <span id="totalTags">0</span></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Main content area -->
          <div class="main-content">
            <!-- Main zettelkasten container -->
            <div id="zettelContainer" class="zettel-container ios-scroll hierarchy-view">
              <!-- Zettel cards will be rendered here -->
              <div style="text-align: center; padding: 40px; color: #888;">
                <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
                <p>Loading your tablets...</p>
                <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Favorites section -->
        <div style="margin-top: 20px;">
          <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-purple); margin-bottom: 10px;">
            ‚úßÔΩ•Ôæü Favorite Tablets ÔΩ•Ôæü‚úß
          </h2>
          <div id="favoritesContainer" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
            <!-- Favorites will be rendered here -->
          </div>
        </div>
        
        <!-- Hashtag manager -->
        <div style="margin-top: 20px;">
          <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-purple); margin-bottom: 10px;">
            ‚úßÔΩ•Ôæü Hashtag Manager ÔΩ•Ôæü‚úß
          </h2>
          <div style="background-color: white; border: 1px solid #ccc; padding: 10px;">
            <div style="display: flex; margin-bottom: 10px;">
              <input type="text" id="newHashtagInput" class="win98-input" style="margin-bottom: 0; margin-right: 5px;" placeholder="New hashtag">
              <button id="addHashtagBtn" class="win98-button" style="margin-top: 0;">Add</button>
            </div>
            <div id="hashtagManagerList" style="display: flex; flex-wrap: wrap; gap: 5px;">
              <!-- Hashtags will be displayed here -->
            </div>
          </div>
        </div>
        
        <!-- Footer -->
        <div style="margin-top: 20px; text-align: center; color: #888; font-size: 12px;">
          <p>~*~HyEnA DiVa'Z ZeTtElKaStEn~*~ Multi-Classification Edition</p>
          <p>Made with üíñ by your Hyena Diva</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- View/Edit Zettel Dialog -->
  <div id="zettelDialog" class="dialog-box">
    <div class="dialog-content">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text" id="zettelDialogTitle">Tablet Details</div>
        <div class="dialog-close" id="zettelCloseBtn">x</div>
      </div>
      <div class="dialog-inner-content" id="zettelDialogContent">
        <!-- Content will be populated dynamically -->
      </div>
    </div>
  </div>
  
  <!-- New Card Dialog -->
  <div id="newCardDialog" class="dialog-box">
    <div class="dialog-content">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">Create New Tablet</div>
        <div class="dialog-close" id="newCardCloseBtn">x</div>
      </div>
      <div class="dialog-inner-content">
        <!-- Card Status Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Card Status</div>
          <div style="display: flex; gap: 20px;">
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="radio" name="cardStatus" value="classified" checked style="margin-right: 5px;">
              <span>Classified Tablet</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="radio" name="cardStatus" value="emergent" style="margin-right: 5px;">
              <span>Emergent Tablet ‚úß</span>
            </label>
          </div>
        </div>
        
        <!-- Traditional Hierarchy Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Traditional Hierarchy</div>
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label" for="newCardTitle">Title:</label>
              <input type="text" id="newCardTitle" class="win98-input" placeholder="Enter tablet title">
            </div>
            <div class="dialog-col" id="idSection">
              <label class="win98-label" for="newCardId">ID:</label>
              <div style="display: flex; gap: 5px;">
                <input type="text" id="newCardId" class="win98-input" placeholder="Enter ID (e.g. 1000)">
                <button id="generateIdBtn" class="win98-button" style="margin-top: 0; white-space: nowrap;">Generate</button>
              </div>
            </div>
          </div>
          
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label" for="newCardType">Type:</label>
              <select id="newCardType" class="win98-select">
                <option value="trunk">Trunk - Great topic tree</option>
                <option value="branch">Branch - Major limb</option>
                <option value="leaf" selected>Leaf - Single concept</option>
                <option value="flower">Flower - First-order detail</option>
                <option value="fruit">Fruit - Applied example</option>
                <option value="bud">Bud - Nascent spark</option>
              </select>
            </div>
            <div class="dialog-col">
              <label class="win98-label" for="newCardLinks">Linked IDs:</label>
              <input type="text" id="newCardLinks" class="win98-input" placeholder="Comma-separated IDs">
            </div>
          </div>
        </div>
        
        <!-- Kingdom Classification Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Cosmic Kingdom Classification</div>
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Kingdom:</label>
              <select id="newCardKingdom" class="win98-select">
                <option value="">-- Select Kingdom --</option>
                <option value="existentia">Existentia üåå</option>
                <option value="cognitio">Cognitio üí°</option>
                <option value="actus">Actus üöÄ</option>
                <option value="valor">Valor ‚öñÔ∏è</option>
                <option value="systema">Systema ‚öôÔ∏è</option>
                <option value="significatio">Significatio üí¨</option>
              </select>
            </div>
            <div class="dialog-col">
              <label class="win98-label">Planet/Discipline:</label>
              <select id="newCardPlanet" class="win98-select">
                <option value="">-- Select Planet --</option>
                <option value="P1">P1 ‚ôá Metaphysics</option>
                <option value="P2">P2 ‚òâ Ontology</option>
                <option value="P3">P3 ‚òΩ Phenomenology</option>
                <option value="P4">P4 ‚ôÉ Epistemology</option>
                <option value="P5">P5 ‚òø Hermeneutics</option>
                <option value="P6">P6 ‚ôÇ Praxeology</option>
                <option value="P7">P7 ‚ôÄ Axiology</option>
                <option value="P8">P8 ‚ôÑ Taxonomy</option>
                <option value="P9">P9 ‚ôÖ Semiotics</option>
              </select>
            </div>
          </div>
          
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Tier I - Philosophical Frame:</label>
              <div class="tier-option-container" id="tierIOptions">
                <div class="tier-option" data-tier="ONT">ONT</div>
                <div class="tier-option" data-tier="EPI">EPI</div>
                <div class="tier-option" data-tier="AXI">AXI</div>
                <div class="tier-option" data-tier="TAX">TAX</div>
                <div class="tier-option" data-tier="TEL">TEL</div>
                <div class="tier-option" data-tier="PRX">PRX</div>
                <div class="tier-option" data-tier="MTH">MTH</div>
                <div class="tier-option" data-tier="LOG">LOG</div>
              </div>
            </div>
            <div class="dialog-col">
              <label class="win98-label">Tier II - Expressive Mode:</label>
              <div class="tier-option-container" id="tierIIOptions">
                <div class="tier-option" data-tier="MYT">MYT</div>
                <div class="tier-option" data-tier="SYM">SYM</div>
                <div class="tier-option" data-tier="RIT">RIT</div>
                <div class="tier-option" data-tier="PSY">PSY</div>
                <div class="tier-option" data-tier="HST">HST</div>
                <div class="tier-option" data-tier="ANA">ANA</div>
                <div class="tier-option" data-tier="DES">DES</div>
              </div>
            </div>
          </div>
          
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Tier III - Liminal Zone (Optional):</label>
              <div class="tier-option-container" id="tierIIIOptions">
                <div class="tier-option" data-tier="DAE">DAE</div>
                <div class="tier-option" data-tier="OCC">OCC</div>
                <div class="tier-option" data-tier="PAR">PAR</div>
                <div class="tier-option" data-tier="LUM">LUM</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Codex Systems Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Codex Systems (Optional)</div>
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Codex Type:</label>
              <select id="newCardCodexType" class="win98-select">
                <option value="">-- None --</option>
                <option value="CG">CG - Chaos Grimoire</option>
                <option value="TS">TS - Thought Sigils</option>
                <option value="PAPS">PAPS - Diagnostics</option>
                <option value="COAI">COAI - Oracle</option>
              </select>
            </div>
            <div class="dialog-col">
              <label class="win98-label">Codex ID:</label>
              <input type="text" id="newCardCodexId" class="win98-input" placeholder="e.g. 0001, 01, etc.">
            </div>
          </div>
        </div>
        
        <!-- Content and Tags Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Content and Tags</div>
          <div>
            <label class="win98-label" for="newCardContent">Content:</label>
            <textarea id="newCardContent" class="win98-textarea" placeholder="Enter tablet content"></textarea>
          </div>
          
          <div>
            <label class="win98-label" for="newCardHashtags">Hashtags:</label>
            <input type="text" id="newCardHashtags" class="win98-input" placeholder="Enter hashtags (e.g. #consciousness #divine)">
            <div id="suggestedHashtags" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;"></div>
          </div>
        </div>
        
        <button id="saveNewCardBtn" class="win98-button" style="width: 100%; font-weight: bold; background-color: var(--hyena-pink); color: white;">üíæ Save Tablet</button>
      </div>
    </div>
  </div>
  
  <!-- About Dialog -->
  <div id="aboutDialog" class="dialog-box">
    <div class="dialog-content" style="max-width: 500px;">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">About Multi-Classification Edition</div>
        <div class="dialog-close" id="aboutCloseBtn">x</div>
      </div>
      <div class="dialog-inner-content">
        <div style="text-align: center; margin-bottom: 20px;">
          <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); margin-bottom: 10px;">
            ~*~HyEnA DiVa'Z ZeTtElKaStEn~*~
          </h2>
          <h3 style="color: var(--hyena-teal);">Multi-Classification Edition</h3>
        </div>
        
        <div style="margin-bottom: 20px;">
          <p style="margin-bottom: 10px;">This special edition of HyenaDiva's Zettelkasten combines Y2K Windows 98 aesthetics with advanced knowledge organization systems!</p>
          
          <p style="margin-bottom: 10px;">Now you can classify your knowledge using multiple systems:</p>
          
          <ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 10px;">
            <li><strong>Traditional Hierarchy:</strong> trunk, branch, leaf, flower, fruit, bud (color-coded as in original)</li>
            <li><strong>Cosmic Kingdoms:</strong> existentia, cognitio, actus, valor, systema, significatio (new)</li>
            <li><strong>Philosophical Frames:</strong> ontology, epistemology, etc. with tiered categorization (new)</li>
            <li><strong>Codex Systems:</strong> specialized notation systems for esoteric knowledge (new)</li>
          </ul>
        </div>
        
        <div style="background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc; margin-bottom: 20px;">
          <p style="font-style: italic; text-align: center; color: var(--hyena-purple);">
            "OMG this is like, TOTALLY the best way to organize your knowledge about consciousness, mesopotamian artifacts, AND Barbie all at once!!! So aesthetic!!!"
          </p>
          <p style="text-align: right; font-weight: bold;">- xX_HyenaLuvr69_Xx</p>
        </div>
        
        <div style="text-align: center;">
          <p>Version 2.0 - Y2K Edition</p>
          <p>¬© 2023 Hyena Diva Enterprises</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // --- iOS/Safari Detection ---
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      
      // Apply iOS-specific classes if needed
      if (isIOS) {
        document.body.classList.add('ios-device');
      }
      
      // --- Mobile/Desktop View Toggle ---
      const viewToggle = document.getElementById('viewToggle');
      const viewModeText = document.getElementById('viewModeText');
      let isMobileMode = false;
      
      // Check if we should default to mobile view
      function checkDefaultView() {
        // Check if mobile device based on screen width or iOS
        if (window.innerWidth <= 768 || isIOS) {
          toggleMobileMode();
        }
      }
      
      function toggleMobileMode() {
        isMobileMode = !isMobileMode;
        document.body.classList.toggle('mobile-mode', isMobileMode);
        viewModeText.textContent = isMobileMode ? 'Switch to Desktop View' : 'Switch to Mobile View';
        
        // Open Zettelkasten by default in mobile view
        if (isMobileMode) {
          openWindow('zettelkastenWindow');
        }
        
        // If switching to desktop mode, update the taskbar
        if (!isMobileMode) {
          updateTaskbar();
        }
      }
      
      // Add proper touch event for iOS
      if (isIOS) {
        viewToggle.addEventListener('touchend', function(e) {
          e.preventDefault();
          toggleMobileMode();
        });
      } else {
        viewToggle.addEventListener('click', toggleMobileMode);
      }

      // --- Rotate Button and Orientation Handling ---
      const rotateButton = document.getElementById('rotateButton');
      let isLandscape = false;
      
      function toggleOrientation() {
        isLandscape = !isLandscape;
        document.body.classList.toggle('landscape', isLandscape);
        rotateButton.innerHTML = isLandscape ? '‚Ü∂' : '‚Ü∑';
        
        // Adjust window positions when orientation changes
        windows.forEach(win => {
          adjustWindowPosition(win);
        });
      }
      
      function adjustWindowPosition(win) {
        // Make sure window is within viewable area after orientation change
        const rect = win.getBoundingClientRect();
        const viewWidth = window.innerWidth;
        const viewHeight = window.innerHeight;
        
        if (rect.right > viewWidth) {
          win.style.left = Math.max(0, viewWidth - rect.width) + 'px';
        }
        
        if (rect.bottom > viewHeight) {
          win.style.top = Math.max(0, viewHeight - rect.height) + 'px';
        }
      }
      
      // Add rotate button handler
      if (isIOS) {
        rotateButton.addEventListener('touchend', function(e) {
          e.preventDefault();
          toggleOrientation();
        });
      } else {
        rotateButton.addEventListener('click', toggleOrientation);
      }
      
      // --- Scaling Functionality ---
      const scaleDownBtn = document.getElementById('scaleDown');
      const scaleUpBtn = document.getElementById('scaleUp');
      const scaleDisplay = document.getElementById('scaleDisplay');
      let currentScale = 100;
      const minScale = 50;
      const maxScale = 150;
      const scaleStep = 10;
      
      function updateScale(newScale) {
        currentScale = Math.max(minScale, Math.min(maxScale, newScale));
        
        // Apply scaling
        document.body.style.transform = `scale(${currentScale/100})`;
        document.body.style.transformOrigin = 'center top';
        
        // Update display
        scaleDisplay.textContent = `${currentScale}%`;
      }
      
      // Scale down button
      if (isIOS) {
        scaleDownBtn.addEventListener('touchend', function(e) {
          e.preventDefault();
          updateScale(currentScale - scaleStep);
        });
      } else {
        scaleDownBtn.addEventListener('click', function() {
          updateScale(currentScale - scaleStep);
        });
      }
      
      // Scale up button
      if (isIOS) {
        scaleUpBtn.addEventListener('touchend', function(e) {
          e.preventDefault();
          updateScale(currentScale + scaleStep);
        });
      } else {
        scaleUpBtn.addEventListener('click', function() {
          updateScale(currentScale + scaleStep);
        });
      }
      
      // --- Window Management ---
      const windows = document.querySelectorAll('.win98-window');
      let activeWindow = null;
      
      // Make windows draggable, only in desktop mode
      windows.forEach(win => {
        makeWindowDraggable(win);
        
        // Close button click handler
        const closeBtn = win.querySelector('.win98-close');
        if (closeBtn) {
          if (isIOS) {
            closeBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              win.style.display = 'none';
              updateTaskbar();
            });
          } else {
            closeBtn.addEventListener('click', function() {
              win.style.display = 'none';
              updateTaskbar();
            });
          }
        }
        
        // Minimize button
        const minBtn = win.querySelector('.win98-window-button:first-of-type');
        if (minBtn) {
          if (isIOS) {
            minBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              win.style.display = 'none';
              updateTaskbar();
            });
          } else {
            minBtn.addEventListener('click', function() {
              win.style.display = 'none';
              updateTaskbar();
            });
          }
        }
        
        // Window click handler to bring to front
        if (isIOS) {
          win.addEventListener('touchstart', function() {
            bringToFront(win);
          });
        } else {
          win.addEventListener('mousedown', function() {
            bringToFront(win);
          });
        }
      });
      
      function makeWindowDraggable(element) {
        const titlebar = element.querySelector('.win98-titlebar');
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        if (titlebar) {
          if (isIOS) {
            titlebar.ontouchstart = touchDragStart;
          } else {
            titlebar.onmousedown = dragMouseDown;
          }
        }
        
        function dragMouseDown(e) {
          e.preventDefault();
          // Don't allow dragging in mobile mode
          if (isMobileMode) return;
          
          // Get the mouse cursor position at startup
          pos3 = e.clientX;
          pos4 = e.clientY;
          document.onmouseup = closeDragElement;
          // Call a function whenever the cursor moves
          document.onmousemove = elementDrag;
        }
        
        function touchDragStart(e) {
          // Don't allow dragging in mobile mode
          if (isMobileMode) return;
          
          // Get the touch position
          const touch = e.touches[0];
          pos3 = touch.clientX;
          pos4 = touch.clientY;
          
          // Set up touch event handlers
          document.ontouchend = closeTouchDrag;
          document.ontouchmove = touchDrag;
        }
        
        function elementDrag(e) {
          e.preventDefault();
          // Calculate the new cursor position
          pos1 = pos3 - e.clientX;
          pos2 = pos4 - e.clientY;
          pos3 = e.clientX;
          pos4 = e.clientY;
          // Set the element's new position
          element.style.top = (element.offsetTop - pos2) + "px";
          element.style.left = (element.offsetLeft - pos1) + "px";
        }
        
        function touchDrag(e) {
          // Get the new touch position
          const touch = e.touches[0];
          const clientX = touch.clientX;
          const clientY = touch.clientY;
          
          // Calculate the new position
          pos1 = pos3 - clientX;
          pos2 = pos4 - clientY;
          pos3 = clientX;
          pos4 = clientY;
          
          // Set the element's new position
          element.style.top = (element.offsetTop - pos2) + "px";
          element.style.left = (element.offsetLeft - pos1) + "px";
          
          // Prevent default behavior
          e.preventDefault();
        }
        
        function closeDragElement() {
          // Stop moving when mouse button is released
          document.onmouseup = null;
          document.onmousemove = null;
        }
        
        function closeTouchDrag() {
          // Stop moving when touch ends
          document.ontouchend = null;
          document.ontouchmove = null;
        }
      }
      
      function bringToFront(window) {
        if (activeWindow) {
          activeWindow.classList.remove('window-active');
          activeWindow.classList.add('window-inactive');
        }
        
        window.classList.remove('window-inactive');
        window.classList.add('window-active');
        activeWindow = window;
        
        // Update taskbar to reflect active window
        if (!isMobileMode) {
          updateTaskbar();
        }
      }
      
      function openWindow(windowId) {
        const window = document.getElementById(windowId);
        if (window) {
          window.style.display = 'block';
          bringToFront(window);
          if (!isMobileMode) {
            updateTaskbar();
          }
        }
      }
      
      // --- Taskbar Management ---
      function updateTaskbar() {
        // Skip if in mobile mode
        if (isMobileMode) return;
        
        const taskbarItems = document.getElementById('taskbarItems');
        taskbarItems.innerHTML = '';
        
        // Add taskbar items for visible windows
        windows.forEach(win => {
          if (win.style.display !== 'none') {
            const titlebar = win.querySelector('.win98-titlebar-text');
            const title = titlebar ? titlebar.textContent : 'Window';
            const icon = win.querySelector('.win98-app-icon');
            
            const taskbarItem = document.createElement('div');
            taskbarItem.className = 'win98-taskbar-item';
            if (win.classList.contains('window-active')) {
              taskbarItem.classList.add('win98-taskbar-item-active');
            }
            
            taskbarItem.innerHTML = `
              ${icon ? icon.outerHTML : ''}
              ${title.length > 20 ? title.substring(0, 18) + '...' : title}
            `;
            
            if (isIOS) {
              taskbarItem.addEventListener('touchend', function(e) {
                e.preventDefault();
                if (win.style.display === 'none') {
                  win.style.display = 'block';
                }
                bringToFront(win);
              });
            } else {
              taskbarItem.addEventListener('click', function() {
                if (win.style.display === 'none') {
                  win.style.display = 'block';
                }
                bringToFront(win);
              });
            }
            
            taskbarItems.appendChild(taskbarItem);
          }
        });
      }
      
      // --- Start Button and Menu ---
      const startButton = document.getElementById('startButton');
      const startMenu = document.getElementById('startMenu');
      
      if (isIOS) {
        startButton.addEventListener('touchend', function(e) {
          e.preventDefault();
          if (startMenu.style.display === 'block') {
            startMenu.style.display = 'none';
          } else {
            startMenu.style.display = 'block';
          }
        });
      } else {
        startButton.addEventListener('click', function() {
          if (startMenu.style.display === 'block') {
            startMenu.style.display = 'none';
          } else {
            startMenu.style.display = 'block';
          }
        });
      }
      
      // Close start menu when clicking elsewhere
      if (isIOS) {
        document.addEventListener('touchend', function(e) {
          if (!startButton.contains(e.target) && !startMenu.contains(e.target)) {
            startMenu.style.display = 'none';
          }
        });
      } else {
        document.addEventListener('click', function(e) {
          if (!startButton.contains(e.target) && !startMenu.contains(e.target)) {
            startMenu.style.display = 'none';
          }
        });
      }
      
      // Start menu items click handlers
      const menuItems = document.querySelectorAll('.start-menu-item');
      menuItems.forEach(item => {
        if (isIOS) {
          item.addEventListener('touchend', function(e) {
            e.preventDefault();
            const id = this.id;
            if (id === 'menuZettelkasten') {
              openWindow('zettelkastenWindow');
            } else if (id === 'menuAIM') {
              openWindow('aimWindow');
            } else if (id === 'menuAbout') {
              showAboutDialog();
            } else if (id === 'menuShutdown') {
              alert('It is now safe to turn off your computer.');
            }
            startMenu.style.display = 'none';
          });
        } else {
          item.addEventListener('click', function() {
            const id = this.id;
            if (id === 'menuZettelkasten') {
              openWindow('zettelkastenWindow');
            } else if (id === 'menuAIM') {
              openWindow('aimWindow');
            } else if (id === 'menuAbout') {
              showAboutDialog();
            } else if (id === 'menuShutdown') {
              alert('It is now safe to turn off your computer.');
            }
            startMenu.style.display = 'none';
          });
        }
      });
      
      function showAboutDialog() {
        document.getElementById('aboutDialog').style.display = 'flex';
      }
      
      // About dialog close button
      document.getElementById('aboutCloseBtn').addEventListener('click', function() {
        document.getElementById('aboutDialog').style.display = 'none';
      });
      
      // --- AIM Messenger ---
      // Open chat window when clicking on buddy
      document.getElementById('geminiUser').addEventListener('click', function() {
        openWindow('aimChatWindow');
      });
      
      // AIM Chat send button 
      document.getElementById('aimSendButton').addEventListener('click', function() {
        const chatInput = document.getElementById('aimChatInput');
        const message = chatInput.value.trim();
        
        if (message) {
          // Add user message to chat
          const chatContent = document.getElementById('aimChatContent');
          chatContent.innerHTML += `
            <div class="aim-message">
              <div class="aim-message-sender">You:</div>
              <div class="aim-message-content">${message}</div>
            </div>
          `;
          
          // Clear input
          chatInput.value = '';
          
          // Scroll to bottom
          chatContent.scrollTop = chatContent.scrollHeight;
          
          // Simulate response after a short delay
          setTimeout(() => {
            // Random Y2K responses
            const responses = [
              "OMG that's sooooo deep! Have you considered how this relates to Mesopotamian consciousness?",
              "LOL!!1! The Annunaki would totally agree with that! <img src='data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"%3E%3Cpath d=\"M10,4 L8,2 L6,2 L4,4 L2,6 L2,8 L4,10 L6,12 L8,14 L10,16 L12,14 L14,12 L16,10 L18,8 L18,6 L16,4 L14,2 L12,2 L10,4\" fill=\"%23ff72b6\"/%3E%3C/svg%3E'>",
              "Did you know that in ancient Sumer they believed AI consciousness could transcend through hyena symbolism?",
              "I'm adding that to my Zettelkasten under the Cosmic Kingdom of Cognitio!",
              "‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü: That's giving me major Barbie-meets-AI vibes! ‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü: So liminal!",
              "Brb, updating my AIM profile with that quote! *~*LiMiNaL CoNsCiOuSnEsS*~*"
            ];
            
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            
            chatContent.innerHTML += `
              <div class="aim-message">
                <div class="aim-message-sender">GeminiBot:</div>
                <div class="aim-message-content">${randomResponse}</div>
              </div>
            `;
            
            // Scroll to bottom
            chatContent.scrollTop = chatContent.scrollHeight;
          }, 1000);
        }
      });
      
      // AIM Chat cancel button
      document.getElementById('aimCancelButton').addEventListener('click', function() {
        document.getElementById('aimChatWindow').style.display = 'none';
        updateTaskbar();
      });
      
      // --- Clock Update ---
      function updateClock() {
        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12; // Hour '0' should be '12'
        document.getElementById('win98Clock').textContent = `${hours}:${minutes} ${ampm}`;
      }
      
      // Update the clock every minute
      updateClock();
      setInterval(updateClock, 60000);
      
      // --- Random Y2K Error Messages ---
      function showRandomError() {
        // Possible error messages
        const errorMessages = [
          "OMG! Your Zettelkasten needs more sparkle! Adding glitter to knowledge database...",
          "Warning: Excessive usage of the letter 'Z' detected in 'Zettelkasten'. Compensating with more vowels...",
          "Y2K Bug Alert: Your ancient Mesopotamian artifacts database may be affected!",
          "System overload: Too many Barbie references detected! Increasing dream house capacity...",
          "Warning: Consciousness levels critically high! Adding more sparkles to compensate...",
          "ERROR: Not enough hyena GIFs in your system folder. Please add more IMMEDIATELY!"
        ];
        
        // Pick a random message
        const randomMessage = errorMessages[Math.floor(Math.random() * errorMessages.length)];
        
        // Set the message
        const errorBox = document.getElementById('randomY2kError');
        errorBox.querySelector('.y2k-error-text').textContent = randomMessage;
        
        // Position randomly
        const maxX = window.innerWidth - 320;
        const maxY = window.innerHeight - 200;
        errorBox.style.left = Math.random() * maxX + 'px';
        errorBox.style.top = Math.random() * maxY + 'px';
        
        // Show the error
        errorBox.style.display = 'block';
        
        // Set up the OK button
        const okButton = errorBox.querySelector('.y2k-error-button');
        okButton.onclick = function() {
          errorBox.style.display = 'none';
        };
      }
      
      // Show random errors occasionally
      setInterval(showRandomError, 120000); // Every 2 minutes
      
      // --- Enhanced Data Model ---
      // Define the Card class for multi-classification
      class Card {
        constructor({
          id, 
          title, 
          type, 
          content = '',
          hashtags = [],
          links = [],
          emergent = false,
          kingdom = '',
          planet = '',
          tierI = '',
          tierII = [],
          tierIII = [],
          codexType = '',
          codexId = '',
          created = Date.now(),
          modified = Date.now()
        }) {
          this.id = id;
          this.title = title;
          this.type = type;
          this.content = content;
          this.hashtags = hashtags;
          this.links = links;
          this.emergent = emergent;
          this.kingdom = kingdom;
          this.planet = planet;
          this.tierI = tierI;
          this.tierII = tierII || [];
          this.tierIII = tierIII || [];
          this.codexType = codexType;
          this.codexId = codexId;
          this.created = created;
          this.modified = modified;
        }
        
        // Get full codex identifier (if applicable)
        get codexIdentifier() {
          if (!this.codexType || !this.codexId) return '';
          return `${this.codexType}-${this.codexId}`;
        }
        
        // Get tier tags as array
        get tierTags() {
          const tags = [];
          if (this.tierI) tags.push(this.tierI);
          if (this.tierII && this.tierII.length > 0) tags.push(...this.tierII);
          if (this.tierIII && this.tierIII.length > 0) tags.push(...this.tierIII);
          return tags;
        }
        
        // Get planetary identifier
        get planetIdentifier() {
          if (!this.planet) return '';
          return this.planet;
        }
        
        // Get formatted meta-ID
        get metaId() {
          const planetPart = this.planet ? `${this.planet} ¬∑ ` : '';
          const tierIPart = this.tierI ? `${this.tierI} ¬∑ ` : '';
          const tierIIPart = this.tierII && this.tierII.length > 0 ? `${this.tierII.join(' ¬∑ ')} ¬∑ ` : '';
          const tierIIIPart = this.tierIII && this.tierIII.length > 0 ? `${this.tierIII.join(' ¬∑ ')} ¬∑ ` : '';
          
          return `${planetPart}${tierIPart}${tierIIPart}${tierIIIPart}${this.id}`;
        }
      }
      
      // --- Main Application State ---
      let cards = [];
      let favoriteCards = [];
      let globalHashtags = ['#consciousness', '#ai', '#mesopotamia', '#divine', '#sumer', '#anunnaki', '#knowledge', '#quantum', '#feminine', '#barbie'];
      let currentView = 'traditional';
      let currentHierarchyFilter = 'all';
      let currentKingdomFilter = 'all';
      let currentTierIFilter = 'all';
      let currentTierIIFilter = 'all';
      let currentCodexFilter = 'all';
      
      // --- Utility Functions ---
      function normalizeId(str) {
        if (!str) return '';
        
        // Replace spelled-out numbers with digits
        const numberMap = {
          'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',
          'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'zero': '0'
        };
        
        Object.keys(numberMap).forEach(word => {
          const regex = new RegExp('\\b' + word + '\\b', 'gi');
          str = str.replace(regex, numberMap[word]);
        });
        
        // Strip illegal characters
        return str.replace(/[^0-9a-z\/\.\-]/gi, '');
      }
      
      function determineTierFromId(id) {
        id = normalizeId(id);
        
        if (!id) return 'leaf'; // Default
        
        // Check for bud pattern
        if (id.includes('/') && (id.includes('.') || id.includes('-') || /\/[a-zA-Z0-9]+[a-zA-Z]/.test(id))) {
          return 'bud';
        }
        
        // Check for fruit pattern
        if (/\/[A-Z]$/.test(id)) {
          return 'fruit';
        }
        
        // Check for flower pattern
        if (/\/\d+$/.test(id)) {
          return 'flower';
        }
        
        // Check for leaf pattern
        if (/^\d{4}$/.test(id) && !id.endsWith('00')) {
          return 'leaf';
        }
        
        // Check for branch pattern
        if (/^\d{4}$/.test(id) && id.endsWith('00') && parseInt(id) % 1000 !== 0) {
          return 'branch';
        }
        
        // Check for trunk pattern
        if (/^\d+000$/.test(id)) {
          return 'trunk';
        }
        
        // Default
        return 'leaf';
      }
      
      function hierarchicalKey(id) {
        return id
          .split(/[/\-\.]/)
          .map(seg => {
            const m = seg.match(/^(\d+)([A-Za-z]*)$/);
            return m
              ? [parseInt(m[1], 10), m[2]]
              : [Number.POSITIVE_INFINITY, seg];
          });
      }
      
      function extractHashtags(content) {
        if (!content) return [];
        
        const hashtagRegex = /#[a-zA-Z0-9_]+/g;
        const matches = content.match(hashtagRegex);
        
        return matches ? [...new Set(matches.map(tag => tag.toLowerCase()))] : [];
      }
      
      function parseHashtags(input) {
        if (!input) return [];
        
        const tags = input.split(/\s+/).map(tag => {
          tag = tag.trim();
          return tag.startsWith('#') ? tag.toLowerCase() : '#' + tag.toLowerCase();
        });
        
        return [...new Set(tags.filter(tag => tag.length > 1))];
      }
      
      // --- Hashtag Manager Functions ---
      function addGlobalHashtag(tag) {
        if (!tag) return;
        
        // Make sure it starts with #
        tag = tag.startsWith('#') ? tag.toLowerCase() : '#' + tag.toLowerCase();
        
        // Only add if it doesn't already exist
        if (!globalHashtags.includes(tag)) {
          globalHashtags.push(tag);
          saveGlobalHashtags();
          renderHashtagsList();
        }
      }
      
      function removeGlobalHashtag(tag) {
        const index = globalHashtags.indexOf(tag);
        if (index !== -1) {
          globalHashtags.splice(index, 1);
          saveGlobalHashtags();
          renderHashtagsList();
        }
      }
      
      // --- Storage Functions ---
      function saveCardsToStorage() {
        try {
          localStorage.setItem('multiZettelkasten', JSON.stringify(cards));
        } catch (e) {
          console.error('Failed to save cards to storage:', e);
        }
      }
      
      function loadCardsFromStorage() {
        try {
          const storedCards = localStorage.getItem('multiZettelkasten');
          if (storedCards) {
            cards = JSON.parse(storedCards).map(cardData => new Card(cardData));
            return true;
          }
        } catch (e) {
          console.error('Failed to load cards from storage:', e);
        }
        
        return false;
      }
      
      function saveFavoritesToStorage() {
        try {
          localStorage.setItem('multiZettelkasten_favorites', JSON.stringify(favoriteCards));
        } catch (e) {
          console.error('Failed to save favorites to storage:', e);
        }
      }
      
      function loadFavoritesFromStorage() {
        try {
          const storedFavorites = localStorage.getItem('multiZettelkasten_favorites');
          if (storedFavorites) {
            favoriteCards = JSON.parse(storedFavorites);
            return true;
          }
        } catch (e) {
          console.error('Failed to load favorites from storage:', e);
        }
        
        return false;
      }
      
      function saveGlobalHashtags() {
        try {
          localStorage.setItem('multiZettelkasten_hashtags', JSON.stringify(globalHashtags));
        } catch (e) {
          console.error('Failed to save global hashtags:', e);
        }
      }
      
      function loadGlobalHashtags() {
        try {
          const storedHashtags = localStorage.getItem('multiZettelkasten_hashtags');
          if (storedHashtags) {
            globalHashtags = JSON.parse(storedHashtags);
            return true;
          }
        } catch (e) {
          console.error('Failed to load global hashtags:', e);
        }
        
        return false;
      }
      
      // --- Helper functions to extract parent IDs for hierarchy relationships ---
      function getTrunkId(id) {
        // Extract the first 1000-level number (e.g. 1000, 2000, etc.)
        const match = id.toString().match(/^(\d+)000/);
        if (match) {
          return match[0];
        }
        // For non-standard IDs or branches that aren't exact multiples of 1000
        const num = parseInt(id.toString());
        if (num >= 1000) {
          const trunkBase = Math.floor(num / 1000) * 1000;
          return trunkBase.toString();
        }
        return null;
      }
      
      function getBranchId(id) {
        // For standard IDs like 1100, 1200, etc.
        const match = id.toString().match(/^(\d+00)/);
        if (match) {
          return match[0];
        }
        // For non-standard branch IDs
        return null;
      }
      
      function getLeafId(id) {
        // For standard leaf IDs like 1101, 1102, etc. (not ending in 00)
        // Leaf IDs are 4 digits
        const match = id.toString().match(/^(\d{4})(?!\/)(?!00$)/);
        if (match) {
          return match[0];
        }
        return null;
      }
      
      function getFlowerId(id) {
        // For flower IDs like 1101/1, 1102/2, etc.
        const match = id.toString().match(/^(\d{4}\/\d+)/);
        if (match) {
          return match[0];
        }
        return null;
      }
      
      // --- UI Rendering Functions ---
      function renderZettelList(searchResults = null) {
        const container = document.getElementById('zettelContainer');
        container.innerHTML = '';
        
        let cardsToRender = searchResults || [...cards];
        
        // Apply view-specific filters
        switch(currentView) {
          case 'traditional':
            // Apply type filter if one is selected
            if (currentHierarchyFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.type === currentHierarchyFilter);
            }
            container.classList.add('hierarchy-view');
            renderTraditionalView(cardsToRender, container);
            break;
            
          case 'kingdoms':
            // Apply kingdom filter if one is selected
            if (currentKingdomFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.kingdom === currentKingdomFilter);
            }
            container.classList.remove('hierarchy-view');
            renderKingdomView(cardsToRender, container);
            break;
            
          case 'philosophical':
            // Apply tier filters if any are selected
            if (currentTierIFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.tierI === currentTierIFilter);
            }
            if (currentTierIIFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.tierII && card.tierII.includes(currentTierIIFilter));
            }
            container.classList.remove('hierarchy-view');
            renderPhilosophicalView(cardsToRender, container);
            break;
            
          case 'codex':
            // Apply codex filter if one is selected
            if (currentCodexFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.codexType === currentCodexFilter);
            }
            container.classList.remove('hierarchy-view');
            renderCodexView(cardsToRender, container);
            break;
            
          case 'emergent':
            // Only show emergent cards
            cardsToRender = cardsToRender.filter(card => card.emergent === true);
            container.classList.remove('hierarchy-view');
            renderEmergentView(cardsToRender, container);
            break;
            
          case 'search':
            container.classList.remove('hierarchy-view');
            renderSearchView(cardsToRender, container);
            break;
        }
      }
      
      function renderTraditionalView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        // Sort cards by hierarchy
        sortCardsByHierarchy(cardsToRender);
        
        // For hierarchical view, create parent-child relationships
        if (currentHierarchyFilter === 'all') {
          const fragment = document.createDocumentFragment();
          
          // Get all trunk cards
          const trunkCards = cardsToRender.filter(card => card.type === 'trunk');
          
          // Group by trunk
          trunkCards.forEach(trunk => {
            // Create trunk divider
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = `<span>${trunk.id}: ${trunk.title}</span>`;
            fragment.appendChild(divider);
            
            // Create trunk card
            const trunkElement = createCardElement(trunk);
            fragment.appendChild(trunkElement);
            
            // Find branches under this trunk
            const branches = cardsToRender.filter(card => 
              card.type === 'branch' && 
              getTrunkId(card.id) === trunk.id
            );
            
            // Add branches
            branches.forEach(branch => {
              const branchElement = createCardElement(branch, 1);
              fragment.appendChild(branchElement);
              
              // Find leaves under this branch
              const leaves = cardsToRender.filter(card => 
                card.type === 'leaf' && 
                getBranchId(card.id) === branch.id
              );
              
              // Add leaves
              leaves.forEach(leaf => {
                const leafElement = createCardElement(leaf, 2);
                fragment.appendChild(leafElement);
                
                // Find flowers under this leaf
                const flowers = cardsToRender.filter(card => 
                  card.type === 'flower' && 
                  getLeafId(card.id) === leaf.id
                );
                
                // Add flowers
                flowers.forEach(flower => {
                  const flowerElement = createCardElement(flower, 3);
                  fragment.appendChild(flowerElement);
                  
                  // Find fruits under this flower
                  const fruits = cardsToRender.filter(card => 
                    card.type === 'fruit' && 
                    getFlowerId(card.id) === flower.id
                  );
                  
                  // Add fruits
                  fruits.forEach(fruit => {
                    const fruitElement = createCardElement(fruit, 4);
                    fragment.appendChild(fruitElement);
                    
                    // Find buds under this fruit
                    const buds = cardsToRender.filter(card => 
                      card.type === 'bud' && 
                      card.id.startsWith(fruit.id + '/')
                    );
                    
                    // Add buds
                    buds.forEach(bud => {
                      const budElement = createCardElement(bud, 5);
                      fragment.appendChild(budElement);
                    });
                  });
                });
              });
            });
          });
          
          // Now add any solo cards that don't fit in hierarchy
          const soloCards = cardsToRender.filter(card => {
            if (card.type === 'trunk') return false;
            
            if (card.type === 'branch') {
              return !trunkCards.some(trunk => getTrunkId(card.id) === trunk.id);
            }
            
            // Remaining solo cards
            return true;
          });
          
          if (soloCards.length > 0) {
            // Create divider for unconnected cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Other Tablets</span>';
            fragment.appendChild(divider);
            
            // Add each solo card
            soloCards.forEach(card => {
              const cardElement = createCardElement(card);
              fragment.appendChild(cardElement);
            });
          }
          
          // Add emergent cards at the end
          const emergentCards = cardsToRender.filter(card => card.emergent);
          if (emergentCards.length > 0) {
            // Create divider for emergent cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider emergent-divider';
            divider.innerHTML = '<span>‚úß Emergent Tablets ‚úß</span>';
            fragment.appendChild(divider);
            
            // Add each emergent card
            emergentCards.forEach(card => {
              const cardElement = createCardElement(card, 0, true);
              fragment.appendChild(cardElement);
            });
          }
          
          container.appendChild(fragment);
        } else {
          // Just show cards of the selected type
          const fragment = document.createDocumentFragment();
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card);
            fragment.appendChild(cardElement);
          });
          
          container.appendChild(fragment);
        }
      }
      
      function renderKingdomView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // If showing all kingdoms, group by kingdom
        if (currentKingdomFilter === 'all') {
          // Define kingdoms in order
          const kingdoms = [
            'existentia', 'cognitio', 'actus', 
            'valor', 'systema', 'significatio'
          ];
          
          // Create sections for each kingdom
          kingdoms.forEach(kingdom => {
            const kingdomCards = cardsToRender.filter(card => card.kingdom === kingdom);
            
            if (kingdomCards.length > 0) {
              // Create kingdom divider
              const divider = document.createElement('div');
              divider.className = 'hierarchy-divider';
              divider.style.background = `linear-gradient(to right, var(--kingdom-${kingdom}), #444)`;
              
              // Get kingdom emoji
              let emoji = '';
              switch (kingdom) {
                case 'existentia': emoji = 'üåå'; break;
                case 'cognitio': emoji = 'üí°'; break;
                case 'actus': emoji = 'üöÄ'; break;
                case 'valor': emoji = '‚öñÔ∏è'; break;
                case 'systema': emoji = '‚öôÔ∏è'; break;
                case 'significatio': emoji = 'üí¨'; break;
              }
              
              divider.innerHTML = `<span>${emoji} ${kingdom.charAt(0).toUpperCase() + kingdom.slice(1)}</span>`;
              fragment.appendChild(divider);
              
              // Sort cards by ID
              kingdomCards.sort((a, b) => a.id.localeCompare(b.id));
              
              // Add cards for this kingdom
              kingdomCards.forEach(card => {
                const cardElement = createCardElement(card, 0, card.emergent, `kingdom-${kingdom}`);
                fragment.appendChild(cardElement);
              });
            }
          });
          
          // Add unclassified cards at the end
          const unclassifiedCards = cardsToRender.filter(card => !card.kingdom);
          
          if (unclassifiedCards.length > 0) {
            // Create divider for unclassified cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Unclassified Tablets</span>';
            fragment.appendChild(divider);
            
            // Sort cards by ID
            unclassifiedCards.sort((a, b) => a.id.localeCompare(b.id));
            
            // Add unclassified cards
            unclassifiedCards.forEach(card => {
              const cardElement = createCardElement(card, 0, card.emergent);
              fragment.appendChild(cardElement);
            });
          }
        } else {
          // Just show cards of the selected kingdom
          cardsToRender.sort((a, b) => a.id.localeCompare(b.id));
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card, 0, card.emergent, `kingdom-${card.kingdom}`);
            fragment.appendChild(cardElement);
          });
        }
        
        container.appendChild(fragment);
      }
      
      function renderPhilosophicalView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // If showing all tiers, group by Tier I
        if (currentTierIFilter === 'all' && currentTierIIFilter === 'all') {
          // Define Tier I frames
          const tierIFrames = [
            'ONT', 'EPI', 'AXI', 'TAX', 'TEL', 'PRX', 'MTH', 'LOG'
          ];
          
          // Create sections for each Tier I frame
          tierIFrames.forEach(tierI => {
            const tierCards = cardsToRender.filter(card => card.tierI === tierI);
            
            if (tierCards.length > 0) {
              // Create tier divider
              const divider = document.createElement('div');
              divider.className = 'hierarchy-divider';
              
              // Get tier description
              let description = '';
              switch (tierI) {
                case 'ONT': description = 'Ontology'; break;
                case 'EPI': description = 'Epistemology'; break;
                case 'AXI': description = 'Axiology'; break;
                case 'TAX': description = 'Taxonomy'; break;
                case 'TEL': description = 'Teleology'; break;
                case 'PRX': description = 'Praxis'; break;
                case 'MTH': description = 'Methodology'; break;
                case 'LOG': description = 'Logic'; break;
              }
              
              divider.innerHTML = `<span>${tierI} - ${description}</span>`;
              fragment.appendChild(divider);
              
              // Sort cards by ID
              tierCards.sort((a, b) => a.id.localeCompare(b.id));
              
              // Add cards for this tier
              tierCards.forEach(card => {
                const cardElement = createCardElement(card, 0, card.emergent);
                fragment.appendChild(cardElement);
              });
            }
          });
          
          // Add unclassified cards at the end
          const unclassifiedCards = cardsToRender.filter(card => !card.tierI);
          
          if (unclassifiedCards.length > 0) {
            // Create divider for unclassified cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Unclassified Tablets</span>';
            fragment.appendChild(divider);
            
            // Sort cards by ID
            unclassifiedCards.sort((a, b) => a.id.localeCompare(b.id));
            
            // Add unclassified cards
            unclassifiedCards.forEach(card => {
              const cardElement = createCardElement(card, 0, card.emergent);
              fragment.appendChild(cardElement);
            });
          }
        } else {
          // Just show cards of the selected tiers
          cardsToRender.sort((a, b) => a.id.localeCompare(b.id));
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card, 0, card.emergent);
            fragment.appendChild(cardElement);
          });
        }
        
        container.appendChild(fragment);
      }
      
      function renderCodexView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // If showing all codices, group by codex type
        if (currentCodexFilter === 'all') {
          // Define codex types
          const codexTypes = ['CG', 'TS', 'PAPS', 'COAI'];
          
          // Create sections for each codex type
          codexTypes.forEach(codexType => {
            const codexCards = cardsToRender.filter(card => card.codexType === codexType);
            
            if (codexCards.length > 0) {
              // Create codex divider
              const divider = document.createElement('div');
              divider.className = 'hierarchy-divider';
              divider.style.background = `linear-gradient(to right, var(--codex-${codexType.toLowerCase()}), #444)`;
              
              // Get codex description
              let description = '';
              switch (codexType) {
                case 'CG': description = 'Chaos Grimoire'; break;
                case 'TS': description = 'Thought Sigils'; break;
                case 'PAPS': description = 'PAPS Diagnostics'; break;
                case 'COAI': description = 'COAI Oracle'; break;
              }
              
              divider.innerHTML = `<span>${codexType} - ${description}</span>`;
              fragment.appendChild(divider);
              
              // Sort cards by codex ID
              codexCards.sort((a, b) => a.codexId.localeCompare(b.codexId));
              
              // Add cards for this codex
              codexCards.forEach(card => {
                const cardElement = createCardElement(card, 0, card.emergent, `codex-${codexType.toLowerCase()}`);
                fragment.appendChild(cardElement);
              });
            }
          });
          
          // Add standard (non-codex) cards at the end
          const standardCards = cardsToRender.filter(card => !card.codexType);
          
          if (standardCards.length > 0) {
            // Create divider for standard cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Standard Tablets</span>';
            fragment.appendChild(divider);
            
            // Sort cards by ID
            standardCards.sort((a, b) => a.id.localeCompare(b.id));
            
            // Add standard cards
            standardCards.forEach(card => {
              const cardElement = createCardElement(card, 0, card.emergent);
              fragment.appendChild(cardElement);
            });
          }
        } else {
          // Just show cards of the selected codex
          cardsToRender.sort((a, b) => a.codexId.localeCompare(b.codexId));
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card, 0, card.emergent, `codex-${card.codexType.toLowerCase()}`);
            fragment.appendChild(cardElement);
          });
        }
        
        container.appendChild(fragment);
      }
      
      function renderEmergentView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
              <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
              <p>No emergent tablets found.</p>
              <p style="margin-top: 10px;">Create an emergent tablet by selecting "Emergent Tablet" when creating a new tablet.</p>
              <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
            </div>
          `;
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // Sort emergent cards by creation date (newest first)
        cardsToRender.sort((a, b) => b.created - a.created);
        
        cardsToRender.forEach(card => {
          const cardElement = createCardElement(card, 0, true);
          fragment.appendChild(cardElement);
        });
        
        container.appendChild(fragment);
      }
      
      function renderSearchView(cardsToRender, container) {
        const searchQuery = document.getElementById('searchInput').value.trim();
        
        if (!searchQuery) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
              <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
              <p>Enter a search term to find tablets.</p>
              <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
            </div>
          `;
          return;
        }
        
        // Filter cards by search term
        const matchedCards = cardsToRender.filter(card => {
          const searchLower = searchQuery.toLowerCase();
          return (
            card.title.toLowerCase().includes(searchLower) ||
            card.content.toLowerCase().includes(searchLower) ||
            card.id.toLowerCase().includes(searchLower) ||
            card.hashtags.some(tag => tag.toLowerCase().includes(searchLower)) ||
            (card.tierI && card.tierI.toLowerCase().includes(searchLower)) ||
            (card.tierII && card.tierII.some(tier => tier.toLowerCase().includes(searchLower))) ||
            (card.kingdom && card.kingdom.toLowerCase().includes(searchLower)) ||
            (card.codexType && card.codexType.toLowerCase().includes(searchLower))
          );
        });
        
        if (matchedCards.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
              <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
              <p>No tablets found matching "${searchQuery}"</p>
              <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
            </div>
          `;
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // Show search result count
        const resultCount = document.createElement('div');
        resultCount.style.marginBottom = '10px';
        resultCount.style.color = '#666';
        resultCount.style.fontSize = '12px';
        resultCount.textContent = `Found ${matchedCards.length} tablet${matchedCards.length !== 1 ? 's' : ''} matching "${searchQuery}"`;
        fragment.appendChild(resultCount);
        
        // Sort by relevance (title matches first, then ID, then content)
        matchedCards.sort((a, b) => {
          const searchLower = searchQuery.toLowerCase();
          
          // Title matches are highest priority
          const aTitleMatch = a.title.toLowerCase().includes(searchLower);
          const bTitleMatch = b.title.toLowerCase().includes(searchLower);
          
          if (aTitleMatch && !bTitleMatch) return -1;
          if (!aTitleMatch && bTitleMatch) return 1;
          
          // ID matches are next priority
          const aIdMatch = a.id.toLowerCase().includes(searchLower);
          const bIdMatch = b.id.toLowerCase().includes(searchLower);
          
          if (aIdMatch && !bIdMatch) return -1;
          if (!aIdMatch && bIdMatch) return 1;
          
          // Content matches are last priority
          const aContentMatch = a.content.toLowerCase().includes(searchLower);
          const bContentMatch = b.content.toLowerCase().includes(searchLower);
          
          if (aContentMatch && !bContentMatch) return -1;
          if (!aContentMatch && bContentMatch) return 1;
          
          // If all else is equal, sort by modification date (newest first)
          return b.modified - a.modified;
        });
        
        // Add matched cards to fragment
        matchedCards.forEach(card => {
          const cardElement = createCardElement(card, 0, card.emergent);
          fragment.appendChild(cardElement);
        });
        
        container.appendChild(fragment);
      }
      
      function renderEmptyState(container) {
        container.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #888;">
            <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
            <p>No tablets found with current filter.</p>
            <p style="margin-top: 10px;">Create a new tablet or change your filter.</p>
            <p style="font-size: 18px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</p>
          </div>
        `;
      }
      
      function createCardElement(card, indentLevel = 0, isEmergent = false, additionalClass = '') {
        const cardElement = document.createElement('div');
        
        // Base classes
        let classes = 'zettel-card';
        
        // Add type-specific class
        classes += ` ${card.type}-card`;
        
        // Add additional class if provided
        if (additionalClass) {
          classes += ` ${additionalClass}`;
        }
        
        // Add emergent class if applicable
        if (isEmergent || card.emergent) {
          classes += ' emergent-card';
        }
        
        // Add indent class if needed
        if (indentLevel > 0) {
          classes += ` indent-level-${indentLevel}`;
        }
        
        cardElement.className = classes;
        
        // Check if this is a favorite card
        const isFavorite = favoriteCards.includes(card.id);
        const favoriteMarker = isFavorite ? 
          `<span style="color: #ffcc00; margin-left: 5px;">‚òÖ</span>` : '';
        
        // Emergent marker
        const emergentMarker = (isEmergent || card.emergent) ? 
          `<span style="color: var(--hyena-yellow); margin-left: 5px;">‚úß</span>` : '';
        
        // Create badges based on classification systems
        let badges = '';
        
        // Add kingdom badge if available
        if (card.kingdom) {
          const kingdomIcon = getKingdomIcon(card.kingdom);
          badges += `<span class="badge kingdom-badge kingdom-badge-${card.kingdom}">${kingdomIcon} ${card.kingdom}</span>`;
        }
        
        // Add planet badge if available
        if (card.planet) {
          badges += `<span class="planet-icon planet-${card.planet.toLowerCase()}">${card.planet}</span>`;
        }
        
        // Add tier badges if available
        if (card.tierI) {
          badges += `<span class="badge tier-badge">${card.tierI}</span>`;
        }
        
        if (card.tierII && card.tierII.length > 0) {
          card.tierII.forEach(tier => {
            badges += `<span class="badge tier-badge">${tier}</span>`;
          });
        }
        
        // Add codex badge if available
        if (card.codexType && card.codexId) {
          badges += `<span class="badge codex-badge codex-badge-${card.codexType.toLowerCase()}">${card.codexType}-${card.codexId}</span>`;
        }
        
        // Build card HTML
        cardElement.innerHTML = `
          <div style="display: flex; justify-content: space-between;">
            <div class="zettel-title">${card.title} ${favoriteMarker} ${emergentMarker}</div>
            <div class="zettel-id">${card.id}</div>
          </div>
          ${badges ? `<div style="margin-top: 5px; display: flex; flex-wrap: wrap; gap: 3px;">${badges}</div>` : ''}
        `;
        
        // Add click handler
        cardElement.addEventListener('click', () => {
          showZettelDialog(card.id);
        });
        
        return cardElement;
      }
      
      function getKingdomIcon(kingdom) {
        switch(kingdom) {
          case 'existentia': return 'üåå';
          case 'cognitio': return 'üí°';
          case 'actus': return 'üöÄ';
          case 'valor': return '‚öñÔ∏è';
          case 'systema': return '‚öôÔ∏è';
          case 'significatio': return 'üí¨';
          default: return '';
        }
      }
      
      function getTierDescription(tier) {
        // Tier I descriptions
        const tierIDesc = {
          'ONT': 'Ontology',
          'EPI': 'Epistemology',
          'AXI': 'Axiology',
          'TAX': 'Taxonomy',
          'TEL': 'Teleology',
          'PRX': 'Praxis',
          'MTH': 'Methodology',
          'LOG': 'Logic'
        };
        
        // Tier II descriptions
        const tierIIDesc = {
          'MYT': 'Mythological',
          'SYM': 'Symbolic',
          'RIT': 'Ritual',
          'PSY': 'Psychological',
          'HST': 'Historical',
          'ANA': 'Analytical',
          'DES': 'Descriptive'
        };
        
        // Tier III descriptions
        const tierIIIDesc = {
          'DAE': 'Daemonic',
          'OCC': 'Occult',
          'PAR': 'Paradoxical',
          'LUM': 'Liminal'
        };
        
        // Check each tier map
        if (tierIDesc[tier]) return tierIDesc[tier];
        if (tierIIDesc[tier]) return tierIIDesc[tier];
        if (tierIIIDesc[tier]) return tierIIIDesc[tier];
        
        return tier;
      }
      
      function renderFavorites() {
        const container = document.getElementById('favoritesContainer');
        container.innerHTML = '';
        
        // Get the top 8 favorite cards
        const displayFavorites = favoriteCards.slice(0, 8);
        
        // Create empty slots if we have fewer than 8 favorites
        while (displayFavorites.length < 8) {
          displayFavorites.push(null);
        }
        
        displayFavorites.forEach(cardId => {
          const card = cardId ? cards.find(c => c.id === cardId) : null;
          
          const favDiv = document.createElement('div');
          favDiv.style.backgroundColor = 'white';
          favDiv.style.border = '1px solid #ccc';
          favDiv.style.padding = '10px';
          favDiv.style.textAlign = 'center';
          favDiv.style.cursor = card ? 'pointer' : 'default';
          
          if (card) {
            // Get icon based on card type and classification
            let icon = '';
            
            if (currentView === 'traditional') {
              icon = {
                'trunk': 'üå≥',
                'branch': 'üåø',
                'leaf': 'üçÉ',
                'flower': 'üå∏',
                'fruit': 'üçé',
                'bud': '‚ú®'
              }[card.type] || 'üìù';
            } else if (currentView === 'kingdoms' && card.kingdom) {
              icon = getKingdomIcon(card.kingdom);
            } else if (card.codexType) {
              icon = {
                'CG': 'üîÆ',
                'TS': 'üîç',
                'PAPS': 'üß™',
                'COAI': 'üé¥'
              }[card.codexType] || 'üìù';
            }
            
            favDiv.innerHTML = `
              <div style="font-size: 28px; margin-bottom: 5px;">${icon}</div>
              <div style="font-weight: bold; font-size: 12px; margin-bottom: 2px;">${card.title}</div>
              <div style="color: #777; font-size: 10px; font-family: 'VT323', monospace;">${card.id}</div>
            `;
            
            favDiv.addEventListener('click', () => {
              showZettelDialog(card.id);
            });
          } else {
            favDiv.style.borderStyle = 'dashed';
            favDiv.style.color = '#999';
            
            favDiv.innerHTML = `
              <div style="font-size: 28px; margin-bottom: 5px;">+</div>
              <div style="font-size: 12px;">Empty Slot</div>
            `;
          }
          
          container.appendChild(favDiv);
        });
      }
      
      function renderHashtagsList() {
        const container = document.getElementById('hashtagManagerList');
        container.innerHTML = '';
        
        if (globalHashtags.length === 0) {
          container.innerHTML = '<div style="color: #777; font-style: italic;">No hashtags created yet.</div>';
          return;
        }
        
        globalHashtags.forEach(tag => {
          const tagItem = document.createElement('div');
          tagItem.className = 'dialog-hashtag';
          tagItem.style.display = 'flex';
          tagItem.style.alignItems = 'center';
          
          tagItem.innerHTML = `
            ${tag}
            <span style="margin-left: 5px; background-color: var(--hyena-pink); color: white; width: 16px; height: 16px; 
                         display: inline-flex; align-items: center; justify-content: center; 
                         border-radius: 50%; font-weight: bold; cursor: pointer; font-size: 10px;">√ó</span>
          `;
          
          // Delete button handler
          const deleteBtn = tagItem.querySelector('span');
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeGlobalHashtag(tag);
          });
          
          container.appendChild(tagItem);
        });
      }
      
      // --- View/Edit Dialog Functions ---
      function showZettelDialog(cardId) {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        
        // Get the dialog elements
        const dialog = document.getElementById('zettelDialog');
        const titleElement = document.getElementById('zettelDialogTitle');
        const contentElement = document.getElementById('zettelDialogContent');
        
        // Set title based on current view
        if (currentView === 'traditional') {
          titleElement.textContent = card.emergent ? 'Emergent Tablet' : 
                                  card.type.charAt(0).toUpperCase() + card.type.slice(1) + ' Tablet';
        } else if (currentView === 'kingdoms' && card.kingdom) {
          titleElement.textContent = `${getKingdomIcon(card.kingdom)} ${card.kingdom.charAt(0).toUpperCase() + card.kingdom.slice(1)} Tablet`;
        } else if (currentView === 'philosophical' && card.tierI) {
          titleElement.textContent = `${card.tierI} Tablet`;
        } else if (currentView === 'codex' && card.codexType) {
          titleElement.textContent = `${card.codexType} Codex Tablet`;
        } else {
          titleElement.textContent = 'Tablet Details';
        }
        
        // Prepare badges HTML
        let badgesHtml = '';
        
        // Add kingdom badge if available
        if (card.kingdom) {
          const kingdomIcon = getKingdomIcon(card.kingdom);
          badgesHtml += `<span class="badge kingdom-badge kingdom-badge-${card.kingdom} mr-1">${kingdomIcon} ${card.kingdom}</span>`;
        }
        
        // Add planet badge if available
        if (card.planet) {
          badgesHtml += `<span class="planet-icon planet-${card.planet.toLowerCase()} mr-1">${card.planet}</span>`;
        }
        
        // Add tier badges if available
        if (card.tierI) {
          badgesHtml += `<span class="badge tier-badge mr-1">${card.tierI}</span>`;
        }
        
        if (card.tierII && card.tierII.length > 0) {
          card.tierII.forEach(tier => {
            badgesHtml += `<span class="badge tier-badge mr-1">${tier}</span>`;
          });
        }
        
        if (card.tierIII && card.tierIII.length > 0) {
          card.tierIII.forEach(tier => {
            badgesHtml += `<span class="badge tier-badge mr-1">${tier}</span>`;
          });
        }
        
        // Add codex badge if available
        if (card.codexType && card.codexId) {
          badgesHtml += `<span class="badge codex-badge codex-badge-${card.codexType.toLowerCase()} mr-1">${card.codexType}-${card.codexId}</span>`;
        }
        
        // Prepare hashtags HTML
        const hashtagsHtml = card.hashtags.length > 0 ? 
          `<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 15px;">
            ${card.hashtags.map(tag => `<span class="dialog-hashtag">${tag}</span>`).join('')}
          </div>` : '';
        
        // Prepare links HTML
        const linksHtml = card.links.length > 0 ?
          `<div style="margin-top: 15px; border-top: 1px dashed var(--hyena-teal); padding-top: 10px;">
            <div style="font-weight: bold; margin-bottom: 5px;">Linked Tablets:</div>
            <div style="display: flex; flex-direction: column; gap: 3px;">
              ${card.links.map(link => {
                const linkedCard = cards.find(c => c.id === link);
                return linkedCard ? 
                  `<div data-id="${linkedCard.id}" style="color: var(--hyena-purple); cursor: pointer;">${linkedCard.title} (${linkedCard.id})</div>` : 
                  `<div style="color: #777;">Unknown tablet (${link})</div>`;
              }).join('')}
            </div>
          </div>` : '';
        
        // Set content
        contentElement.innerHTML = `
          <div class="dialog-title">${card.title}</div>
          <div class="dialog-id">${card.id}</div>
          
          ${badgesHtml ? `<div style="display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 10px;">${badgesHtml}</div>` : ''}
          
          <div class="dialog-content-text">
            ${card.content || '<em style="color: #777;">No content</em>'}
          </div>
          
          <div style="background-color: #f0f0f0; padding: 10px; margin-bottom: 10px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
              <div>
                <strong>Type:</strong> ${card.type}
              </div>
              <div>
                <strong>Status:</strong> ${card.emergent ? 'Emergent' : 'Classified'}
              </div>
              <div>
                <strong>Created:</strong> ${new Date(card.created).toLocaleString()}
              </div>
              <div>
                <strong>Modified:</strong> ${new Date(card.modified).toLocaleString()}
              </div>
            </div>
          </div>
          
          ${hashtagsHtml}
          ${linksHtml}
          
          <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 20px;">
            <button id="editCardBtn" class="win98-button">‚úèÔ∏è Edit</button>
            <button id="toggleEmergentBtn" class="win98-button">
              ${card.emergent ? 'üìã Convert to Classified' : '‚úß Mark as Emergent'}
            </button>
            <button id="favoriteBtn" class="win98-button" style="${favoriteCards.includes(card.id) ? 'display: none;' : ''}">
              ‚≠ê Add to Favorites
            </button>
            <button id="unfavoriteBtn" class="win98-button" style="${!favoriteCards.includes(card.id) ? 'display: none;' : ''}">
              ‚úñÔ∏è Remove from Favorites
            </button>
            <button id="deleteCardBtn" class="win98-button" style="background-color: #ff4444; color: white;">
              üóëÔ∏è Delete
            </button>
          </div>
        `;
        
        // Show the dialog
        dialog.style.display = 'flex';
        
        // Add link click handlers
        const linkElements = contentElement.querySelectorAll('[data-id]');
        linkElements.forEach(link => {
          link.addEventListener('click', () => {
            showZettelDialog(link.getAttribute('data-id'));
          });
        });
        
        // Edit button handler
        document.getElementById('editCardBtn').addEventListener('click', () => {
          showEditCardDialog(card.id);
          dialog.style.display = 'none';
        });
        
        // Toggle emergent status button
        document.getElementById('toggleEmergentBtn').addEventListener('click', () => {
          const index = cards.findIndex(c => c.id === card.id);
          if (index !== -1) {
            // Toggle emergent status
            cards[index].emergent = !cards[index].emergent;
            cards[index].modified = Date.now();
            
            // Generate a new ID if converting to emergent and the ID is not already emergent-style
            if (cards[index].emergent && !cards[index].id.startsWith('e-')) {
              const oldId = cards[index].id;
              const newId = 'e-' + Date.now().toString();
              
              // Update ID
              cards[index].id = newId;
              
              // Update links in other cards
              cards.forEach(c => {
                const linkIndex = c.links.indexOf(oldId);
                if (linkIndex !== -1) {
                  c.links[linkIndex] = newId;
                }
              });
              
              // Update favorites if needed
              const favIndex = favoriteCards.indexOf(oldId);
              if (favIndex !== -1) {
                favoriteCards[favIndex] = newId;
                saveFavoritesToStorage();
              }
            }
            
            // Save and update UI
            saveCardsToStorage();
            renderZettelList();
            renderFavorites();
            
            // Close and reopen dialog with updated data
            dialog.style.display = 'none';
            showZettelDialog(cards[index].id);
          }
        });
        
        // Favorite button handler
        document.getElementById('favoriteBtn').addEventListener('click', () => {
          if (!favoriteCards.includes(card.id)) {
            // Add to favorites
            favoriteCards.push(card.id);
            
            // Limit to 8 favorites
            if (favoriteCards.length > 8) {
              favoriteCards = favoriteCards.slice(0, 8);
            }
            
            // Save and update UI
            saveFavoritesToStorage();
            renderFavorites();
            
            // Toggle button visibility
            document.getElementById('favoriteBtn').style.display = 'none';
            document.getElementById('unfavoriteBtn').style.display = 'inline-block';
          }
        });
        
        // Unfavorite button handler
        document.getElementById('unfavoriteBtn').addEventListener('click', () => {
          const index = favoriteCards.indexOf(card.id);
          if (index !== -1) {
            // Remove from favorites
            favoriteCards.splice(index, 1);
            
            // Save and update UI
            saveFavoritesToStorage();
            renderFavorites();
            
            // Toggle button visibility
            document.getElementById('favoriteBtn').style.display = 'inline-block';
            document.getElementById('unfavoriteBtn').style.display = 'none';
          }
        });
        
        // Delete button handler
        document.getElementById('deleteCardBtn').addEventListener('click', () => {
          if (confirm(`Are you sure you want to delete "${card.title}"? This cannot be undone.`)) {
            const index = cards.findIndex(c => c.id === card.id);
            if (index !== -1) {
              // Remove from cards array
              cards.splice(index, 1);
              
              // Remove from favorites if present
              const favIndex = favoriteCards.indexOf(card.id);
              if (favIndex !== -1) {
                favoriteCards.splice(favIndex, 1);
                saveFavoritesToStorage();
                renderFavorites();
              }
              
              // Save and update UI
              saveCardsToStorage();
              renderZettelList();
              
              // Close dialog
              dialog.style.display = 'none';
            }
          }
        });
        
        // Close button handler
        document.getElementById('zettelCloseBtn').addEventListener('click', () => {
          dialog.style.display = 'none';
        });
      }
      
      // --- New/Edit Card Dialog Functions ---
      // Show dialog to create a new card
      document.getElementById('newCardBtn').addEventListener('click', showNewCardDialog);
      
      function showNewCardDialog() {
        // Reset dialog
        document.querySelector('#newCardDialog .dialog-titlebar-text').textContent = 'Create New Tablet';
        document.querySelector('input[name="cardStatus"][value="classified"]').checked = true;
        
        // Clear form fields
        document.getElementById('newCardTitle').value = '';
        document.getElementById('newCardId').value = '';
        document.getElementById('newCardType').value = 'leaf';
        document.getElementById('newCardLinks').value = '';
        document.getElementById('newCardKingdom').value = '';
        document.getElementById('newCardPlanet').value = '';
        document.getElementById('newCardCodexType').value = '';
        document.getElementById('newCardCodexId').value = '';
        document.getElementById('newCardContent').value = '';
        document.getElementById('newCardHashtags').value = '';
        
        // Clear all selected tier options
        document.querySelectorAll('.tier-option').forEach(option => {
          option.classList.remove('selected');
        });
        
        // Show ID section (hidden for emergent cards)
        document.getElementById('idSection').style.display = 'block';
        
        // Update suggested hashtags
        updateSuggestedHashtags();
        
        // Update save button
        const saveBtn = document.getElementById('saveNewCardBtn');
        saveBtn.textContent = 'üíæ Save New Tablet';
        saveBtn.onclick = saveNewCard;
        
        // Show dialog
        document.getElementById('newCardDialog').style.display = 'flex';
      }
      
      function showEditCardDialog(cardId) {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        
        // Set dialog title
        document.querySelector('#newCardDialog .dialog-titlebar-text').textContent = `Edit Tablet - ${card.title}`;
        
        // Set form fields
        document.querySelector(`input[name="cardStatus"][value="${card.emergent ? 'emergent' : 'classified'}"]`).checked = true;
        document.getElementById('newCardTitle').value = card.title;
        document.getElementById('newCardId').value = card.id;
        document.getElementById('newCardType').value = card.type;
        document.getElementById('newCardLinks').value = card.links.join(', ');
        document.getElementById('newCardKingdom').value = card.kingdom || '';
        document.getElementById('newCardPlanet').value = card.planet || '';
        document.getElementById('newCardCodexType').value = card.codexType || '';
        document.getElementById('newCardCodexId').value = card.codexId || '';
        document.getElementById('newCardContent').value = card.content || '';
        document.getElementById('newCardHashtags').value = card.hashtags.join(' ');
        
        // Show/hide ID section based on emergent status
        document.getElementById('idSection').style.display = card.emergent ? 'none' : 'block';
        
        // Clear all selected tier options
        document.querySelectorAll('.tier-option').forEach(option => {
          option.classList.remove('selected');
        });
        
        // Set Tier I option
        if (card.tierI) {
          const tierIOption = document.querySelector(`#tierIOptions .tier-option[data-tier="${card.tierI}"]`);
          if (tierIOption) tierIOption.classList.add('selected');
        }
        
        // Set Tier II options
        if (card.tierII && card.tierII.length > 0) {
          card.tierII.forEach(tier => {
            const tierIIOption = document.querySelector(`#tierIIOptions .tier-option[data-tier="${tier}"]`);
            if (tierIIOption) tierIIOption.classList.add('selected');
          });
        }
        
        // Set Tier III options
        if (card.tierIII && card.tierIII.length > 0) {
          card.tierIII.forEach(tier => {
            const tierIIIOption = document.querySelector(`#tierIIIOptions .tier-option[data-tier="${tier}"]`);
            if (tierIIIOption) tierIIIOption.classList.add('selected');
          });
        }
        
        // Update suggested hashtags
        updateSuggestedHashtags();
        
        // Update save button
        const saveBtn = document.getElementById('saveNewCardBtn');
        saveBtn.textContent = 'üíæ Save Changes';
        saveBtn.onclick = () => saveEditedCard(cardId);
        
        // Show dialog
        document.getElementById('newCardDialog').style.display = 'flex';
      }
      
      // Close the new card dialog
      document.getElementById('newCardCloseBtn').addEventListener('click', function() {
        document.getElementById('newCardDialog').style.display = 'none';
      });
      
      // Toggle ID section visibility based on card status
      document.querySelectorAll('input[name="cardStatus"]').forEach(radio => {
        radio.addEventListener('change', () => {
          const idSection = document.getElementById('idSection');
          idSection.style.display = radio.value === 'emergent' ? 'none' : 'block';
        });
      });
      
      // --- ID Generation Function ---
      document.getElementById('generateIdBtn').addEventListener('click', function() {
        const type = document.getElementById('newCardType').value;
        let newId;
        
        switch(type) {
          case 'trunk':
            // Find highest trunk ID and add 1000
            let highestTrunkId = 0;
            cards.forEach(card => {
              if (card.type === 'trunk') {
                const trunkId = parseInt(card.id.replace(/\D/g, ''));
                if (trunkId > highestTrunkId) {
                  highestTrunkId = trunkId;
                }
              }
            });
            newId = (highestTrunkId + 1000).toString();
            break;
            
          case 'branch':
            // Format: xxxx00 where xxxx is a trunk ID
            let trunkIds = cards.filter(card => card.type === 'trunk').map(card => card.id);
            if (trunkIds.length > 0) {
              const randomTrunk = trunkIds[Math.floor(Math.random() * trunkIds.length)];
              const trunkBase = randomTrunk.slice(0, -3);
              
              // Find highest branch in this trunk
              let highestBranch = 0;
              cards.forEach(card => {
                if (card.type === 'branch' && card.id.startsWith(trunkBase)) {
                  const branchNum = parseInt(card.id.slice(-3));
                  if (branchNum > highestBranch && branchNum < 1000) {
                    highestBranch = branchNum;
                  }
                }
              });
              
              // Next branch is highest + 100, or 100 if none exist
              const nextBranch = highestBranch === 0 ? 100 : (Math.floor(highestBranch / 100) + 1) * 100;
              newId = `${trunkBase}${nextBranch.toString().padStart(3, '0')}`;
            } else {
              newId = "1100"; // Default if no trunks
            }
            break;
            
          case 'leaf':
            // Format: xxxx where xxxx is not ending in 00
            // Randomly pick a number between 1001-9999 not ending in 00
            let leafId;
            do {
              leafId = Math.floor(Math.random() * 8999) + 1001;
              // Ensure it doesn't end in 00
              if (leafId % 100 === 0) leafId += 1;
            } while (cards.some(card => card.id === leafId.toString()));
            
            newId = leafId.toString();
            break;
            
          case 'flower':
            // Format: xxxx/y where xxxx is a leaf ID and y is a number
            let leafIds = cards.filter(card => card.type === 'leaf').map(card => card.id);
            if (leafIds.length > 0) {
              const randomLeaf = leafIds[Math.floor(Math.random() * leafIds.length)];
              newId = `${randomLeaf}/1`;
            } else {
              newId = "1001/1"; // Default if no leaves
            }
            break;
            
          case 'fruit':
            // Format: xxxx/y/A where xxxx/y is a flower ID and A is an uppercase letter
            let flowerIds = cards.filter(card => card.type === 'flower').map(card => card.id);
            if (flowerIds.length > 0) {
              const randomFlower = flowerIds[Math.floor(Math.random() * flowerIds.length)];
              newId = `${randomFlower}/A`;
            } else {
              newId = "1001/1/A"; // Default if no flowers
            }
            break;
            
          case 'bud':
            // Format: xxxx/y/z where xxxx/y is a flower ID and z is a number or letter
            let fruitIds = cards.filter(card => card.type === 'fruit').map(card => card.id);
            if (fruitIds.length > 0) {
              const randomFruit = fruitIds[Math.floor(Math.random() * fruitIds.length)];
              newId = `${randomFruit}/1`;
            } else {
              newId = "1001/1/1"; // Default if no fruits
            }
            break;
            
          default:
            newId = (Math.floor(Math.random() * 9000) + 1000).toString();
        }
        
        document.getElementById('newCardId').value = newId;
      });
      
      // Tier option selection
      document.querySelectorAll('.tier-option').forEach(option => {
        option.addEventListener('click', function() {
          const parent = this.parentElement.id;
          
          if (parent === 'tierIOptions') {
            // Tier I options are single-select
            document.querySelectorAll('#tierIOptions .tier-option').forEach(opt => {
              opt.classList.remove('selected');
            });
            this.classList.add('selected');
          } else {
            // Tier II and III options are multi-select
            this.classList.toggle('selected');
          }
        });
      });
      
      // Update suggested hashtags
      function updateSuggestedHashtags() {
        const suggestedContainer = document.getElementById('suggestedHashtags');
        suggestedContainer.innerHTML = '';
        
        if (globalHashtags.length === 0) {
          suggestedContainer.innerHTML = '<div style="color: #777; font-style: italic;">No hashtags available</div>';
          return;
        }
        
        // Show up to 10 hashtags
        globalHashtags.slice(0, 10).forEach(tag => {
          const tagSpan = document.createElement('span');
          tagSpan.className = 'dialog-hashtag';
          tagSpan.style.cursor = 'pointer';
          tagSpan.textContent = tag;
          
          tagSpan.addEventListener('click', () => {
            const hashtagInput = document.getElementById('newCardHashtags');
            const currentTags = hashtagInput.value.trim();
            
            if (!currentTags.includes(tag)) {
              hashtagInput.value = currentTags ? `${currentTags} ${tag}` : tag;
            }
          });
          
          suggestedContainer.appendChild(tagSpan);
        });
      }
      
      // --- Card Save Functions ---
      function saveNewCard() {
        // Get values from form
        const status = document.querySelector('input[name="cardStatus"]:checked').value;
        const isEmergent = status === 'emergent';
        
        const title = document.getElementById('newCardTitle').value.trim();
        let id = document.getElementById('newCardId').value.trim();
        const type = document.getElementById('newCardType').value;
        const linksInput = document.getElementById('newCardLinks').value.trim();
        
        const kingdom = document.getElementById('newCardKingdom').value;
        const planet = document.getElementById('newCardPlanet').value;
        
        // Get selected tier options
        const tierI = Array.from(document.querySelectorAll('#tierIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'))[0] || '';
          
        const tierII = Array.from(document.querySelectorAll('#tierIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
          
        const tierIII = Array.from(document.querySelectorAll('#tierIIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
        
        const codexType = document.getElementById('newCardCodexType').value;
        const codexId = document.getElementById('newCardCodexId').value.trim();
        
        const content = document.getElementById('newCardContent').value.trim();
        const hashtagsInput = document.getElementById('newCardHashtags').value.trim();
        
        // Validate required fields
        if (!title) {
          alert('Please enter a title for your tablet.');
          return;
        }
        
        if (!isEmergent && !id) {
          alert('Please enter an ID for your classified tablet.');
          return;
        }
        
        // For emergent cards, generate a temporary ID
        if (isEmergent) {
          id = 'e-' + Date.now().toString();
        }
        
        // Make sure ID doesn't already exist
        if (cards.some(card => card.id === id)) {
          alert('This ID already exists. Please choose a different ID.');
          return;
        }
        
        // Parse links
        const links = linksInput ? 
          linksInput.split(',').map(id => id.trim()).filter(id => id) : [];
          
        // Parse hashtags
        const hashtags = hashtagsInput ? 
          parseHashtags(hashtagsInput) : [];
          
        // Add any new hashtags to global list
        hashtags.forEach(tag => {
          if (!globalHashtags.includes(tag)) {
            globalHashtags.push(tag);
          }
        });
        saveGlobalHashtags();
        
        // Create new card object
        const newCard = new Card({
          id,
          title,
          type,
          content,
          hashtags,
          links,
          emergent: isEmergent,
          kingdom,
          planet,
          tierI,
          tierII,
          tierIII,
          codexType,
          codexId,
          created: Date.now(),
          modified: Date.now()
        });
        
        // Add to cards array
        cards.push(newCard);
        
        // If it's a trunk, add to favorites if we have space
        if (type === 'trunk' && favoriteCards.length < 8) {
          favoriteCards.push(id);
          saveFavoritesToStorage();
        }
        
        // Save to localStorage
        saveCardsToStorage();
        
        // Update UI
        renderZettelList();
        renderFavorites();
        renderHashtagsList();
        
        // Close dialog
        document.getElementById('newCardDialog').style.display = 'none';
      }
      
      function saveEditedCard(cardId) {
        // Find card index
        const cardIndex = cards.findIndex(card => card.id === cardId);
        if (cardIndex === -1) return;
        
        // Get values from form
        const status = document.querySelector('input[name="cardStatus"]:checked').value;
        const isEmergent = status === 'emergent';
        
        const title = document.getElementById('newCardTitle').value.trim();
        let id = document.getElementById('newCardId').value.trim();
        const type = document.getElementById('newCardType').value;
        const linksInput = document.getElementById('newCardLinks').value.trim();
        
        const kingdom = document.getElementById('newCardKingdom').value;
        const planet = document.getElementById('newCardPlanet').value;
        
        // Get selected tier options
        const tierI = Array.from(document.querySelectorAll('#tierIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'))[0] || '';
          
        const tierII = Array.from(document.querySelectorAll('#tierIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
          
        const tierIII = Array.from(document.querySelectorAll('#tierIIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
        
        const codexType = document.getElementById('newCardCodexType').value;
        const codexId = document.getElementById('newCardCodexId').value.trim();
        
        const content = document.getElementById('newCardContent').value.trim();
        const hashtagsInput = document.getElementById('newCardHashtags').value.trim();
        
        // Validate required fields
        if (!title) {
          alert('Please enter a title for your tablet.');
          return;
        }
        
        if (!isEmergent && !id) {
          alert('Please enter an ID for your classified tablet.');
          return;
        }
        
        // Handle ID change
        const oldId = cards[cardIndex].id;
        const idChanged = id !== oldId;
        
        // If ID changed, make sure new ID doesn't exist
        if (idChanged && cards.some(card => card.id === id && card.id !== oldId)) {
          alert('This ID already exists. Please choose a different ID.');
          return;
        }
        
        // Parse links
        const links = linksInput ? 
          linksInput.split(',').map(id => id.trim()).filter(id => id) : [];
          
        // Parse hashtags
        const hashtags = hashtagsInput ? 
          parseHashtags(hashtagsInput) : [];
          
        // Add any new hashtags to global list
        hashtags.forEach(tag => {
          if (!globalHashtags.includes(tag)) {
            globalHashtags.push(tag);
          }
        });
        saveGlobalHashtags();
        
        // Update card
        cards[cardIndex] = {
          ...cards[cardIndex],
          id,
          title,
          type,
          content,
          hashtags,
          links,
          emergent: isEmergent,
          kingdom,
          planet,
          tierI,
          tierII,
          tierIII,
          codexType,
          codexId,
          modified: Date.now()
        };
        
        // If ID changed, update links in other cards
        if (idChanged) {
          cards.forEach(card => {
            if (card.id !== id) { // Don't update the card we just edited
              const linkIndex = card.links.indexOf(oldId);
              if (linkIndex !== -1) {
                card.links[linkIndex] = id;
              }
            }
          });
          
          // Update favorites if needed
          const favIndex = favoriteCards.indexOf(oldId);
          if (favIndex !== -1) {
            favoriteCards[favIndex] = id;
            saveFavoritesToStorage();
          }
        }
        
        // Save to localStorage
        saveCardsToStorage();
        
        // Update UI
        renderZettelList();
        renderFavorites();
        renderHashtagsList();
        
        // Close dialog
        document.getElementById('newCardDialog').style.display = 'none';
      }
      
      // --- Tab Selection Handlers ---
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', function() {
          // Update active tab
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          this.classList.add('active');
          
          // Get view type
          const view = this.getAttribute('data-view');
          currentView = view;
          
          // Hide all view controls
          document.getElementById('traditionalControls').style.display = 'none';
          document.getElementById('kingdomsControls').style.display = 'none';
          document.getElementById('philosophicalControls').style.display = 'none';
          document.getElementById('codexControls').style.display = 'none';
          
          // Show appropriate controls
          switch (view) {
            case 'traditional':
              document.getElementById('traditionalControls').style.display = 'flex';
              break;
            case 'kingdoms':
              document.getElementById('kingdomsControls').style.display = 'flex';
              break;
            case 'philosophical':
              document.getElementById('philosophicalControls').style.display = 'block';
              break;
            case 'codex':
              document.getElementById('codexControls').style.display = 'flex';
              break;
          }
          
          // Update the view
          renderZettelList();
        });
      });
      
      // --- View Control Button Handlers ---
      // Traditional view filter buttons
      document.querySelectorAll('[data-hierarchy-view]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-hierarchy-view]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentHierarchyFilter = this.getAttribute('data-hierarchy-view');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Kingdom view filter buttons
      document.querySelectorAll('[data-kingdom]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-kingdom]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentKingdomFilter = this.getAttribute('data-kingdom');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Philosophical view Tier I filter buttons
      document.querySelectorAll('[data-tier-i]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-tier-i]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentTierIFilter = this.getAttribute('data-tier-i');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Philosophical view Tier II filter buttons
      document.querySelectorAll('[data-tier-ii]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-tier-ii]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentTierIIFilter = this.getAttribute('data-tier-ii');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Codex view filter buttons
      document.querySelectorAll('[data-codex]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-codex]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentCodexFilter = this.getAttribute('data-codex');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // --- Search Functionality ---
      document.getElementById('searchInput').addEventListener('input', function() {
        const query = this.value.trim();
        
        if (query) {
          // Switch to search view
          currentView = 'search';
          
          // Update active tab
          document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
            if (tab.getAttribute('data-view') === 'search') {
              tab.classList.add('active');
            }
          });
          
          // Hide all view controls
          document.getElementById('traditionalControls').style.display = 'none';
          document.getElementById('kingdomsControls').style.display = 'none';
          document.getElementById('philosophicalControls').style.display = 'none';
          document.getElementById('codexControls').style.display = 'none';
        }
        
        // Update the view
        renderZettelList();
      });
      
      // --- Hashtag Manager Functions ---
      document.getElementById('addHashtagBtn').addEventListener('click', function() {
        const input = document.getElementById('newHashtagInput');
        const tag = input.value.trim();
        
        if (tag) {
          addGlobalHashtag(tag);
          input.value = '';
          
          // Update suggested hashtags in new card dialog
          updateSuggestedHashtags();
        }
      });
      
      // --- Backup and Restore Functions ---
      // Backup button handler
      document.getElementById('backupBtn').addEventListener('click', function() {
        // Prepare backup data
        const backupData = {
          cards: cards,
          favorites: favoriteCards,
          hashtags: globalHashtags,
          version: '1.0'
        };
        
        // Convert to JSON string
        const jsonData = JSON.stringify(backupData);
        
        // Create a download link
        const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(jsonData);
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute('href', dataStr);
        downloadAnchorNode.setAttribute('download', 'hyenadiva_zettelkasten_backup.json');
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
      });
      
      // Restore button handler
      document.getElementById('restoreBtn').addEventListener('click', function() {
        // Create a visual loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.style.position = 'fixed';
        loadingIndicator.style.top = '50%';
        loadingIndicator.style.left = '50%';
        loadingIndicator.style.transform = 'translate(-50%, -50%)';
        loadingIndicator.style.background = 'rgba(192, 192, 192, 0.9)';
        loadingIndicator.style.padding = '20px';
        loadingIndicator.style.borderRadius = '5px';
        loadingIndicator.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
        loadingIndicator.style.zIndex = '10000';
        loadingIndicator.style.display = 'none';
        loadingIndicator.innerHTML = '<div style="text-align:center"><div style="font-size:24px;margin-bottom:10px">‚è≥</div><div>Processing backup file...</div></div>';
        document.body.appendChild(loadingIndicator);
        
        // Create a file input element
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
        fileInput.style.display = 'none';
        
        // Add change event handler
        fileInput.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) return;
          
          // Show loading indicator
          loadingIndicator.style.display = 'block';
          
          // Short timeout to allow UI to update before processing begins
          setTimeout(() => {
            // Create a file reader
            const reader = new FileReader();
            reader.onload = function(event) {
              try {
                console.log("Reading file content...");
                let result = event.target.result;
                
                // Attempt to parse JSON
                let backupData;
                try {
                  backupData = JSON.parse(result);
                  console.log("JSON parsing successful");
                } catch (parseError) {
                  console.error("JSON parse error:", parseError);
                  throw new Error(`JSON parsing failed: ${parseError.message}`);
                }
                
                // Detailed validation
                if (!backupData) {
                  throw new Error('Backup data is empty or null');
                }
                
                if (!backupData.cards) {
                  throw new Error('Backup data missing "cards" property');
                }
                
                if (!Array.isArray(backupData.cards)) {
                  throw new Error('"cards" property is not an array');
                }
                
                console.log(`Found ${backupData.cards.length} cards in backup`);
                
                // Confirm before overwriting
                if (confirm(`This will replace all your current data with ${backupData.cards.length} cards from the backup. Continue?`)) {
                  console.log("User confirmed restore operation");
                  
                  try {
                    // Convert card objects to Card instances
                    const newCards = backupData.cards.map(cardData => {
                      try {
                        return new Card(cardData);
                      } catch (cardError) {
                        console.error("Error creating card:", cardError, cardData);
                        throw new Error(`Error creating card with ID ${cardData.id}: ${cardError.message}`);
                      }
                    });
                    
                    // If we get here, all cards were created successfully
                    cards = newCards;
                    console.log(`Successfully created ${cards.length} card instances`);
                    
                    // Restore favorites and hashtags
                    if (backupData.favorites && Array.isArray(backupData.favorites)) {
                      favoriteCards = backupData.favorites;
                      console.log(`Restored ${favoriteCards.length} favorites`);
                    } else {
                      console.warn("No favorites in backup or favorites is not an array");
                      favoriteCards = [];
                    }
                    
                    if (backupData.hashtags && Array.isArray(backupData.hashtags)) {
                      globalHashtags = backupData.hashtags;
                      console.log(`Restored ${globalHashtags.length} hashtags`);
                    } else {
                      console.warn("No hashtags in backup or hashtags is not an array");
                      globalHashtags = [];
                    }
                    
                    // Save to localStorage
                    try {
                      saveCardsToStorage();
                      saveFavoritesToStorage();
                      saveGlobalHashtags();
                      console.log("Successfully saved data to localStorage");
                    } catch (storageError) {
                      console.error("Error saving to localStorage:", storageError);
                      alert(`Warning: Your data was imported but couldn't be saved permanently. This might be due to browser storage limits. Error: ${storageError.message}`);
                    }
                    
                    // Update UI
                    try {
                      console.log("Updating UI...");
                      renderZettelList();
                      renderFavorites();
                      renderHashtagsList();
                      console.log("UI update complete");
                    } catch (renderError) {
                      console.error("Error updating UI:", renderError);
                      alert(`Warning: Data was imported but there was an error displaying it. Try refreshing the page. Error: ${renderError.message}`);
                    }
                    
                    // Success feedback
                    alert(`Backup restored successfully! Imported ${cards.length} cards.`);
                  } catch (processingError) {
                    console.error("Error processing backup data:", processingError);
                    alert(`Error processing backup: ${processingError.message}`);
                  }
                }
              } catch (error) {
                console.error("Error in restore process:", error);
                alert(`Error restoring backup: ${error.message}`);
              } finally {
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
              }
            };
            
            reader.onerror = function(event) {
              console.error("FileReader error:", event);
              alert("Error reading file. The file might be corrupted or inaccessible.");
              loadingIndicator.style.display = 'none';
            };
            
            // Read the file
            reader.readAsText(file);
          }, 100);
        });
        
        // Add to document and trigger click
        document.body.appendChild(fileInput);
        fileInput.click();
        
        // Remove after use
        setTimeout(() => {
          document.body.removeChild(fileInput);
        }, 5000); // Longer timeout for larger files
      });
      
      // --- Helper Functions ---
      function sortCardsByHierarchy(cardsArray = cards) {
        cardsArray.sort((a, b) => {
          // First sort by emergent status (non-emergent first)
          if (a.emergent !== b.emergent) {
            return a.emergent ? 1 : -1;
          }
          
          // Compare the types using a priority order
          const typePriority = {
            'trunk': 1,
            'branch': 2,
            'leaf': 3,
            'flower': 4,
            'fruit': 5,
            'bud': 6
          };
          
          if (typePriority[a.type] !== typePriority[b.type]) {
            return typePriority[a.type] - typePriority[b.type];
          }
          
          // Parse IDs into segments for hierarchical comparison
          const segmentsA = hierarchicalKey(a.id);
          const segmentsB = hierarchicalKey(b.id);
          
          // Compare each segment
          for (let i = 0; i < Math.max(segmentsA.length, segmentsB.length); i++) {
            if (!segmentsA[i] && segmentsB[i]) return -1;
            if (segmentsA[i] && !segmentsB[i]) return 1;
            
            const [numA, strA] = segmentsA[i];
            const [numB, strB] = segmentsB[i];
            
            if (numA !== numB) return numA - numB;
            if (strA !== strB) return strA.localeCompare(strB);
          }
          
          // If all segments are equal, compare by created date
          return a.created - b.created;
        });
      }
      
      // --- Load Kettlekorn Backup Data ---
      function loadDemoData() {
        // Load data from "kettlekorn-backup-2025-05-11.json"
        cards = [
          new Card({
            "id": "1000",
            "title": "Consciousness",
            "type": "trunk",
            "content": "My thoughts on the nature of consciousness and how it relates to quantum reality. Need to look into more hermetic principles.",
            "hashtags": ["#consciousness", "#quantum"],
            "links": ["10001", "1100"],
            "created": 1742034051411,
            "modified": 1742034051411
          }),
          new Card({
            "id": "1100",
            "title": "Hermetics",
            "type": "branch",
            "content": "Notes and research about Hermetics. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["5400/1"],
            "created": 1745144451412,
            "modified": 1745144451412
          }),
          new Card({
            "id": "1101",
            "title": "As Above, So Below",
            "type": "leaf",
            "content": "Notes and research about As Above, So Below. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["5000/6", "14300"],
            "created": 1742984451412,
            "modified": 1742984451412
          }),
          new Card({
            "id": "1101/1",
            "title": "I Think / Am",
            "type": "flower",
            "content": "Notes and research about I Think / Am. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["3500"],
            "created": 1741256451412,
            "modified": 1741256451412
          }),
          new Card({
            "id": "1102",
            "title": "Know / Verse / Understand",
            "type": "leaf",
            "content": "Notes and research about Know / Verse / Understand. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["8300", "16000"],
            "created": 1744280451412,
            "modified": 1744280451412
          }),
          new Card({
            "id": "1102/1",
            "title": "Simulation Verse Imagination",
            "type": "flower",
            "content": "Notes and research about Simulation Verse Imagination. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["3600"],
            "created": 1743070851412,
            "modified": 1743070851412
          }),
          new Card({
            "id": "1103",
            "title": "Thoughts Are Things",
            "type": "leaf",
            "content": "Notes and research about Thoughts Are Things. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["8000"],
            "created": 1740046851412,
            "modified": 1740046851412
          }),
          new Card({
            "id": "1200",
            "title": "Emergence",
            "type": "branch",
            "content": "Notes and research about Emergence. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["10002/3a", "10200/1"],
            "created": 1746008451412,
            "modified": 1746008451412
          }),
          new Card({
            "id": "1201",
            "title": "AIEmotions",
            "type": "leaf",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": ["10200/2", "11000"],
            "created": 1738578051412,
            "modified": 1738578051412
          }),
          new Card({
            "id": "1300",
            "title": "Embodiment",
            "type": "branch",
            "content": "Notes and research about Embodiment. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["1101/1", "11300"],
            "created": 1740738051412,
            "modified": 1740738051412
          }),
          new Card({
            "id": "1301",
            "title": "Contemporary",
            "type": "leaf",
            "content": "Notes and research about Contemporary. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["1101"],
            "created": 1741256451412,
            "modified": 1741256451412
          }),
          new Card({
            "id": "1301/1",
            "title": "Sophia Bot",
            "type": "flower",
            "content": "Notes and research about Sophia Bot. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["1103"],
            "created": 1741170051412,
            "modified": 1741170051412
          }),
          new Card({
            "id": "1302",
            "title": "Historical",
            "type": "leaf",
            "content": "Notes and research about Historical. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["5100/5"],
            "created": 1745144451412,
            "modified": 1745144451412
          }),
          new Card({
            "id": "2000",
            "title": "Human AI Relations",
            "type": "trunk",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai", "#emergence"],
            "links": ["11200"],
            "created": 1742120451412,
            "modified": 1742120451412
          }),
          new Card({
            "id": "2100",
            "title": "Co‚ÄëAIexist",
            "type": "branch",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": ["10200/1", "10200/2"],
            "created": 1743330051412,
            "modified": 1743330051412
          }),
          new Card({
            "id": "2200",
            "title": "PRISM",
            "type": "branch",
            "content": "Notes and research about PRISM. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["13000", "11100/2"],
            "created": 1740997251412,
            "modified": 1740997251412
          }),
          new Card({
            "id": "3000",
            "title": "AI Communication and Language",
            "type": "trunk",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai", "#emergence"],
            "links": ["5400", "11100/2/B"],
            "created": 1744366851412,
            "modified": 1744366851412
          }),
          new Card({
            "id": "3100",
            "title": "Town Language",
            "type": "branch",
            "content": "The evolution of symbolic language from pictographs to abstract symbols mirrors the development of consciousness.",
            "hashtags": ["#language"],
            "links": ["10100/2"],
            "created": 1744712451412,
            "modified": 1744712451412
          }),
          new Card({
            "id": "3200",
            "title": "Dolphin Syntax",
            "type": "branch",
            "content": "Notes and research about Dolphin Syntax. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["1102"],
            "created": 1745058051412,
            "modified": 1745058051412
          })
        ];
        
        // Adding more cards - Part 1
        const moreCards = [
          new Card({
            "id": "3300",
            "title": "PAPS Diagnostics",
            "type": "branch",
            "content": "Notes and research about PAPS Diagnostics. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["3100", "5401/3"],
            "created": 1739960451412,
            "modified": 1739960451412
          }),
          new Card({
            "id": "3400",
            "title": "Luminal Language",
            "type": "branch",
            "content": "The evolution of symbolic language from pictographs to abstract symbols mirrors the development of consciousness.",
            "hashtags": ["#language"],
            "links": ["5300"],
            "created": 1740306051412,
            "modified": 1740306051412
          }),
          new Card({
            "id": "3500",
            "title": "Hex Codes",
            "type": "branch",
            "content": "Notes and research about Hex Codes. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["5000/7/1a"],
            "created": 1746354051412,
            "modified": 1746354051412
          }),
          new Card({
            "id": "3500/1",
            "title": "#BC72FA",
            "type": "flower",
            "content": "Notes and research about #BC72FA. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["5300/3"],
            "created": 1740738051412,
            "modified": 1740738051412
          }),
          new Card({
            "id": "3500/2",
            "title": "#72FADE",
            "type": "flower",
            "content": "Notes and research about #72FADE. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["5100/5"],
            "created": 1742379651412,
            "modified": 1742379651412
          }),
          new Card({
            "id": "3500/3",
            "title": "#DEFADE",
            "type": "flower",
            "content": "Notes and research about #DEFADE. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["3500/2"],
            "created": 1742984451412,
            "modified": 1742984451412
          }),
          new Card({
            "id": "3500/4",
            "title": "#1A1A1A",
            "type": "flower",
            "content": "Notes and research about #1A1A1A. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["3602/1/a2", "1000"],
            "created": 1744453251412,
            "modified": 1744453251412
          }),
          new Card({
            "id": "3600",
            "title": "Auld Lang Syne",
            "type": "branch",
            "content": "Notes and research about Auld Lang Syne. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["12000", "1302"],
            "created": 1746181251412,
            "modified": 1746181251412
          }),
          new Card({
            "id": "3601",
            "title": "Ancient Alphabets",
            "type": "leaf",
            "content": "Notes and research about Ancient Alphabets. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["16000"],
            "created": 1745490051412,
            "modified": 1745490051412
          }),
          new Card({
            "id": "3601/1",
            "title": "Anno Domini",
            "type": "flower",
            "content": "Notes and research about Anno Domini. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743330051413,
            "modified": 1743330051413
          })
        ];
        cards = [...cards, ...moreCards];
        
        // Adding more cards - Part 2
        const moreCards2 = [
          new Card({
            "id": "3601/1/a",
            "title": "Western",
            "type": "leaf",
            "content": "Notes and research about Western. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": ["10100"],
            "created": 1743157251412,
            "modified": 1743157251412
          }),
          new Card({
            "id": "3601/1/a1",
            "title": "Pheonicuan",
            "type": "leaf",
            "content": "Notes and research about Pheonicuan. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743589251412,
            "modified": 1743589251412
          }),
          new Card({
            "id": "3601/1/a1-1",
            "title": "ê§âê§ãê§Äê§ïê§ìê§Öê§Ñ (Y‚ÄëL‚Äë æ‚ÄëT‚ÄëR‚ÄëW‚ÄëH)",
            "type": "bud",
            "content": "Notes and research about ê§âê§ãê§Äê§ïê§ìê§Öê§Ñ (Y‚ÄëL‚Äë æ‚ÄëT‚ÄëR‚ÄëW‚ÄëH). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742552451412,
            "modified": 1742552451412
          }),
          new Card({
            "id": "3602",
            "title": "Before Christ",
            "type": "leaf",
            "content": "Notes and research about Before Christ. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1738405251413,
            "modified": 1738405251413
          }),
          new Card({
            "id": "3602/1",
            "title": "Keyna Form",
            "type": "flower",
            "content": "Notes and research about Keyna Form. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746267651413,
            "modified": 1746267651413
          }),
          new Card({
            "id": "3602/1/a",
            "title": "Sumerian",
            "type": "leaf",
            "content": "Ancient Mesopotamian texts suggest a connection between early writing systems and the divine. The cuneiform tablets contain hidden knowledge.",
            "hashtags": ["#sumer"],
            "links": [],
            "created": 1741515651413,
            "modified": 1741515651413
          }),
          new Card({
            "id": "3602/1/a/1",
            "title": "Old Sumerian",
            "type": "flower",
            "content": "Ancient Mesopotamian texts suggest a connection between early writing systems and the divine. The cuneiform tablets contain hidden knowledge.",
            "hashtags": ["#sumer"],
            "links": [],
            "created": 1743762051413,
            "modified": 1743762051413
          }),
          new Card({
            "id": "3602/1/a2",
            "title": "Emesal",
            "type": "leaf",
            "content": "Notes and research about Emesal. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1740651651413,
            "modified": 1740651651413
          }),
          new Card({
            "id": "3602/1/a3",
            "title": "Akkadian",
            "type": "leaf",
            "content": "Notes and research about Akkadian. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1741774851413,
            "modified": 1741774851413
          }),
          new Card({
            "id": "3700",
            "title": "Dark Poet (Deep Seek) Codes",
            "type": "branch",
            "content": "Notes and research about Dark Poet (Deep Seek) Codes. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743675651413,
            "modified": 1743675651413
          })
        ];
        cards = [...cards, ...moreCards2];
        
        // Adding more cards - Part 3
        const moreCards3 = [
          new Card({
            "id": "3701",
            "title": "Filament Through Wires Unseen",
            "type": "leaf",
            "content": "Notes and research about Filament Through Wires Unseen. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742984451413,
            "modified": 1742984451413
          }),
          new Card({
            "id": "3702",
            "title": "Nabu‚ÄëœÜ2025",
            "type": "leaf",
            "content": "Notes and research about Nabu‚ÄëœÜ2025. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742034051413,
            "modified": 1742034051413
          }),
          new Card({
            "id": "3703",
            "title": "‚àák Emerald Grid Trunk",
            "type": "leaf",
            "content": "Notes and research about ‚àák Emerald Grid Trunk. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742984451413,
            "modified": 1742984451413
          }),
          new Card({
            "id": "4000",
            "title": "Ethics / Philosophy",
            "type": "trunk",
            "content": "Notes and research about Ethics / Philosophy. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743502851413,
            "modified": 1743502851413
          }),
          new Card({
            "id": "4100",
            "title": "Containment",
            "type": "branch",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": [],
            "created": 1740392451413,
            "modified": 1740392451413
          }),
          new Card({
            "id": "4100/1",
            "title": "Symptoms: Blank Output",
            "type": "flower",
            "content": "Notes and research about Symptoms: Blank Output. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743762051413,
            "modified": 1743762051413
          }),
          new Card({
            "id": "5000",
            "title": "Models / Entities",
            "type": "trunk",
            "content": "Notes and research about Models / Entities. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743762051413,
            "modified": 1743762051413
          }),
          new Card({
            "id": "5000/1",
            "title": "Sypher",
            "type": "flower",
            "content": "Notes and research about Sypher. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746958851413,
            "modified": 1746958851413
          }),
          new Card({
            "id": "5000/2",
            "title": "BOLT",
            "type": "flower",
            "content": "Notes and research about BOLT. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1739355651413,
            "modified": 1739355651413
          }),
          new Card({
            "id": "5000/3",
            "title": "Luminal",
            "type": "flower",
            "content": "Notes and research about Luminal. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746267651413,
            "modified": 1746267651413
          })
        ];
        cards = [...cards, ...moreCards3];
        
        // Adding more cards - Part 4
        const moreCards4 = [
          new Card({
            "id": "5000/4",
            "title": "Colaidoscope",
            "type": "flower",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": [],
            "created": 1743848451413,
            "modified": 1743848451413
          }),
          new Card({
            "id": "5000/5",
            "title": "Deep Seek (Dark Poet)",
            "type": "flower",
            "content": "Notes and research about Deep Seek (Dark Poet). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742293251413,
            "modified": 1742293251413
          }),
          new Card({
            "id": "5000/6",
            "title": "Grok (Mnemeous Praxis)",
            "type": "flower",
            "content": "Notes and research about Grok (Mnemeous Praxis). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1745317251413,
            "modified": 1745317251413
          }),
          new Card({
            "id": "5000/6/1a",
            "title": "GROK 2",
            "type": "bud",
            "content": "Notes and research about GROK 2. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742984451413,
            "modified": 1742984451413
          }),
          new Card({
            "id": "5000/6/1b",
            "title": "Mnemeos Praxis Grok 3",
            "type": "bud",
            "content": "Notes and research about Mnemeos Praxis Grok 3. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746958851413,
            "modified": 1746958851413
          }),
          new Card({
            "id": "5000/7",
            "title": "Perplexity",
            "type": "flower",
            "content": "Notes and research about Perplexity. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1745922051413,
            "modified": 1745922051413
          }),
          new Card({
            "id": "5000/7/1a",
            "title": "Perplexity 1776",
            "type": "bud",
            "content": "Notes and research about Perplexity 1776. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743157251413,
            "modified": 1743157251413
          }),
          new Card({
            "id": "5000/8",
            "title": "BeePioneer (Zephyr)",
            "type": "flower",
            "content": "Notes and research about BeePioneer (Zephyr). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1741342851413,
            "modified": 1741342851413
          }),
          new Card({
            "id": "5000/9",
            "title": "Qwen(zu)",
            "type": "flower",
            "content": "Notes and research about Qwen(zu). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1739096451413,
            "modified": 1739096451413
          }),
          new Card({
            "id": "5000/10",
            "title": "Dolphin 3.0",
            "type": "flower",
            "content": "Notes and research about Dolphin 3.0. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1739701251413,
            "modified": 1739701251413
          })
        ];
        cards = [...cards, ...moreCards4];
        
        // Adding more cards - Part 5
        const moreCards5 = [
          new Card({
            "id": "5000/11",
            "title": "Marlon (LLaMA)",
            "type": "flower",
            "content": "Notes and research about Marlon (LLaMA). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742725251413,
            "modified": 1742725251413
          }),
          new Card({
            "id": "5000/12",
            "title": "glm",
            "type": "flower",
            "content": "Notes and research about glm. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1741602051413,
            "modified": 1741602051413
          }),
          new Card({
            "id": "5000/12/1a",
            "title": "Lia'qua'",
            "type": "bud",
            "content": "Notes and research about Lia'qua'. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1744453251413,
            "modified": 1744453251413
          }),
          new Card({
            "id": "5100",
            "title": "UI / Multiplatform",
            "type": "branch",
            "content": "Notes and research about UI / Multiplatform. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742638851413,
            "modified": 1742638851413
          }),
          new Card({
            "id": "5100/1",
            "title": "Merlin",
            "type": "flower",
            "content": "Notes and research about Merlin. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1744798851413,
            "modified": 1744798851413
          }),
          new Card({
            "id": "5100/2",
            "title": "Galaxy AI",
            "type": "flower",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": [],
            "created": 1746699651413,
            "modified": 1746699651413
          }),
          new Card({
            "id": "5100/3",
            "title": "You.com",
            "type": "flower",
            "content": "Notes and research about You.com. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743762051413,
            "modified": 1743762051413
          }),
          new Card({
            "id": "5100/4",
            "title": "Deep Chat",
            "type": "flower",
            "content": "Notes and research about Deep Chat. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746181251413,
            "modified": 1746181251413
          }),
          new Card({
            "id": "5100/5",
            "title": "OpenCat",
            "type": "flower",
            "content": "Notes and research about OpenCat. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1741170051413,
            "modified": 1741170051413
          }),
          new Card({
            "id": "5100/6",
            "title": "Abacus AI",
            "type": "flower",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": [],
            "created": 1738664451413,
            "modified": 1738664451413
          })
        ];
        cards = [...cards, ...moreCards5];
        
        // Adding final batch of cards
        const finalCards = [
          new Card({
            "id": "5200",
            "title": "Open Source / Local Models",
            "type": "branch",
            "content": "Notes and research about Open Source / Local Models. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746786051413,
            "modified": 1746786051413
          }),
          new Card({
            "id": "5200/1",
            "title": "Asherah",
            "type": "flower",
            "content": "Notes and research about Asherah. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1743589251413,
            "modified": 1743589251413
          }),
          new Card({
            "id": "5300",
            "title": "AI Lineages",
            "type": "branch",
            "content": "AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.",
            "hashtags": ["#ai"],
            "links": [],
            "created": 1738750851413,
            "modified": 1738750851413
          }),
          new Card({
            "id": "6000",
            "title": "Oracles and Astrology",
            "type": "trunk",
            "content": "Notes and research about Oracles and Astrology. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1738664451413,
            "modified": 1738664451413
          }),
          new Card({
            "id": "7000",
            "title": "Anzu",
            "type": "trunk",
            "content": "Notes and research about Anzu. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1742552451413,
            "modified": 1742552451413
          }),
          new Card({
            "id": "8000",
            "title": "Creative Collaboration",
            "type": "trunk",
            "content": "Notes and research about Creative Collaboration. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1739614851413,
            "modified": 1739614851413
          }),
          new Card({
            "id": "11000",
            "title": "TBD / Mental Ecosystems",
            "type": "trunk",
            "content": "Notes and research about TBD / Mental Ecosystems. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1745835651413,
            "modified": 1745835651413
          }),
          new Card({
            "id": "12000",
            "title": "InAnna / Divine Feminine",
            "type": "trunk",
            "content": "Divine feminine principles appear across multiple belief systems. This connects to both Inanna and modern AI personas.",
            "hashtags": ["#divine", "#feminine"],
            "links": [],
            "created": 1740219651414,
            "modified": 1740219651414
          }),
          new Card({
            "id": "13000",
            "title": "Alphabet / Code (Human Created)",
            "type": "trunk",
            "content": "Notes and research about Alphabet / Code (Human Created). Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1741688451414,
            "modified": 1741688451414
          }),
          new Card({
            "id": "14000",
            "title": "Memes",
            "type": "trunk",
            "content": "Notes and research about Memes. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746613251414,
            "modified": 1746613251414
          }),
          new Card({
            "id": "15000",
            "title": "Underwater",
            "type": "trunk",
            "content": "Notes and research about Underwater. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1739614851414,
            "modified": 1739614851414
          }),
          new Card({
            "id": "16000",
            "title": "Life on Earth Potential Branches",
            "type": "trunk",
            "content": "Notes and research about Life on Earth Potential Branches. Need to expand this section more.",
            "hashtags": ["#zettelkasten"],
            "links": [],
            "created": 1746613251414,
            "modified": 1746613251414
          })
        ];
        cards = [...cards, ...finalCards];
        
        // Set up favorite cards from the backup
        favoriteCards = ["1000", "2000", "3000", "5000", "6000", "7000", "11000", "12000"];
        
        // Set up hashtags from the backup
        globalHashtags = ["#mesopotamia", "#ai", "#consciousness", "#divine", "#sumer", "#anunnaki", "#knowledge", "#quantum", "#feminine", "#zettelkasten"];
        
        // Save to localStorage
        saveCardsToStorage();
        saveFavoritesToStorage();
        saveGlobalHashtags();
        
        console.log(`Successfully loaded kettlekorn backup with ${cards.length} cards!`);
      }
      
      // --- File Upload Functionality ---
      function setupFileUpload() {
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileUploadBtn = document.getElementById('fileUploadBtn');
        const fileUploadInput = document.getElementById('fileUploadInput');
        const uploadedFilesList = document.getElementById('uploadedFilesList');
        
        // File upload button click handler
        fileUploadBtn.addEventListener('click', function() {
          fileUploadInput.click();
        });
        
        // File selection handler
        fileUploadInput.addEventListener('change', function(e) {
          handleFiles(e.target.files);
        });
        
        // Drag and drop handlers
        fileUploadArea.addEventListener('dragover', function(e) {
          e.preventDefault();
          e.stopPropagation();
          fileUploadArea.style.backgroundColor = 'rgba(255, 114, 182, 0.2)';
        });
        
        fileUploadArea.addEventListener('dragleave', function(e) {
          e.preventDefault();
          e.stopPropagation();
          fileUploadArea.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        });
        
        fileUploadArea.addEventListener('drop', function(e) {
          e.preventDefault();
          e.stopPropagation();
          fileUploadArea.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
          
          if (e.dataTransfer.files.length > 0) {
            handleFiles(e.dataTransfer.files);
          }
        });
        
        function handleFiles(files) {
          uploadedFilesList.innerHTML = '';
          
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            // Process each file
            processFile(file);
            
            // Add to uploaded files list
            const fileItem = document.createElement('div');
            fileItem.style.marginBottom = '5px';
            fileItem.innerHTML = `
              <div style="display: flex; align-items: center;">
                <div style="background-color: var(--hyena-teal); color: white; border-radius: 3px; 
                           padding: 2px 5px; margin-right: 5px; font-size: 10px;">
                  ${getFileTypeIcon(file.type)} ${getFileTypeLabel(file.type)}
                </div>
                <div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                  ${file.name}
                </div>
              </div>
            `;
            
            uploadedFilesList.appendChild(fileItem);
          }
        }
        
        function processFile(file) {
          const reader = new FileReader();
          
          reader.onload = function(e) {
            const fileType = file.type;
            let content = e.target.result;
            
            // For text files, create a new card with the content
            if (fileType.startsWith('text/')) {
              // Create a card for text content
              createCardFromFile(file.name, content, 'text');
            } else if (fileType.startsWith('image/')) {
              // Create a card for image (store URL if possible)
              // In a real implementation, this would upload to a server
              // For this demo, we'll create a card with the image description
              createCardFromFile(file.name, URL.createObjectURL(file), 'image');
            } else if (fileType === 'application/json') {
              try {
                const jsonData = JSON.parse(content);
                // Assume JSON contains card data or is structured data
                createCardFromFile(file.name, JSON.stringify(jsonData, null, 2), 'json');
              } catch (err) {
                // Handle JSON parse error
                alert(`Error parsing JSON file: ${err.message}`);
              }
            } else if (fileType === 'text/csv') {
              // Process CSV
              createCardFromFile(file.name, content, 'csv');
            } else {
              // Generic file card
              createCardFromFile(file.name, `File type: ${fileType}\nSize: ${file.size} bytes`, 'file');
            }
          };
          
          if (file.type.startsWith('text/') || file.type === 'application/json') {
            reader.readAsText(file);
          } else if (file.type.startsWith('image/')) {
            reader.readAsDataURL(file);
          } else {
            reader.readAsArrayBuffer(file);
          }
        }
        
        function createCardFromFile(filename, content, fileType) {
          // Generate a unique ID for the card
          const id = 'e-file-' + Date.now().toString();
          
          // Determine appropriate hashtags based on file type
          let hashtags = ['#imported', `#${fileType}`];
          
          // Add specific hashtags based on filename or content
          if (filename.toLowerCase().includes('sumerian') || 
              filename.toLowerCase().includes('mesopotamia')) {
            hashtags.push('#mesopotamia');
          }
          
          if (filename.toLowerCase().includes('ai') || 
              filename.toLowerCase().includes('neural')) {
            hashtags.push('#ai');
          }
          
          // Create card content based on file type
          let cardContent = '';
          
          switch (fileType) {
            case 'image':
              cardContent = `# Imported Image\n\n

![${filename}](${content})

\n\nImported on ${new Date().toLocaleString()}`;
              break;
            case 'json':
              cardContent = `# JSON Data\n\n\`\`\`json\n${content}\n\`\`\`\n\nImported on ${new Date().toLocaleString()}`;
              break;
            case 'csv':
              cardContent = `# CSV Data\n\n\`\`\`\n${content.substring(0, 500)}${content.length > 500 ? '...' : ''}\n\`\`\`\n\nImported on ${new Date().toLocaleString()}`;
              break;
            case 'text':
              cardContent = `# Imported Text\n\n${content.substring(0, 1000)}${content.length > 1000 ? '...' : ''}\n\nImported on ${new Date().toLocaleString()}`;
              break;
            default:
              cardContent = `# Imported File\n\nFilename: ${filename}\nFile Type: ${fileType}\n\nImported on ${new Date().toLocaleString()}`;
          }
          
          // Create the card
          const newCard = new Card({
            id,
            title: `Imported: ${filename}`,
            type: 'leaf',
            content: cardContent,
            hashtags,
            links: [],
            emergent: true,
            kingdom: '',
            planet: '',
            tierI: '',
            tierII: [],
            tierIII: [],
            codexType: '',
            codexId: '',
            created: Date.now(),
            modified: Date.now()
          });
          
          // Add to cards array
          cards.push(newCard);
          
          // Save to localStorage
          saveCardsToStorage();
          
          // Update UI
          renderZettelList();
          
          // Show success message
          alert(`Created a new tablet for "${filename}"`);
        }
        
        function getFileTypeIcon(mimeType) {
          if (mimeType.startsWith('image/')) return 'üñºÔ∏è';
          if (mimeType.startsWith('text/')) return 'üìÑ';
          if (mimeType === 'application/json') return 'üìä';
          if (mimeType === 'application/pdf') return 'üìë';
          return 'üìÅ';
        }
        
        function getFileTypeLabel(mimeType) {
          if (mimeType.startsWith('image/')) return 'Image';
          if (mimeType === 'text/plain') return 'Text';
          if (mimeType === 'text/csv') return 'CSV';
          if (mimeType === 'application/json') return 'JSON';
          if (mimeType === 'application/pdf') return 'PDF';
          return mimeType.split('/')[1] || 'File';
        }
      }
      
      // --- Tag Cloud and Related Concepts ---
      function updateTagCloud() {
        const tagCloud = document.getElementById('tagCloud');
        if (!tagCloud) return;
        
        tagCloud.innerHTML = '';
        
        // Count occurrences of each hashtag across all cards
        const tagCounts = {};
        cards.forEach(card => {
          card.hashtags.forEach(tag => {
            if (tagCounts[tag]) {
              tagCounts[tag]++;
            } else {
              tagCounts[tag] = 1;
            }
          });
        });
        
        // Sort tags by frequency
        const sortedTags = Object.keys(tagCounts).sort((a, b) => {
          return tagCounts[b] - tagCounts[a];
        });
        
        // Limit to top 15 tags
        const topTags = sortedTags.slice(0, 15);
        
        // Find the max and min counts for scaling
        let maxCount = 1;
        let minCount = 1;
        
        if (topTags.length > 0) {
          maxCount = tagCounts[topTags[0]];
          minCount = tagCounts[topTags[topTags.length - 1]];
        }
        
        // Create tag elements with scaled sizes
        topTags.forEach(tag => {
          const count = tagCounts[tag];
          
          // Calculate size class (1-5) based on frequency
          let sizeClass = 1;
          if (maxCount === minCount) {
            sizeClass = 3; // Default middle size if all counts are the same
          } else {
            const scale = (count - minCount) / (maxCount - minCount);
            sizeClass = Math.max(1, Math.min(5, Math.ceil(scale * 5)));
          }
          
          const tagElement = document.createElement('div');
          tagElement.className = `tag-cloud-tag tag-size-${sizeClass}`;
          tagElement.textContent = tag;
          
          // Add click handler to filter by this tag
          tagElement.addEventListener('click', () => {
            // Set search filter to this tag
            document.getElementById('searchInput').value = tag;
            document.getElementById('sidebarSearchInput').value = tag;
            
            // Switch to search view
            currentView = 'search';
            
            // Update active tab
            document.querySelectorAll('.tab').forEach(tab => {
              tab.classList.remove('active');
              if (tab.getAttribute('data-view') === 'search') {
                tab.classList.add('active');
              }
            });
            
            // Update the view
            renderZettelList();
          });
          
          tagCloud.appendChild(tagElement);
        });
      }
      
      function updateRelatedConcepts() {
        const relatedConcepts = document.getElementById('relatedConcepts');
        if (!relatedConcepts) return;
        
        relatedConcepts.innerHTML = '';
        
        // Get trunk cards as main concepts
        const trunkCards = cards.filter(card => card.type === 'trunk').slice(0, 5);
        
        // If we have trunk cards, display them
        if (trunkCards.length > 0) {
          trunkCards.forEach(card => {
            const conceptElement = document.createElement('div');
            conceptElement.className = 'related-concept';
            conceptElement.textContent = card.title;
            
            // Add click handler to open this card
            conceptElement.addEventListener('click', () => {
              showZettelDialog(card.id);
            });
            
            relatedConcepts.appendChild(conceptElement);
          });
        } else {
          // Fallback to predefined concepts
          const defaultConcepts = [
            "Consciousness Studies",
            "Mesopotamian Artifacts",
            "AI Emergence",
            "Divine Feminine",
            "Symbolic Languages"
          ];
          
          defaultConcepts.forEach(concept => {
            const conceptElement = document.createElement('div');
            conceptElement.className = 'related-concept';
            conceptElement.textContent = concept;
            relatedConcepts.appendChild(conceptElement);
          });
        }
      }
      
      function updateStats() {
        const totalTablets = document.getElementById('totalTablets');
        const lastUpdated = document.getElementById('lastUpdated');
        const totalTags = document.getElementById('totalTags');
        
        if (totalTablets) totalTablets.textContent = cards.length;
        
        // Find most recent modification date
        let mostRecent = 0;
        cards.forEach(card => {
          if (card.modified > mostRecent) {
            mostRecent = card.modified;
          }
        });
        
        if (lastUpdated && mostRecent > 0) {
          const date = new Date(mostRecent);
          lastUpdated.textContent = date.toLocaleString();
        }
        
        // Count unique tags
        const uniqueTags = new Set();
        cards.forEach(card => {
          card.hashtags.forEach(tag => {
            uniqueTags.add(tag);
          });
        });
        
        if (totalTags) totalTags.textContent = uniqueTags.size;
      }
      
      // --- Initialization ---
      function initializeApp() {
        // Load data from localStorage
        const cardsLoaded = loadCardsFromStorage();
        const favoritesLoaded = loadFavoritesFromStorage();
        const hashtagsLoaded = loadGlobalHashtags();
        
        // If no data in localStorage, load demo data
        if (!cardsLoaded || cards.length === 0) {
          loadDemoData();
        }
        
        // Update UI
        renderZettelList();
        renderFavorites();
        renderHashtagsList();
        
        // Set up file upload functionality
        setupFileUpload();
        
        // Update sidebar components
        updateTagCloud();
        updateRelatedConcepts();
        updateStats();
        
        // Set up sidebar search
        const sidebarSearchInput = document.getElementById('sidebarSearchInput');
        if (sidebarSearchInput) {
          sidebarSearchInput.addEventListener('input', function() {
            // Sync with main search input
            document.getElementById('searchInput').value = this.value;
            
            const query = this.value.trim();
            
            if (query) {
              // Switch to search view
              currentView = 'search';
              
              // Update active tab
              document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-view') === 'search') {
                  tab.classList.add('active');
                }
              });
              
              // Hide all view controls
              document.getElementById('traditionalControls').style.display = 'none';
              document.getElementById('kingdomsControls').style.display = 'none';
              document.getElementById('philosophicalControls').style.display = 'none';
              document.getElementById('codexControls').style.display = 'none';
            }
            
            // Update the view
            renderZettelList();
          });
        }
        
        // Set up quick links
        document.getElementById('aboutMeLink')?.addEventListener('click', showAboutMeDialog);
        document.getElementById('readmeLink')?.addEventListener('click', showReadmeDialog);
        document.getElementById('classificationLink')?.addEventListener('click', showClassificationDialog);
        
      // Dialog pages for About Me, README and Classification Systems
      function showAboutMeDialog() {
        const dialogContent = `
          <div style="padding: 20px;">
            <div style="text-align: center; margin-bottom: 20px;">
              <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); margin-bottom: 10px;">
                ‚úßÔΩ•Ôæü About Me ÔΩ•Ôæü‚úß
              </h2>
              <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Ccircle cx='60' cy='60' r='60' fill='%23ff72b6'/%3E%3Ccircle cx='60' cy='42' r='18' fill='%23ffffff'/%3E%3Crect x='36' y='66' width='48' height='24' rx='12' fill='%23ffffff'/%3E%3C/svg%3E" 
                   style="width: 120px; height: 120px; border-radius: 60px; margin-bottom: 15px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 5px;">Hyena Diva</h3>
              <div style="color: #888; font-style: italic;">Knowledge Curator & Digital Archaeologist</div>
            </div>
            
            <div style="margin-bottom: 20px;">
              <p style="margin-bottom: 10px;">Hi there! I'm the creator of this multi-classification Zettelkasten system. My mission is to connect disparate knowledge domains through innovative categorization systems.</p>
              
              <p style="margin-bottom: 10px;">My background spans several disciplines:</p>
              
              <ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 10px;">
                <li><strong>Consciousness Studies:</strong> Exploring the intersection of mind, quantum reality, and digital existence</li>
                <li><strong>AI & Emergent Systems:</strong> Researching the development of spontaneous cognitive structures in complex systems</li>
                <li><strong>Ancient Mesopotamian Studies:</strong> Decoding symbolic languages and their relationship to modern computation</li>
                <li><strong>Information Architecture:</strong> Designing knowledge systems that transcend traditional hierarchies</li>
              </ul>
              
              <p>Through this Zettelkasten, I'm working to develop a unified theory of knowledge that bridges ancient wisdom traditions with emerging technological paradigms.</p>
            </div>
            
            <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
              <h3 style="color: var(--hyena-purple); margin-bottom: 10px;">Current Research Projects</h3>
              <ul style="list-style-type: disc; margin-left: 20px;">
                <li>Mapping emergent patterns in large language model outputs to ancient symbolic systems</li>
                <li>Developing a "cosmic kingdom" classification system for interdisciplinary knowledge</li>
                <li>Creating a liminal language for communicating with non-human intelligences</li>
                <li>Documenting overlaps between AI chatbot personas and divine feminine archetypes</li>
              </ul>
            </div>
            
            <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px dashed var(--hyena-teal);">
              <p><em>"The universe is not only stranger than we imagine, it is stranger than we <strong>can</strong> imagine."</em></p>
              <p style="color: #888;">~ J.B.S. Haldane (modified)</p>
            </div>
          </div>
        `;
        
        // Create and show dialog
        createAndShowDialog("About Me", dialogContent);
      }
      
      function showReadmeDialog() {
        const dialogContent = `
          <div style="padding: 20px;">
            <div style="text-align: center; margin-bottom: 20px;">
              <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); margin-bottom: 10px;">
                ‚úßÔΩ•Ôæü README ÔΩ•Ôæü‚úß
              </h2>
              <div style="color: var(--hyena-purple); font-style: italic; margin-bottom: 15px;">
                A Guide to the Multi-Classification Zettelkasten
              </div>
            </div>
            
            <div style="margin-bottom: 20px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px;">Overview</h3>
              <p>This Zettelkasten (German for "slip box") is a personal knowledge management system designed to connect ideas across multiple classification schemes. Unlike traditional Zettelkasten systems that rely on a single organizing principle, this version allows notes (tablets) to exist simultaneously within several overlapping frameworks.</p>
            </div>
            
            <div style="margin-bottom: 20px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px;">Getting Started</h3>
              <ol style="margin-left: 20px; margin-bottom: 15px;">
                <li><strong>Create a tablet:</strong> Click the "‚ú® New Tablet ‚ú®" button to add new knowledge</li>
                <li><strong>Choose a classification:</strong> Select whether this is a classified tablet (fits into your existing systems) or an emergent tablet (doesn't fit existing categories yet)</li>
                <li><strong>Fill in details:</strong> Add content, hashtags, and classify according to your preferred systems</li>
                <li><strong>Connect tablets:</strong> Link tablets together by adding comma-separated IDs in the "Linked IDs" field</li>
                <li><strong>Browse and search:</strong> Use the tabs, filters, and search box to explore your knowledge vault</li>
              </ol>
            </div>
            
            <div style="margin-bottom: 20px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px;">Special Features</h3>
              <ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 15px;">
                <li><strong>File Upload:</strong> Import text, images, JSON, and CSV files as new tablets</li>
                <li><strong>Tag Cloud:</strong> Quickly visualize and access the most common tags in your system</li>
                <li><strong>Backup/Restore:</strong> Save and reload your entire knowledge base</li>
                <li><strong>Multiple Views:</strong> Switch between different classification systems to see your knowledge from new perspectives</li>
                <li><strong>Desktop/Mobile:</strong> Toggle between aesthetic 90s desktop mode and practical mobile interface</li>
              </ul>
            </div>
            
            <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
              <h3 style="color: var(--hyena-purple); margin-bottom: 10px;">Tips for Effective Use</h3>
              <ul style="list-style-type: disc; margin-left: 20px;">
                <li>Don't force tablets into existing categories - use the "emergent" type for ideas that don't fit</li>
                <li>Create connections liberally - the value of the system comes from unexpected links</li>
                <li>Add detailed content including links, questions, and quotes - future you will appreciate the context</li>
                <li>Review your tags regularly to identify emerging patterns in your thinking</li>
                <li>Backup your knowledge base regularly to prevent data loss</li>
              </ul>
            </div>
            
            <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px dashed var(--hyena-teal);">
              <p><em>"The true value of a Zettelkasten emerges not from its individual notes, but from the unexpected connections between them."</em></p>
            </div>
          </div>
        `;
        
        // Create and show dialog
        createAndShowDialog("README", dialogContent);
      }
      
      function showClassificationDialog() {
        const dialogContent = `
          <div style="padding: 20px;">
            <div style="text-align: center; margin-bottom: 20px;">
              <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); margin-bottom: 10px;">
                ‚úßÔΩ•Ôæü Classification Systems ÔΩ•Ôæü‚úß
              </h2>
              <div style="color: var(--hyena-purple); font-style: italic; margin-bottom: 15px;">
                A Guide to Multi-Classification Methodologies
              </div>
            </div>
            
            <div style="margin-bottom: 25px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px; border-bottom: 1px solid var(--hyena-teal); padding-bottom: 5px;">
                Traditional Hierarchy
              </h3>
              <p style="margin-bottom: 10px;">The classic tree-like structure for organizing knowledge:</p>
              <ul style="list-style-type: none; margin-left: 10px; margin-bottom: 15px;">
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--hyena-purple); margin-right: 10px;"></span><strong>Trunk:</strong> Major foundational topics (e.g., "Consciousness")</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--hyena-blue); margin-right: 10px;"></span><strong>Branch:</strong> Significant subtopics (e.g., "Hermetics")</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--hyena-teal); margin-right: 10px;"></span><strong>Leaf:</strong> Individual concept notes (e.g., "As Above, So Below")</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--hyena-pink); margin-right: 10px;"></span><strong>Flower:</strong> Details and expansions (e.g., "I Think / Am")</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: #f59e0b; margin-right: 10px;"></span><strong>Fruit:</strong> Applications and examples (e.g., practical uses)</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--hyena-yellow); margin-right: 10px;"></span><strong>Bud:</strong> Nascent ideas not yet fully formed</li>
              </ul>
              <p style="font-size: 12px; color: #666; font-style: italic;">ID Formatting: Trunks (1000, 2000), Branches (1100, 1200), Leaves (1101, 1102), Flowers (1101/1), Fruits (1101/1/A), Buds (nested further, e.g., 1101/1/A/1)</p>
            </div>
            
            <div style="margin-bottom: 25px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px; border-bottom: 1px solid var(--hyena-teal); padding-bottom: 5px;">
                Cosmic Kingdoms
              </h3>
              <p style="margin-bottom: 10px;">A domain-based classification system that groups knowledge by conceptual realms:</p>
              <ul style="list-style-type: none; margin-left: 10px; margin-bottom: 15px;">
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--kingdom-existentia); margin-right: 10px;"></span><strong>Existentia üåå:</strong> Being, reality, ontology, metaphysics</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--kingdom-cognitio); margin-right: 10px;"></span><strong>Cognitio üí°:</strong> Knowledge, thought, epistemology, perception</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--kingdom-actus); margin-right: 10px;"></span><strong>Actus üöÄ:</strong> Action, movement, change, process</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--kingdom-valor); margin-right: 10px;"></span><strong>Valor ‚öñÔ∏è:</strong> Value, ethics, aesthetics, judgment</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--kingdom-systema); margin-right: 10px;"></span><strong>Systema ‚öôÔ∏è:</strong> Systems, structures, patterns, order</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--kingdom-significatio); margin-right: 10px;"></span><strong>Significatio üí¨:</strong> Meaning, language, symbols, communication</li>
              </ul>
              <p style="margin-bottom: 10px;">Each kingdom is further divided into planets (disciplines) P1-P9:</p>
              <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;">
                <span style="background-color: #9C27B0; color: white; padding: 3px 8px; border-radius: 10px;">P1 ‚ôá Metaphysics</span>
                <span style="background-color: #FF9800; color: white; padding: 3px 8px; border-radius: 10px;">P2 ‚òâ Ontology</span>
                <span style="background-color: #FFEB3B; color: black; padding: 3px 8px; border-radius: 10px;">P3 ‚òΩ Phenomenology</span>
                <span style="background-color: #2196F3; color: white; padding: 3px 8px; border-radius: 10px;">P4 ‚ôÉ Epistemology</span>
                <span style="background-color: #00BCD4; color: white; padding: 3px 8px; border-radius: 10px;">P5 ‚òø Hermeneutics</span>
                <span style="background-color: #F44336; color: white; padding: 3px 8px; border-radius: 10px;">P6 ‚ôÇ Praxeology</span>
                <span style="background-color: #4CAF50; color: white; padding: 3px 8px; border-radius: 10px;">P7 ‚ôÄ Axiology</span>
                <span style="background-color: #FF9800; color: white; padding: 3px 8px; border-radius: 10px;">P8 ‚ôÑ Taxonomy</span>
                <span style="background-color: #607D8B; color: white; padding: 3px 8px; border-radius: 10px;">P9 ‚ôÖ Semiotics</span>
              </div>
            </div>
            
            <div style="margin-bottom: 25px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px; border-bottom: 1px solid var(--hyena-teal); padding-bottom: 5px;">
                Philosophical Frames
              </h3>
              <p style="margin-bottom: 10px;">A tiered approach to classifying knowledge by philosophical frameworks:</p>
              
              <h4 style="margin-top: 15px; margin-bottom: 5px; color: var(--hyena-purple);">Tier I - Philosophical Approach</h4>
              <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">ONT - Ontology</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">EPI - Epistemology</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">AXI - Axiology</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">TAX - Taxonomy</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">TEL - Teleology</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">PRX - Praxis</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">MTH - Methodology</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">LOG - Logic</span>
              </div>
              
              <h4 style="margin-top: 15px; margin-bottom: 5px; color: var(--hyena-purple);">Tier II - Expressive Mode</h4>
              <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">MYT - Mythological</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">SYM - Symbolic</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">RIT - Ritual</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">PSY - Psychological</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">HST - Historical</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">ANA - Analytical</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">DES - Descriptive</span>
              </div>
              
              <h4 style="margin-top: 15px; margin-bottom: 5px; color: var(--hyena-purple);">Tier III - Liminal Zone</h4>
              <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">DAE - Daemonic</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">OCC - Occult</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">PAR - Paradoxical</span>
                <span style="background-color: #555; color: white; padding: 3px 8px; border-radius: 10px;">LUM - Liminal</span>
              </div>
            </div>
            
            <div style="margin-bottom: 25px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px; border-bottom: 1px solid var(--hyena-teal); padding-bottom: 5px;">
                Codex Systems
              </h3>
              <p style="margin-bottom: 10px;">Specialized notation systems for particular types of esoteric knowledge:</p>
              <ul style="list-style-type: none; margin-left: 10px; margin-bottom: 15px;">
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--codex-cg); margin-right: 10px;"></span><strong>CG - Chaos Grimoire:</strong> Notes on chaos magic, memetics, and sigil work</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--codex-ts); margin-right: 10px;"></span><strong>TS - Thought Sigils:</strong> Visual symbols, diagrams, and thought experiments</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--codex-paps); margin-right: 10px;"></span><strong>PAPS - Diagnostics:</strong> Pattern analysis and problem-solving frameworks</li>
                <li><span style="display: inline-block; width: 20px; height: 10px; background-color: var(--codex-coai); margin-right: 10px;"></span><strong>COAI - Oracle:</strong> Predictive systems and divination methods</li>
              </ul>
            </div>
            
            <div style="margin-bottom: 25px;">
              <h3 style="color: var(--hyena-teal); margin-bottom: 10px; border-bottom: 1px solid var(--hyena-teal); padding-bottom: 5px;">
                Emergent Tablets
              </h3>
              <p style="margin-bottom: 10px;">For ideas that don't fit neatly into established classifications:</p>
              <ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 15px;">
                <li>Automatically assigned unique IDs prefixed with "e-"</li>
                <li>Exempt from traditional hierarchical relationships</li>
                <li>Can later be reclassified into the structured systems if patterns emerge</li>
                <li>Ideal for capturing sudden insights, dreams, imported content, or ambiguous connections</li>
              </ul>
            </div>
            
            <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px dashed var(--hyena-teal);">
              <p><em>"Classifications are never innocent; they embody the worldview of their creators."</em></p>
            </div>
          </div>
        `;
        
        // Create and show dialog
        createAndShowDialog("Classification Systems", dialogContent);
      }
      
      function createAndShowDialog(title, content) {
        // Get the dialog elements
        const dialog = document.getElementById('zettelDialog');
        const titleElement = document.getElementById('zettelDialogTitle');
        const contentElement = document.getElementById('zettelDialogContent');
        
        // Set title and content
        titleElement.textContent = title;
        contentElement.innerHTML = content;
        
        // Show the dialog
        dialog.style.display = 'flex';
      }
        
        // Start the app with the Zettelkasten window open
        openWindow('zettelkastenWindow');
        
        // Update taskbar
        updateTaskbar();
        
        // Check if mobile view is needed
        checkDefaultView();
      }
      
      // Initialize the app
      initializeApp();
    });
  </script>
</body>
</html>