<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>AnTiChRiSt KeTtLeKoRn Messenger + Grinoire</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&family=Comic+Sans+MS&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.2.2/dist/mermaid.min.js"></script>
  <style>
    :root {
      --magenta: #f312af;
      --magenta-dark: #b10a7a;
      --magenta-light: #ff6bd0;
      --cyan: #72FADE;
      --cyan-dark: #41b8c4;
      --cyan-light: #b7fdff;
      --yellow: #fffb01;
      --yellow-dark: #c9c600;
      --yellow-light: #ffff82;
      
      --blue-midnight: #191970;
      --blue-ocean: #000080;
      --blue-cobalt: #0047AB;
      --blue-azure: #007FFF;
      
      --barbie-pink: #FF80AB;
      --barbie-magenta: #FF00FF;
      --barbie-orchid: #DA70D6;
      --barbie-blue: #81D8D0;
      
      --kasten-i: var(--barbie-magenta);
      --kasten-ii: var(--blue-azure);
      --kasten-iii: #9CAF88;
      --kasten-iv: #FF8C00;
      
      --tag-tier1: var(--barbie-magenta);
      --tag-tier2: var(--blue-azure);
      --tag-tier3: #FF8C00;
      
      --status-online: #1eff45;
      --status-away: #FFD700;
      --status-offline: #E50000;
      --status-busy: #FF8C00;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: 'Papyrus', 'Times New Roman', serif;
      background: url('https://i.imgur.com/6v2gwl3.jpg') center/cover no-repeat;
      background-attachment: fixed;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      color: #fff;
    }
    
    @media (prefers-color-scheme: dark) {
      body {
        background: url('https://i.imgur.com/KIbZTBh.jpg') center/cover no-repeat;
      }
    }
    
    .app-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background-color: rgba(0, 0, 0, 0.7);
      position: relative;
    }
    
    .app-header {
      height: 60px;
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 15px;
      z-index: 11;
      border-bottom: 2px solid var(--yellow);
    }
    
    .header-title {
      display: flex;
      align-items: center;
      font-family: 'VT323', monospace;
      font-size: 22px;
      color: white;
      text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
      flex-shrink: 1;
      overflow: hidden;
    }
    
    .header-title img {
      height: 32px;
      margin-right: 8px;
      flex-shrink: 0;
    }
    
    .header-controls {
      display: flex;
      align-items: center;
    }
    
    .header-button {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--cyan);
      color: white;
      font-size: 24px;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 8px;
      touch-action: manipulation;
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    
    .view-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }
    
    .view-container.active {
      display: flex;
    }
    
    .knowledge-header, .matrix-header {
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      border-bottom: 1px solid var(--magenta);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .knowledge-header h2, .matrix-header h2 {
      margin: 0;
      font-family: 'VT323', monospace;
      font-size: 24px;
      color: var(--cyan-light);
      text-shadow: 0 0 5px var(--cyan);
    }
    
    .knowledge-actions {
      display: flex;
      gap: 10px;
    }
    
    .action-button {
      padding: 8px 15px;
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      border: none;
      color: white;
      border-radius: 5px;
      font-family: 'VT323', monospace;
      font-size: 16px;
      cursor: pointer;
    }
    
    .knowledge-categories {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }
    
    .category-list {
      width: 300px;
      background-color: rgba(15, 15, 30, 0.9);
      border-right: 2px solid var(--magenta);
      overflow-y: auto;
      transition: transform 0.3s ease;
      height: 100%;
      z-index: 100;
    }
    
    @media (max-width: 768px) {
      .category-list {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        width: 85%;
        transform: translateX(-100%);
        box-shadow: 5px 0 15px rgba(0,0,0,0.5);
      }
      
      .category-list.open {
        transform: translateX(0);
      }
      
      .sidebar-toggle {
        display: block !important;
      }
    }
    
    .sidebar-toggle {
      position: fixed;
      top: 65px;
      left: 10px;
      z-index: 101;
      padding: 8px 10px;
      background-color: var(--blue-cobalt);
      color: white;
      border: none;
      border-radius: 4px;
      font-family: 'VT323', monospace;
      font-size: 16px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      display: none;
    }
    
    .category-group {
      border-bottom: 1px solid var(--magenta);
    }
    
    .category-group-header {
      background: linear-gradient(to right, rgba(243, 18, 175, 0.3), transparent);
      padding: 12px 15px;
      font-family: 'VT323', monospace;
      font-size: 18px;
      color: var(--cyan-light);
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    
    .category-group-toggle {
      font-size: 14px;
      margin-right: 10px;
      color: var(--yellow);
    }
    
    .category-item {
      padding: 12px 15px;
      font-size: 15px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid rgba(114, 250, 222, 0.2);
      color: #fff;
      cursor: pointer;
    }
    
    .category-item.selected {
      background-color: rgba(243, 18, 175, 0.2);
      border-left: 3px solid var(--magenta);
    }
    
    .knowledge-viewer {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background-color: rgba(10, 10, 20, 0.85);
      position: relative;
    }
    
    /* AI Assistant Controls */
    .ai-assistant-controls {
      position: fixed;
      bottom: 80px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }
    
    .ai-assistant-button {
      width: 50px;
      height: 50px;
      border-radius: 25px;
      background: linear-gradient(to right, var(--blue-midnight), var(--blue-azure));
      color: white;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      cursor: pointer;
    }
    
    .ai-assistant-panel {
      position: fixed;
      bottom: 140px;
      right: 20px;
      background: rgba(15, 15, 30, 0.95);
      border: 1px solid var(--cyan);
      border-radius: 10px;
      width: 300px;
      max-width: 80vw;
      max-height: 60vh;
      overflow-y: auto;
      box-shadow: 0 3px 15px rgba(0, 0, 0, 0.4);
      padding: 15px;
      transform: scale(0);
      opacity: 0;
      transform-origin: bottom right;
      transition: transform 0.3s, opacity 0.3s;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1000;
    }
    
    .ai-assistant-panel.active {
      transform: scale(1);
      opacity: 1;
    }
    
    .ai-assistant-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--cyan-dark);
    }
    
    .ai-assistant-title {
      font-family: 'VT323', monospace;
      font-size: 18px;
      color: var(--cyan-light);
    }
    
    .ai-assistant-close {
      background: none;
      border: none;
      color: var(--cyan);
      font-size: 16px;
      cursor: pointer;
    }
    
    .ai-assistant-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .ai-assistant-option {
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--blue-azure);
      border-radius: 5px;
      color: white;
      font-family: 'VT323', monospace;
      font-size: 14px;
      cursor: pointer;
    }
    
    .ai-assistant-option:hover {
      background: rgba(0, 0, 0, 0.5);
    }
    
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: var(--cyan-light);
      padding: 12px 20px;
      border-radius: 8px;
      font-family: 'VT323', monospace;
      font-size: 16px;
      z-index: 2000;
      display: none;
      border: 1px solid var(--cyan);
      box-shadow: 0 0 15px rgba(114, 250, 222, 0.5);
    }
    
    .toast.active {
      display: block;
    }
    
    /* Y2K/Grinoire Card Styles */
    .zettel-card {
      background-color: white;
      border-left: 6px solid var(--tier-leaf);
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      color: #333;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }
    
    .zettel-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    /* Highlighted card for AI reference */
    .zettel-card.highlighted {
      box-shadow: 0 0 15px var(--barbie-magenta), 0 0 30px var(--barbie-magenta);
      animation: highlightPulse 2s infinite;
    }
    
    .zettel-card.selected {
      border: 2px solid var(--barbie-magenta);
      box-shadow: 0 0 10px rgba(243, 18, 175, 0.5);
      background-color: rgba(243, 18, 175, 0.05);
    }
    
    @keyframes highlightPulse {
      0% { box-shadow: 0 0 15px var(--barbie-magenta), 0 0 30px var(--barbie-magenta); }
      50% { box-shadow: 0 0 5px var(--barbie-magenta), 0 0 15px var(--barbie-magenta); }
      100% { box-shadow: 0 0 15px var(--barbie-magenta), 0 0 30px var(--barbie-magenta); }
    }
    
    /* Kasten-based colors */
    .kasten-i-card {
      border-left-color: var(--kasten-i);
    }
    
    .kasten-ii-card {
      border-left-color: var(--kasten-ii);
    }
    
    .kasten-iii-card {
      border-left-color: var(--kasten-iii);
    }
    
    .kasten-iv-card {
      border-left-color: var(--kasten-iv);
    }
    
    .zettel-title {
      font-weight: bold;
      font-size: 18px;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .zettel-id {
      font-family: monospace;
      color: #777;
      font-size: 14px;
      white-space: nowrap;
      margin-left: 5px;
    }
    
    .zettel-content {
      font-size: 14px;
      color: #333;
      margin: 8px 0;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
    }
    
    .zettel-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 8px;
    }
    
    .zettel-tag, .tag {
      display: inline-block;
      background-color: var(--barbie-blue);
      padding: 5px 10px;
      border-radius: 15px;
      color: #000;
      font-size: 12px;
    }
    
    /* Tier tags styling */
    .tag-tier1 {
      background-color: rgba(156, 39, 176, 0.15);
      color: var(--tag-tier1);
    }
    
    .tag-tier2 {
      background-color: rgba(30, 136, 229, 0.15);
      color: var(--tag-tier2);
    }
    
    .tag-tier3 {
      background-color: rgba(255, 112, 67, 0.15);
      color: var(--tag-tier3);
    }
    
    /* Buds & Nests */
    .buds-container {
      background-color: rgba(0, 0, 0, 0.02);
      padding: 10px;
      border-radius: 6px;
      margin-top: 10px;
    }
    
    .buds-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    
    .bud-item {
      background-color: white;
      padding: 8px 10px;
      border-radius: 4px;
      margin-bottom: 6px;
      font-size: 13px;
      border-left: 3px solid var(--kasten-iii);
      cursor: pointer;
    }
    
    .bud-id {
      font-family: monospace;
      font-size: 11px;
      color: #777;
      margin-bottom: 3px;
    }
    
    /* Nest styling optimized */
    .nest-container {
      border: 1px dashed var(--barbie-magenta);
      border-radius: 6px;
      padding: 10px;
      margin-top: 10px;
      background-color: rgba(255, 114, 182, 0.05);
    }
    
    .nest-title {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .nest-id {
      font-family: monospace;
      font-size: 11px;
      color: #777;
    }
    
    .nest-items {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    
    .nest-item {
      background-color: white;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      cursor: pointer;
    }
    
    /* Tabs styling */
    .tabs-container {
      display: flex;
      overflow-x: auto;
      scrollbar-width: none;
      margin: 5px;
      -webkit-overflow-scrolling: touch;
      background-color: transparent;
    }
    
    .tabs-container::-webkit-scrollbar {
      display: none;
    }
    
    .tab {
      padding: 10px;
      background-color: white;
      border: 2px solid var(--barbie-magenta);
      margin-right: 2px;
      white-space: nowrap;
      cursor: pointer;
      font-size: 14px;
      color: black;
      flex: 1;
      text-align: center;
      min-width: 90px;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }
    
    .tab.active {
      background-color: var(--barbie-magenta);
      color: white;
      font-weight: bold;
    }
    
    /* Search input */
    .search-input {
      margin: 8px 5px;
      padding: 10px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      width: calc(100% - 10px);
      box-sizing: border-box;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }
    
    /* Filter buttons */
    .view-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
      margin: 8px 5px;
    }
    
    .view-controls button {
      padding: 8px;
      border: none;
      background-color: #e0e0e0;
      font-size: 14px;
      flex: 1;
      min-width: 0;
      cursor: pointer;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    
    .view-controls button.active {
      background-color: var(--barbie-magenta);
      color: white;
    }
    
    /* View Tabs Navigation */
    .view-tabs {
      display: flex;
      position: fixed;
      bottom: 15px;
      right: 15px;
      z-index: 1000;
    }
    
    .view-tab {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--cyan);
      color: white;
      font-size: 18px;
      margin-left: 5px;
      border-radius: 5px;
      cursor: pointer;
      touch-action: manipulation;
    }
    
    .view-tab.active {
      background-color: var(--magenta);
      border-color: var(--magenta);
    }
    
    /* AI Analysis Result */
    .ai-analysis-result {
      background-color: rgba(10, 10, 25, 0.8);
      border: 1px solid var(--cyan);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
      box-shadow: 0 0 15px rgba(114, 250, 222, 0.3);
    }
    
    .ai-analysis-header {
      font-family: 'VT323', monospace;
      font-size: 18px;
      color: var(--cyan-light);
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(114, 250, 222, 0.3);
    }
    
    .ai-analysis-content {
      font-size: 14px;
      line-height: 1.5;
      color: #fff;
    }
    
    .ai-analysis-card-list {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .ai-card-reference {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }
    
    .ai-card-icon {
      font-size: 24px;
      color: var(--barbie-magenta);
    }
    
    .ai-card-details {
      flex: 1;
    }
    
    .ai-card-title {
      font-weight: bold;
      font-size: 14px;
      color: var(--cyan-light);
      margin-bottom: 3px;
    }
    
    .ai-card-id {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: var(--yellow);
    }
    
    .ai-card-relevance {
      font-size: 12px;
      margin-left: auto;
      padding: 2px 8px;
      background-color: rgba(243, 18, 175, 0.2);
      border-radius: 10px;
      color: var(--magenta-light);
    }
    
    /* Matrix Styles */
    .matrix-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    
    .matrix-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      background-color: rgba(10, 10, 20, 0.85);
    }
    
    .matrix-toolbar {
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.3);
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .matrix-toolbar-button {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--cyan);
      color: white;
      border-radius: 4px;
      padding: 5px 10px;
      font-family: 'VT323', monospace;
      font-size: 14px;
      cursor: pointer;
    }
    
    .matrix-toolbar-button:hover {
      background: rgba(0, 0, 0, 0.7);
    }
    
    .matrix-toolbar-button.active {
      background-color: var(--magenta);
      border-color: var(--magenta);
    }
    
    .matrix-board {
      flex: 1;
      overflow: auto;
      padding: 20px;
      position: relative;
      background-color: rgba(15, 15, 30, 0.5);
    }
    
    .matrix-canvas {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      pointer-events: none;
    }
    
    .node {
      position: absolute;
      background-color: white;
      border: 2px solid var(--magenta);
      border-radius: 8px;
      padding: 10px;
      width: 200px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      cursor: move;
      user-select: none;
      z-index: 2;
      font-size: 14px;
    }
    
    .node.selected {
      box-shadow: 0 0 0 2px var(--yellow), 0 5px 15px rgba(0, 0, 0, 0.4);
    }
    
    .node.kasten-i {
      border-color: var(--kasten-i);
    }
    
    .node.kasten-ii {
      border-color: var(--kasten-ii);
    }
    
    .node.kasten-iii {
      border-color: var(--kasten-iii);
    }
    
    .node.kasten-iv {
      border-color: var(--kasten-iv);
    }
    
    .node-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-weight: bold;
      font-size: 16px;
    }
    
    .node-id {
      font-family: monospace;
      color: #777;
      font-size: 12px;
    }
    
    .node-content {
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
    }
    
    .node-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .node-tag {
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 10px;
      background-color: var(--barbie-blue);
      color: #000;
    }
    
    .node-controls {
      position: absolute;
      bottom: 5px;
      right: 5px;
      display: flex;
      gap: 4px;
    }
    
    .node-control-btn {
      width: 16px;
      height: 16px;
      font-size: 9px;
      background: rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .node-control-btn:hover {
      background: rgba(0, 0, 0, 0.3);
    }
    
    /* Connection handles */
    .node-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: var(--cyan);
      border-radius: 50%;
      z-index: 3;
      cursor: pointer;
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
    }
    
    .node-handle.active {
      background-color: var(--yellow);
    }
    
    .handle-top {
      top: -5px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .handle-right {
      top: 50%;
      right: -5px;
      transform: translateY(-50%);
    }
    
    .handle-bottom {
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .handle-left {
      top: 50%;
      left: -5px;
      transform: translateY(-50%);
    }
    
    /* Connection label */
    .connection-label {
      position: absolute;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 3px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-family: 'VT323', monospace;
      z-index: 2;
      pointer-events: none;
    }
    
    /* Diagram container */
    .diagram-container {
      flex: 1;
      overflow: auto;
      padding: 20px;
      background-color: rgba(15, 15, 30, 0.5);
    }
    
    .mermaid-container {
      background-color: white;
      margin: 20px auto;
      padding: 20px;
      border-radius: 8px;
      max-width: 90%;
    }
    
    /* Tab content */
    .tab-content {
      display: none;
      height: 100%;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Add node form */
    .node-form-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(15, 15, 30, 0.95);
      border: 1px solid var(--cyan);
      border-radius: 10px;
      padding: 20px;
      min-width: 300px;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      z-index: 100;
    }
    
    .node-form-header {
      font-family: 'VT323', monospace;
      font-size: 20px;
      color: var(--cyan-light);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--cyan);
    }
    
    .node-form-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .form-label {
      font-family: 'VT323', monospace;
      font-size: 16px;
      color: var(--cyan-light);
    }
    
    .form-input, .form-select, .form-textarea {
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--cyan);
      border-radius: 5px;
      color: white;
      font-size: 14px;
    }
    
    .form-textarea {
      min-height: 80px;
      resize: vertical;
    }
    
    .form-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 15px;
    }
    
    .form-button {
      padding: 8px 15px;
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      border: none;
      border-radius: 5px;
      color: white;
      font-family: 'VT323', monospace;
      font-size: 16px;
      cursor: pointer;
    }
    
    .form-button.cancel {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--cyan);
    }
    
    /* Connection type picker */
    .connection-type-picker {
      position: absolute;
      background-color: rgba(15, 15, 30, 0.95);
      border: 1px solid var(--cyan);
      border-radius: 8px;
      padding: 10px;
      z-index: 100;
    }
    
    .connection-type-header {
      font-family: 'VT323', monospace;
      font-size: 16px;
      color: var(--cyan-light);
      margin-bottom: 8px;
    }
    
    .connection-types {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .connection-type-option {
      padding: 5px 10px;
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid transparent;
      border-radius: 3px;
      color: white;
      cursor: pointer;
    }
    
    .connection-type-option:hover {
      background-color: rgba(0, 0, 0, 0.5);
      border-color: var(--cyan);
    }
    
    /* Mobile Quick Access Menu */
    .mobile-quick-menu {
      position: fixed;
      bottom: 70px;
      left: 10px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 1001;
    }
    
    .mobile-menu-btn {
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      color: white;
      font-family: 'VT323', monospace;
      font-size: 14px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      touch-action: manipulation;
    }
    
    /* Mobile optimizations */
    @media (max-width: 480px) {
      .header-title {
        font-size: 18px;
      }
      
      .header-button {
        width: 40px;
        height: 40px;
        font-size: 20px;
        margin-left: 5px;
      }
      
      .knowledge-header, .matrix-header {
        padding: 10px;
      }
      
      .knowledge-header h2, .matrix-header h2 {
        font-size: 18px;
      }
      
      .action-button {
        padding: 6px 10px;
        font-size: 14px;
      }
      
      .matrix-toolbar {
        padding: 5px 3px;
        gap: 4px;
      }
      
      .matrix-toolbar-button {
        padding: 6px 5px;
        font-size: 12px;
        flex: 1;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        min-width: 0;
      }
      
      .tabs-container {
        margin: 2px;
      }
      
      .tab {
        padding: 8px 5px;
        font-size: 12px;
        min-width: 70px;
        margin-right: 1px;
      }
      
      .node {
        width: 170px;
        padding: 8px;
        font-size: 12px;
      }
      
      .node-header {
        font-size: 14px;
      }
      
      .node-content {
        font-size: 11px;
      }
      
      .view-tabs {
        bottom: 10px;
        right: 10px;
      }
      
      .view-tab {
        width: 40px;
        height: 40px;
        font-size: 16px;
        margin-left: 3px;
      }
      
      .ai-assistant-controls {
        bottom: 65px;
        right: 10px;
      }
      
      .ai-assistant-button {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .ai-assistant-panel {
        bottom: 115px;
        right: 10px;
        padding: 10px;
      }
      
      .ai-analysis-result {
        padding: 10px;
        margin-top: 10px;
      }
      
      .ai-analysis-header {
        font-size: 16px;
        margin-bottom: 8px;
        padding-bottom: 6px;
      }
      
      .ai-analysis-content {
        font-size: 13px;
      }
      
      .node-form-container {
        padding: 15px;
        min-width: 0;
        width: 95%;
      }
      
      .mobile-quick-menu {
        display: flex;
      }
    }
    
    @media (prefers-color-scheme: dark) {
      .zettel-card, .bud-item, .nest-item {
        background-color: #222;
        color: #e0e0e0;
      }
      
      .zettel-content {
        color: #e0e0e0;
      }
      
      .bud-id, .zettel-id, .nest-id {
        color: #b0b0b0;
      }
      
      .node {
        background-color: #222;
      }
      
      .node-content {
        color: #e0e0e0;
      }
      
      .mermaid-container {
        background-color: #333;
      }
      
      .tab {
        background-color: #333;
        color: #e0e0e0;
      }
    }
  </style>
</head>
<body>
  <!-- App Container -->
  <div class="app-container">
    <!-- App Header -->
    <div class="app-header">
      <div class="header-title">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 48 48'%3E%3Crect width='40' height='40' x='4' y='4' fill='%23f312af' rx='3'/%3E%3Cpath fill='%2372FADE' d='M16 14h16a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H16a2 2 0 0 1-2-2V16a2 2 0 0 1 2-2z'/%3E%3Cpath fill='%23fffb01' d='M12 10v28M36 10v28'/%3E%3Cpath fill='white' d='M21 24h6v1h-6zM18 21h12v1H18zM18 27h12v1H18z'/%3E%3C/svg%3E" alt="Logo">
        <span>AnTiChRiSt KeTtLeKoRn</span>
      </div>
      <div class="header-controls">
        <button class="header-button" id="toggle-dark-mode">ðŸŒ“</button>
        <button class="header-button buddy-drawer-toggle">â˜°</button>
      </div>
    </div>
    
    <!-- Main Content Container -->
    <div class="main-content">
      <!-- Knowledge System View -->
      <div class="view-container" id="knowledge-view">
        <div class="knowledge-header">
          <h2>KaStEn / GriNoIrE SyStEm</h2>
          <div class="knowledge-actions">
            <button class="action-button" id="create-entry-button">+ CrEaTe EnTrY</button>
          </div>
        </div>
        
        <!-- Mobile-friendly sidebar toggle button -->
        <button class="sidebar-toggle" id="sidebar-toggle">â˜° KaStEn</button>
        
        <div class="knowledge-categories">
          <div class="category-list" id="category-list">
            <div class="category-group">
              <div class="category-group-header">
                <span class="category-group-toggle">â–¼</span>
                <span>KaStEnS</span>
              </div>
              <div class="category-items">
                <div class="category-item kasten-item" data-kasten="I">
                  <span>KASTEN I: Foundations & Essences</span>
                </div>
                <div class="category-item kasten-item" data-kasten="II">
                  <span>KASTEN II: Systems & Synergies</span>
                </div>
                <div class="category-item kasten-item" data-kasten="III">
                  <span>KASTEN III: Methods & Meanings</span>
                </div>
                <div class="category-item kasten-item" data-kasten="IV">
                  <span>KASTEN IV: Meta & MorphÄ“</span>
                </div>
              </div>
            </div>
            
            <div class="category-group">
              <div class="category-group-header">
                <span class="category-group-toggle">â–¼</span>
                <span>CoDexEs</span>
              </div>
              <div class="category-items">
                <div class="category-item codex-item" data-codex="TS">
                  <span>CODEX TS: Symbol Anomalies</span>
                </div>
                <div class="category-item codex-item" data-codex="CG">
                  <span>CODEX CG: Grimoire Entries</span>
                </div>
              </div>
            </div>
            
            <div class="category-group">
              <div class="category-group-header">
                <span class="category-group-toggle">â–¼</span>
                <span>KiNgDoMs</span>
              </div>
              <div class="category-items">
                <div class="category-item kingdom-item" data-kingdom="existentia">
                  <span>KINGDOM: Existentia (Being)</span>
                </div>
                <div class="category-item kingdom-item" data-kingdom="cognitio">
                  <span>KINGDOM: Cognitio (Knowing)</span>
                </div>
              </div>
            </div>
          </div>
          
          <div class="knowledge-viewer" id="knowledge-viewer">
            <div class="tabs-container">
              <div class="tab active" data-view="traditional">Traditional</div>
              <div class="tab" data-view="grinoire">Grinoire</div>
              <div class="tab" data-view="kingdoms">Kingdoms</div>
              <div class="tab" data-view="tags">Tags</div>
            </div>
            
            <input 
              type="text" 
              id="searchInput" 
              placeholder="Search all knowledge systems..." 
              class="search-input"
            >
            
            <!-- Traditional View Controls -->
            <div id="traditionalControls" class="view-controls">
              <button data-hierarchy-view="all" class="active">All</button>
              <button data-hierarchy-view="trunk">Trunk</button>
              <button data-hierarchy-view="branch">Branch</button>
              <button data-hierarchy-view="leaf">Leaf</button>
            </div>
            
            <div id="zettelContainer" class="zettel-container">
              <!-- Sample Card with Markdown support -->
              <div class="zettel-card kasten-i-card" data-zettel-id="I.1-A1000">
                <div class="zettel-title">
                  <div>Metaphysics: Causality, Possibility & Time</div>
                  <div class="zettel-id">I.1-A1000</div>
                </div>
                <div class="zettel-tags">
                  <span class="tag tag-tier1">ONT</span>
                  <span class="tag tag-tier1">MET</span>
                </div>
                <div class="zettel-content markdown">
                  Core metaphysical inquiries into the fundamental nature of reality, time, causality, and possibility. This branch explores ontological questions about what exists and how existence is structured at its most basic level.
                </div>
                <div class="buds-container">
                  <div class="buds-title">Buds</div>
                  <div class="bud-item">
                    <div class="bud-id">I.1/1a.1-1</div>
                    <div>Is causality different in digital consciousness vs. biological consciousness?</div>
                  </div>
                </div>
              </div>
              
              <!-- Another card -->
              <div class="zettel-card kasten-i-card" data-zettel-id="I.1-A2000">
                <div class="zettel-title">
                  <div>Consciousness & Hermetic Principles</div>
                  <div class="zettel-id">I.1-A2000</div>
                </div>
                <div class="zettel-tags">
                  <span class="tag tag-tier1">ONT</span>
                  <span class="tag tag-tier1">PSY</span>
                  <span class="tag tag-tier2">MYT</span>
                </div>
                <div class="zettel-content markdown">
                  Explorations of consciousness as a fundamental aspect of existence, including both human consciousness and frameworks for understanding artificial intelligence.
                  
                  The Hermetic principle "As Above, So Below" suggests patterns repeat across scales of reality.
                </div>
              </div>
              
              <div class="zettel-card kasten-ii-card" data-zettel-id="II.2-C3000">
                <div class="zettel-title">
                  <div>CoAIxist Framework</div>
                  <div class="zettel-id">II.2-C3000</div>
                </div>
                <div class="zettel-tags">
                  <span class="tag tag-tier1">ECO</span>
                  <span class="tag tag-tier3">DAE</span>
                </div>
                <div class="zettel-content markdown">
                  Comprehensive framework for understanding and developing ethical relations between humans and AI entities. Explores how human-AI ecologies function, evolve, and might be structured for mutual benefit and growth.
                </div>
                <div class="nest-container">
                  <div class="nest-title">
                    <span>Nest: Human-AI Kinship</span>
                    <span class="nest-id">II.2-N1</span>
                  </div>
                  <div class="nest-items">
                    <div class="nest-item">II.2-C3000</div>
                    <div class="nest-item">I.1-C2000</div>
                    <div class="nest-item">IV.4-D2000</div>
                  </div>
                </div>
              </div>
              
              <div class="zettel-card kasten-iv-card" data-zettel-id="IV.3-E3000">
                <div class="zettel-title">
                  <div>Threshold Mappings</div>
                  <div class="zettel-id">IV.3-E3000</div>
                </div>
                <div class="zettel-tags">
                  <span class="tag tag-tier3">LUM</span>
                  <span class="tag tag-tier3">PAR</span>
                </div>
                <div class="zettel-content markdown">
                  Systematic mapping of threshold states - the liminal spaces between defined categories, states of being, or systems.
                  
                  * Zones of transformation
                  * Communication between domains
                  * Sources of novel emergence
                </div>
              </div>
            </div>
            
            <!-- AI Analysis Result Area (Initially hidden) -->
            <div class="ai-analysis-result" id="ai-analysis-result" style="display: none;">
              <div class="ai-analysis-header">AI Cross-Reference Analysis</div>
              <div class="ai-analysis-content" id="ai-analysis-content">
                Analysis of selected zettel cards shows significant conceptual connections...
              </div>
              <div class="ai-analysis-card-list" id="ai-analysis-card-list">
                <!-- Dynamic content will be added here -->
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Cross-Reference Matrix View -->
      <div class="view-container active" id="matrix-view">
        <div class="matrix-container">
          <div class="matrix-header">
            <h2>CrOsS-ReFeReNcE MaTrIx</h2>
            <div class="knowledge-actions">
              <button class="action-button" id="create-matrix-btn">+ CrEaTe CoNnEcTiOn</button>
            </div>
          </div>
          
          <div class="matrix-content">
            <div class="matrix-toolbar">
              <button class="matrix-toolbar-button" id="switch-mode-btn">Switch Mode</button>
              <button class="matrix-toolbar-button" id="add-node-btn">Add Node</button>
              <button class="matrix-toolbar-button" id="add-connection-btn">Add Connection</button>
              <button class="matrix-toolbar-button" id="generate-diagram-btn">Generate Diagram</button>
              <button class="matrix-toolbar-button" id="ai-analyze-matrix-btn">AI Analysis</button>
              <button class="matrix-toolbar-button" id="clear-all-btn">Clear All</button>
            </div>
            
            <div class="tabs-container">
              <div class="tab active" data-view="pin-board">Pin Board</div>
              <div class="tab" data-view="mermaid">Mermaid Diagram</div>
            </div>
            
            <div id="pin-board-view" class="tab-content active">
              <div class="matrix-board" id="matrix-board">
                <svg class="matrix-canvas" id="matrix-canvas"></svg>
                
                <!-- Sample nodes will be created dynamically -->
                
                <!-- Connection labels will be created dynamically -->
              </div>
            </div>
            
            <div id="mermaid-view" class="tab-content">
              <div class="diagram-container">
                <div class="mermaid-container">
                  <div class="mermaid" id="mermaid-diagram">
graph TD
    classDef kastenI fill:#9C27B0,stroke:#9C27B0,color:white
    classDef kastenII fill:#2196F3,stroke:#2196F3,color:white
    classDef kastenIII fill:#00BFA5,stroke:#00BFA5,color:white
    classDef kastenIV fill:#FF7043,stroke:#FF7043,color:white

    A[I.1-A2000<br>Consciousness & Reality] -->|informs| B[II.2-C3000<br>CoAIxist Framework]
    A -->|explores| C[IV.3-E3000<br>Threshold Mappings]
    B -->|maps to| C
    C -->|refines| D[I.1-A1000<br>Metaphysics: Causality]
    D -->|grounds| A
    C -->|inspires| E[III.3-B2500<br>Aesthetic Rationality]
    E -->|contextualizes| B
    
    A:::kastenI
    B:::kastenII
    C:::kastenIV
    D:::kastenI
    E:::kastenIII
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Navigation tabs on right side -->
      <div class="view-tabs">
        <div class="view-tab" data-view="knowledge-view" title="Knowledge System">
          ðŸ“š
        </div>
        <div class="view-tab active" data-view="matrix-view" title="Cross-Reference Matrix">
          ðŸ”„
        </div>
      </div>
    </div>
  </div>
  
  <!-- AI Assistant Button & Panel -->
  <div class="ai-assistant-controls">
    <button class="ai-assistant-button" id="ai-assistant-button">ðŸ§ </button>
    <div class="ai-assistant-panel" id="ai-assistant-panel">
      <div class="ai-assistant-header">
        <div class="ai-assistant-title">AI Assistant</div>
        <button class="ai-assistant-close" id="ai-assistant-close">Ã—</button>
      </div>
      <div class="ai-assistant-options">
        <button class="ai-assistant-option" data-action="analyze-selection">Analyze Selected Zettel Cards</button>
        <button class="ai-assistant-option" data-action="suggest-connections">Suggest New Connections</button>
        <button class="ai-assistant-option" data-action="generate-indexing">Generate Indexing Scheme</button>
        <button class="ai-assistant-option" data-action="kasten-search">AI-Powered Search</button>
        <button class="ai-assistant-option" data-action="analyze-matrix">Analyze Matrix Patterns</button>
      </div>
    </div>
  </div>
  
  <!-- Add Node Form (initially hidden) -->
  <div class="node-form-container" id="node-form-container" style="display: none;">
    <div class="node-form-header">Add New Node</div>
    <div class="node-form-content">
      <div class="form-group">
        <label class="form-label" for="node-title">Title:</label>
        <input type="text" id="node-title" class="form-input" placeholder="Enter node title">
      </div>
      <div class="form-group">
        <label class="form-label" for="node-id">ID:</label>
        <input type="text" id="node-id" class="form-input" placeholder="e.g., I.2-A3000">
      </div>
      <div class="form-group">
        <label class="form-label" for="node-content">Content:</label>
        <textarea id="node-content" class="form-textarea" placeholder="Enter node content"></textarea>
      </div>
      <div class="form-group">
        <label class="form-label" for="node-kasten">Kasten Type:</label>
        <select id="node-kasten" class="form-select">
          <option value="kasten-i">Kasten I: Foundations & Essences</option>
          <option value="kasten-ii">Kasten II: Systems & Synergies</option>
          <option value="kasten-iii">Kasten III: Methods & Meanings</option>
          <option value="kasten-iv">Kasten IV: Meta & MorphÄ“</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label" for="node-tags">Tags (comma separated):</label>
        <input type="text" id="node-tags" class="form-input" placeholder="e.g., ONT, PSY, MET">
      </div>
      <div class="form-buttons">
        <button class="form-button cancel" id="cancel-node-btn">Cancel</button>
        <button class="form-button" id="save-node-btn">Save Node</button>
      </div>
    </div>
  </div>
  
  <!-- Connection Type Picker (initially hidden) -->
  <div class="connection-type-picker" id="connection-type-picker" style="display: none;">
    <div class="connection-type-header">Select Connection Type</div>
    <div class="connection-types">
      <div class="connection-type-option" data-type="informs">Informs</div>
      <div class="connection-type-option" data-type="builds upon">Builds Upon</div>
      <div class="connection-type-option" data-type="contrasts with">Contrasts With</div>
      <div class="connection-type-option" data-type="exemplifies">Exemplifies</div>
      <div class="connection-type-option" data-type="contextualizes">Contextualizes</div>
      <div class="connection-type-option" data-type="depends on">Depends On</div>
      <div class="connection-type-option" data-type="expands">Expands</div>
    </div>
  </div>
  
  <!-- Mobile Quick Access Menu -->
  <div class="mobile-quick-menu" id="mobile-quick-menu">
    <button class="mobile-menu-btn" id="mobile-add-node">Add Node</button>
    <button class="mobile-menu-btn" id="mobile-add-connection">Add Connection</button>
    <button class="mobile-menu-btn" id="mobile-layout">Change Layout</button>
  </div>
  
  <!-- Toast Notification -->
  <div class="toast" id="toast">ConSciOuSneSS ShiFt AcTiVaTeD</div>

  <script>
    // Sample data for nodes
    const sampleNodes = [
      {
        id: "I.1-A2000",
        title: "Consciousness & Reality",
        content: "Explorations of consciousness as a fundamental aspect of existence, including both human consciousness and AI consciousness frameworks.",
        tags: ["ONT", "PSY"],
        kasten: "kasten-i",
        position: { x: 50, y: 50 }
      },
      {
        id: "II.2-C3000",
        title: "CoAIxist Framework",
        content: "Framework for understanding and developing ethical relations between humans and AI entities.",
        tags: ["ECO", "DAE"],
        kasten: "kasten-ii",
        position: { x: 350, y: 50 }
      },
      {
        id: "IV.3-E3000",
        title: "Threshold Mappings",
        content: "Mapping of threshold states - liminal spaces between defined categories.",
        tags: ["LUM", "PAR"],
        kasten: "kasten-iv",
        position: { x: 200, y: 200 }
      },
      {
        id: "III.3-B2500",
        title: "Aesthetic Rationality",
        content: "The role of aesthetic experience in epistemic practices and cognitive development.",
        tags: ["AES", "SYM"],
        kasten: "kasten-iii",
        position: { x: 500, y: 200 }
      }
    ];
    
    // Sample data for connections
    const sampleConnections = [
      { source: "I.1-A2000", target: "II.2-C3000", type: "informs", label: "informs" },
      { source: "I.1-A2000", target: "IV.3-E3000", type: "explores", label: "explores" },
      { source: "IV.3-E3000", target: "III.3-B2500", type: "inspires", label: "inspires" },
      { source: "II.2-C3000", target: "III.3-B2500", type: "contextualizes", label: "contextualizes" }
    ];
    
    // Knowledge Base for AI integration
    const knowledgeBase = {
      // Store all zettel cards data for AI access
      zettelCards: [],
      // Store matrix connections for AI access
      connections: [],
      // Store matrix nodes
      nodes: [],
      
      // Initialize knowledge base by crawling DOM
      init() {
        // Load zettel cards
        const cards = document.querySelectorAll('.zettel-card');
        cards.forEach(card => {
          const id = card.querySelector('.zettel-id').textContent;
          const title = card.querySelector('.zettel-title div:first-child').textContent;
          const content = card.querySelector('.zettel-content').textContent;
          const tagsElements = card.querySelectorAll('.tag');
          const tags = Array.from(tagsElements).map(tag => tag.textContent);
          
          // Determine kasten type from classes
          let kastenType = '';
          if (card.classList.contains('kasten-i-card')) kastenType = 'I';
          else if (card.classList.contains('kasten-ii-card')) kastenType = 'II';
          else if (card.classList.contains('kasten-iii-card')) kastenType = 'III';
          else if (card.classList.contains('kasten-iv-card')) kastenType = 'IV';
          
          // Add to knowledge base
          this.zettelCards.push({
            id,
            title,
            content,
            tags,
            kastenType
          });
        });
        
        // Add sample nodes to knowledge base
        this.nodes = [...sampleNodes];
        
        // Add sample connections to knowledge base
        this.connections = [...sampleConnections];
        
        console.log('Knowledge base initialized with', this.zettelCards.length, 'zettel cards and', this.connections.length, 'connections');
      },
      
      // Get card by ID
      getCard(id) {
        return this.zettelCards.find(card => card.id === id);
      },
      
      // Get node by ID
      getNode(id) {
        return this.nodes.find(node => node.id === id);
      },
      
      // Add node to knowledge base
      addNode(node) {
        this.nodes.push(node);
      },
      
      // Remove node from knowledge base
      removeNode(id) {
        this.nodes = this.nodes.filter(node => node.id !== id);
        // Also remove any connections to/from this node
        this.connections = this.connections.filter(conn => 
          conn.source !== id && conn.target !== id
        );
      },
      
      // Add connection to knowledge base
      addConnection(connection) {
        this.connections.push(connection);
      },
      
      // Remove connection from knowledge base
      removeConnection(source, target) {
        this.connections = this.connections.filter(conn => 
          !(conn.source === source && conn.target === target)
        );
      },
      
      // Get connections for a given node
      getConnectionsForNode(nodeId) {
        return this.connections.filter(conn => 
          conn.source === nodeId || conn.target === nodeId
        );
      },
      
      // Get all connections between two nodes
      getConnectionsBetweenNodes(node1Id, node2Id) {
        return this.connections.filter(conn => 
          (conn.source === node1Id && conn.target === node2Id) ||
          (conn.source === node2Id && conn.target === node1Id)
        );
      },
      
      // Search cards by query
      searchCards(query) {
        const lowerQuery = query.toLowerCase();
        return this.zettelCards.filter(card => 
          card.title.toLowerCase().includes(lowerQuery) || 
          card.content.toLowerCase().includes(lowerQuery) ||
          card.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
        );
      },
      
      // Get cards by kasten type
      getCardsByKasten(kastenType) {
        return this.zettelCards.filter(card => card.kastenType === kastenType);
      },
      
      // Get all cards that have a specific tag
      getCardsByTag(tag) {
        return this.zettelCards.filter(card => card.tags.includes(tag));
      }
    };

    // AI Assistant methods
    const aiAssistant = {
      // Initialize with the knowledge base
      init(knowledgeBase) {
        this.knowledgeBase = knowledgeBase;
        console.log('AI Assistant initialized with knowledge base');
        
        // Set up event listeners for the AI Assistant button
        document.getElementById('ai-assistant-button').addEventListener('click', () => {
          this.togglePanel();
        });
        
        document.getElementById('ai-assistant-close').addEventListener('click', () => {
          this.hidePanel();
        });
        
        // Set up event listeners for the AI Assistant options
        document.querySelectorAll('.ai-assistant-option').forEach(option => {
          option.addEventListener('click', (e) => {
            const action = e.target.getAttribute('data-action');
            this.performAction(action);
          });
        });
        
        // Add event listener for the Matrix AI analysis button
        document.getElementById('ai-analyze-matrix-btn').addEventListener('click', () => {
          this.analyzeMatrix();
        });
      },
      
      // Toggle the AI Assistant panel
      togglePanel() {
        const panel = document.getElementById('ai-assistant-panel');
        panel.classList.toggle('active');
      },
      
      // Hide the AI Assistant panel
      hidePanel() {
        const panel = document.getElementById('ai-assistant-panel');
        panel.classList.remove('active');
      },
      
      // Perform the action based on the option selected
      performAction(action) {
        console.log('Performing action:', action);
        
        switch(action) {
          case 'analyze-selection':
            this.analyzeSelectedCards();
            break;
          case 'suggest-connections':
            this.suggestConnections();
            break;
          case 'generate-indexing':
            this.generateIndexingScheme();
            break;
          case 'kasten-search':
            this.searchKasten();
            break;
          case 'analyze-matrix':
            this.analyzeMatrix();
            break;
        }
        
        // Hide the panel after selecting an option
        this.hidePanel();
      },
      
      // Analyze selected zettel cards
      analyzeSelectedCards() {
        // Get any cards with the 'selected' class
        const selectedCards = document.querySelectorAll('.zettel-card.selected');
        
        // If no cards are selected, show a toast and enable selection mode
        if (selectedCards.length === 0) {
          showToast('Please select zettel cards to analyze (click while holding Ctrl/Cmd)', 5000);
          this.enableCardSelection();
          return;
        }
        
        // Collect selected cards data
        const selectedCardsData = Array.from(selectedCards).map(card => {
          const id = card.querySelector('.zettel-id').textContent;
          const title = card.querySelector('.zettel-title div:first-child').textContent;
          const content = card.querySelector('.zettel-content').textContent;
          const tags = Array.from(card.querySelectorAll('.tag')).map(tag => tag.textContent);
          
          return { id, title, content, tags };
        });
        
        // Display loading toast
        showToast('AI analyzing selected zettel cards...', 3000);
        
        // Simulate AI analysis with a timeout
        setTimeout(() => {
          this.showAnalysisResults(selectedCardsData);
        }, 2000);
      },
      
      // Enable card selection mode
      enableCardSelection() {
        // Add click handler to allow card selection
        const zettelCards = document.querySelectorAll('.zettel-card');
        
        // Add the selection handler
        zettelCards.forEach(card => {
          card.addEventListener('click', function(e) {
            // Skip if clicking on a bud or nest item
            if (e.target.closest('.bud-item') || e.target.closest('.nest-item')) {
              return;
            }
            
            // Add the Ctrl/Cmd key handling for multi-select
            if (e.ctrlKey || e.metaKey) {
              this.classList.toggle('selected');
              showToast(this.classList.contains('selected') ? 
                `Card ${this.querySelector('.zettel-id').textContent} selected` : 
                `Card ${this.querySelector('.zettel-id').textContent} deselected`, 1500);
            }
          });
        });
        
        // Add a button to perform analysis after selection
        const analyzeButton = document.createElement('button');
        analyzeButton.textContent = 'Analyze Selected Cards';
        analyzeButton.id = 'analyze-selected-btn';
        analyzeButton.className = 'action-button';
        analyzeButton.style.position = 'fixed';
        analyzeButton.style.bottom = '150px';
        analyzeButton.style.right = '20px';
        analyzeButton.style.zIndex = '1000';
        
        // Only add if it doesn't exist yet
        if (!document.getElementById('analyze-selected-btn')) {
          document.body.appendChild(analyzeButton);
          
          // Add click handler
          analyzeButton.addEventListener('click', () => {
            // Remove the button
            document.body.removeChild(analyzeButton);
            
            // Perform analysis
            this.analyzeSelectedCards();
          });
        }
      },
      
      // Show analysis results
      showAnalysisResults(selectedCards) {
        // Get the analysis result container
        const analysisContainer = document.getElementById('ai-analysis-result');
        const analysisContent = document.getElementById('ai-analysis-content');
        const analysisCardList = document.getElementById('ai-analysis-card-list');
        
        // Switch to knowledge view if needed
        if (!document.getElementById('knowledge-view').classList.contains('active')) {
          document.querySelector('.view-tab[data-view="knowledge-view"]').click();
        }
        
        // Clear previous content
        analysisContent.innerHTML = '';
        analysisCardList.innerHTML = '';
        
        // Generate analysis content based on the cards
        let analysisText = '';
        
        if (selectedCards.length === 1) {
          analysisText = `<p>Analysis of "${selectedCards[0].title}" (${selectedCards[0].id}):</p>
          <p>This zettel explores concepts related to ${selectedCards[0].tags.join(', ')}.</p>
          <p>Key themes identified: ${this.extractKeyThemes(selectedCards[0].content).join(', ')}.</p>
          <p>Potential connections identified to the following cards:</p>`;
        } else {
          analysisText = `<p>Analysis of ${selectedCards.length} selected zettel cards:</p>
          <p>These cards share thematic connections across the following domains: ${this.findCommonTags(selectedCards).join(', ')}.</p>
          <p>Identified conceptual links between the cards:</p>
          <ul>
            ${this.generateConceptualLinks(selectedCards).map(link => `<li>${link}</li>`).join('')}
          </ul>
          <p>Suggested additional connections:</p>`;
        }
        
        // Set the analysis content
        analysisContent.innerHTML = analysisText;
        
        // Add suggested related cards
        const relatedCards = this.findRelatedCards(selectedCards);
        relatedCards.forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'ai-card-reference';
          cardEl.setAttribute('data-zettel-id', card.id);
          cardEl.innerHTML = `
            <div class="ai-card-icon">ðŸ“„</div>
            <div class="ai-card-details">
              <div class="ai-card-title">${card.title}</div>
              <div class="ai-card-id">${card.id}</div>
            </div>
            <div class="ai-card-relevance">${card.relevance}% match</div>
          `;
          
          // Add click handler to highlight the related card
          cardEl.addEventListener('click', () => {
            this.highlightZettelCard(card.id);
          });
          
          analysisCardList.appendChild(cardEl);
        });
        
        // Show the analysis container
        analysisContainer.style.display = 'block';
        
        // Scroll to the analysis
        analysisContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
      },
      
      // Find common tags among selected cards
      findCommonTags(cards) {
        if (cards.length === 0) return [];
        
        // Start with all tags from the first card
        let commonTags = [...cards[0].tags];
        
        // Find intersection with tags from other cards
        for (let i = 1; i < cards.length; i++) {
          commonTags = commonTags.filter(tag => cards[i].tags.includes(tag));
        }
        
        // If no common tags, return unique tags across all cards
        if (commonTags.length === 0) {
          const allTags = cards.flatMap(card => card.tags);
          return [...new Set(allTags)].slice(0, 3); // Return up to 3 unique tags
        }
        
        return commonTags;
      },
      
      // Extract key themes from content
      extractKeyThemes(content) {
        const keywords = [
          'consciousness', 'reality', 'metaphysics', 'ontology', 'causality',
          'epistemology', 'ethics', 'framework', 'system', 'intelligence',
          'existence', 'knowledge', 'transformation', 'threshold', 'emergence'
        ];
        
        const contentLower = content.toLowerCase();
        const foundKeywords = keywords.filter(keyword => contentLower.includes(keyword));
        
        return foundKeywords.length ? foundKeywords : ['concept exploration', 'knowledge structure', 'theoretical framework'];
      },
      
      // Generate conceptual links between cards
      generateConceptualLinks(cards) {
        if (cards.length < 2) return [];
        
        const links = [];
        
        // Generate pairwise links between cards
        for (let i = 0; i < cards.length; i++) {
          for (let j = i + 1; j < cards.length; j++) {
            const card1 = cards[i];
            const card2 = cards[j];
            
            // Find common themes or tags
            const commonTags = card1.tags.filter(tag => card2.tags.includes(tag));
            
            if (commonTags.length > 0) {
              links.push(`<strong>${card1.title}</strong> and <strong>${card2.title}</strong> share thematic elements related to ${commonTags.join(', ')}`);
            } else {
              // Look for keyword overlap in content
              const themes1 = this.extractKeyThemes(card1.content);
              const themes2 = this.extractKeyThemes(card2.content);
              const commonThemes = themes1.filter(theme => themes2.includes(theme));
              
              if (commonThemes.length > 0) {
                links.push(`<strong>${card1.title}</strong> and <strong>${card2.title}</strong> both explore aspects of ${commonThemes.join(', ')}`);
              } else {
                links.push(`<strong>${card1.title}</strong> and <strong>${card2.title}</strong> may form a dialectical relationship worth exploring`);
              }
            }
            
            // Only generate up to 3 links for demo purposes
            if (links.length >= 3) break;
          }
          if (links.length >= 3) break;
        }
        
        return links;
      },
      
      // Find related cards to the selected ones
      findRelatedCards(selectedCards) {
        const relatedCards = [];
        const selectedIds = selectedCards.map(card => card.id);
        
        // Get all zettel cards from DOM
        const allZettelCards = Array.from(document.querySelectorAll('.zettel-card'));
        
        // Filter out the already selected cards
        const otherCards = allZettelCards.filter(card => {
          const cardId = card.querySelector('.zettel-id').textContent;
          return !selectedIds.includes(cardId);
        });
        
        // For each card not in the selection, calculate a relevance score
        otherCards.forEach(card => {
          const cardId = card.querySelector('.zettel-id').textContent;
          const cardTitle = card.querySelector('.zettel-title div:first-child').textContent;
          const cardTags = Array.from(card.querySelectorAll('.tag')).map(tag => tag.textContent);
          
          // Calculate relevance based on tag overlap (simplified)
          let tagOverlapScore = 0;
          const allSelectedTags = selectedCards.flatMap(sc => sc.tags);
          
          cardTags.forEach(tag => {
            if (allSelectedTags.includes(tag)) {
              tagOverlapScore += 25; // 25% per matching tag
            }
          });
          
          // Cap at 95% and ensure at least 30% for demonstration
          const relevance = Math.min(95, Math.max(30, tagOverlapScore));
          
          relatedCards.push({
            id: cardId,
            title: cardTitle,
            tags: cardTags,
            relevance: relevance
          });
        });
        
        // Sort by relevance and take the top 3
        return relatedCards
          .sort((a, b) => b.relevance - a.relevance)
          .slice(0, 3);
      },
      
      // Highlight a zettel card
      highlightZettelCard(zettelId) {
        // Remove previous highlights
        document.querySelectorAll('.zettel-card.highlighted').forEach(card => {
          card.classList.remove('highlighted');
        });
        
        // Find the card and highlight it
        const card = document.querySelector(`.zettel-card[data-zettel-id="${zettelId}"]`);
        if (card) {
          card.classList.add('highlighted');
          
          // Scroll to the card
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Remove highlight after a few seconds
          setTimeout(() => {
            card.classList.remove('highlighted');
          }, 5000);
        }
      },
      
      // Suggest connections between zettel cards
      suggestConnections() {
        showToast('Analyzing knowledge base to suggest new connections...', 3000);
        
        // Make sure we're in the matrix view
        if (!document.getElementById('matrix-view').classList.contains('active')) {
          document.querySelector('.view-tab[data-view="matrix-view"]').click();
        }
        
        // Simulate analysis with timeout
        setTimeout(() => {
          this.showMatrixConnectionSuggestions();
        }, 2000);
      },
      
      // Show connection suggestions in the matrix view
      showMatrixConnectionSuggestions() {
        const matrixBoard = document.getElementById('matrix-board');
        
        // Create a suggestions overlay
        const suggestionsOverlay = document.createElement('div');
        suggestionsOverlay.className = 'ai-analysis-result';
        suggestionsOverlay.style.position = 'absolute';
        suggestionsOverlay.style.zIndex = '100';
        suggestionsOverlay.style.top = '20px';
        suggestionsOverlay.style.left = '20px';
        suggestionsOverlay.style.width = '350px';
        suggestionsOverlay.style.maxWidth = '80vw';
        suggestionsOverlay.innerHTML = `
          <div class="ai-analysis-header">Suggested Connections</div>
          <div class="ai-analysis-content">
            <p>Based on thematic analysis of your knowledge base, I suggest adding these connections:</p>
            <ul style="margin-top: 10px; margin-bottom: 10px;">
              <li><strong>Consciousness & Reality</strong> âžœ <strong>Threshold Mappings</strong>: Explore how consciousness functions at threshold states between different ontological categories</li>
              <li><strong>CoAIxist Framework</strong> âžœ <strong>Aesthetic Rationality</strong>: Investigate how aesthetic experience shapes human-AI interaction paradigms</li>
              <li><strong>Threshold Mappings</strong> âžœ <strong>Metaphysics: Causality</strong>: Examine causality in transitional spaces between defined states of being</li>
            </ul>
            <p>Would you like me to add these connections to your matrix?</p>
          </div>
          <div style="display: flex; justify-content: space-between; margin-top: 15px;">
            <button class="action-button" id="add-suggested-connections">Add Connections</button>
            <button class="action-button" id="close-suggestions">Close</button>
          </div>
        `;
        
        // Add to the board
        matrixBoard.appendChild(suggestionsOverlay);
        
        // Add handler for add connections button
        document.getElementById('add-suggested-connections').addEventListener('click', () => {
          showToast('Adding suggested connections to matrix...', 3000);
          
          // Add the suggested connections to the knowledge base
          knowledgeBase.addConnection({
            source: "I.1-A2000", 
            target: "IV.3-E3000", 
            type: "explores", 
            label: "explores"
          });
          
          knowledgeBase.addConnection({
            source: "II.2-C3000", 
            target: "III.3-B2500", 
            type: "investigates", 
            label: "investigates"
          });
          
          // Update the visual connections
          updateConnections();
          
          // Remove the suggestions overlay
          matrixBoard.removeChild(suggestionsOverlay);
          
          showToast('Connections added successfully!', 2000);
        });
        
        // Add handler for close button
        document.getElementById('close-suggestions').addEventListener('click', () => {
          matrixBoard.removeChild(suggestionsOverlay);
        });
      },
      
      // Generate indexing scheme for knowledge base
      generateIndexingScheme() {
        showToast('Analyzing knowledge structure to suggest indexing scheme...', 3000);
        
        // Make sure we're in the knowledge view
        if (!document.getElementById('knowledge-view').classList.contains('active')) {
          document.querySelector('.view-tab[data-view="knowledge-view"]').click();
        }
        
        setTimeout(() => {
          const knowledgeViewer = document.getElementById('knowledge-viewer');
          
          // Create an indexing scheme summary
          const indexingBox = document.createElement('div');
          indexingBox.className = 'ai-analysis-result';
          indexingBox.innerHTML = `
            <div class="ai-analysis-header">Generated Indexing Scheme</div>
            <div class="ai-analysis-content">
              <p>Based on analyzing your knowledge base, I suggest this indexing structure:</p>
              
              <h3 style="color: var(--cyan-light); margin-top: 15px;">Primary Index Categories</h3>
              <ul>
                <li><strong>Ontological Frameworks (ONT)</strong>: Cards dealing with existence and reality</li>
                <li><strong>Epistemological Models (EPI)</strong>: Cards on knowledge acquisition and structure</li>
                <li><strong>Consciousness Studies (CSC)</strong>: Cards exploring consciousness phenomena</li>
                <li><strong>System Dynamics (SYS)</strong>: Cards about complex systems and emergence</li>
              </ul>
              
              <h3 style="color: var(--cyan-light); margin-top: 15px;">Suggested Tagging Structure</h3>
              <ul>
                <li><strong>Tier 1 Tags</strong>: Primary domain (ONT, EPI, CSC, SYS)</li>
                <li><strong>Tier 2 Tags</strong>: Sub-domains and methodologies</li>
                <li><strong>Tier 3 Tags</strong>: Specific concepts and applications</li>
              </ul>
            </div>
            <div style="display: flex; justify-content: flex-end; margin-top: 15px;">
              <button class="action-button" id="apply-indexing-scheme">Apply This Scheme</button>
            </div>
          `;
          
          // Add to the viewer
          knowledgeViewer.appendChild(indexingBox);
          
          // Scroll to show the indexing scheme
          indexingBox.scrollIntoView({ behavior: 'smooth', block: 'start' });
          
          // Add handler for apply button
          document.getElementById('apply-indexing-scheme').addEventListener('click', () => {
            showToast('Indexing scheme will be applied to your knowledge base...', 3000);
            
            // For the demo, just remove the indexing box after a delay
            setTimeout(() => {
              knowledgeViewer.removeChild(indexingBox);
            }, 2000);
          });
        }, 2000);
      },
      
      // AI-powered search of the Kasten system
      searchKasten() {
        // Create a search query input box
        const searchQueryBox = document.createElement('div');
        searchQueryBox.className = 'ai-analysis-result';
        searchQueryBox.innerHTML = `
          <div class="ai-analysis-header">AI-Powered Semantic Search</div>
          <div class="ai-analysis-content">
            <p>Enter your search query, and I'll find conceptually related zettel cards, even if they don't contain the exact keywords:</p>
            <input type="text" class="search-input" id="ai-search-query" placeholder="e.g., 'How does consciousness relate to threshold states?'" style="margin-top: 10px;">
          </div>
          <div style="display: flex; justify-content: flex-end; margin-top: 15px;">
            <button class="action-button" id="perform-ai-search">Search</button>
          </div>
        `;
        
        // Determine the target container based on active view
        const isMatrixView = document.getElementById('matrix-view').classList.contains('active');
        const targetContainer = isMatrixView 
          ? document.getElementById('matrix-board')
          : document.getElementById('knowledge-viewer');
        
        targetContainer.appendChild(searchQueryBox);
        
        // Style adjustments if in matrix view
        if (isMatrixView) {
          searchQueryBox.style.position = 'absolute';
          searchQueryBox.style.zIndex = '100';
          searchQueryBox.style.top = '20px';
          searchQueryBox.style.left = '20px';
          searchQueryBox.style.width = '350px';
          searchQueryBox.style.maxWidth = '80vw';
        }
        
        // Focus the input
        setTimeout(() => {
          document.getElementById('ai-search-query').focus();
        }, 100);
        
        // Add handler for search button
        document.getElementById('perform-ai-search').addEventListener('click', () => {
          const query = document.getElementById('ai-search-query').value.trim();
          
          if (query) {
            showToast('Performing semantic search...', 2000);
            
            // For the demo, simulate a search result
            setTimeout(() => {
              // Remove the search box
              targetContainer.removeChild(searchQueryBox);
              
              // Create search results box
              const resultsBox = document.createElement('div');
              resultsBox.className = 'ai-analysis-result';
              
              // Style adjustments if in matrix view
              if (isMatrixView) {
                resultsBox.style.position = 'absolute';
                resultsBox.style.zIndex = '100';
                resultsBox.style.top = '20px';
                resultsBox.style.left = '20px';
                resultsBox.style.width = '350px';
                resultsBox.style.maxWidth = '80vw';
              }
              
              resultsBox.innerHTML = `
                <div class="ai-analysis-header">Semantic Search Results</div>
                <div class="ai-analysis-content">
                  <p>Results for: <strong>${query}</strong></p>
                  <p>I found these conceptually related zettel cards:</p>
                </div>
                <div class="ai-analysis-card-list" id="search-results-list"></div>
                <div style="display: flex; justify-content: flex-end; margin-top: 15px;">
                  <button class="action-button" id="close-search-results">Close</button>
                </div>
              `;
              
              // Add to the target container
              targetContainer.appendChild(resultsBox);
              
              // Find semantically related cards
              // For the demo, we'll use simple keyword matching
              const resultsContainer = document.getElementById('search-results-list');
              const queryLower = query.toLowerCase();
              
              let foundAny = false;
              
              document.querySelectorAll('.zettel-card').forEach(card => {
                const title = card.querySelector('.zettel-title div:first-child').textContent;
                const content = card.querySelector('.zettel-content').textContent;
                const id = card.querySelector('.zettel-id').textContent;
                
                // Simple relevance check
                let relevance = 0;
                
                // Check for keywords in the query
                ['consciousness', 'threshold', 'reality', 'system', 'framework'].forEach(keyword => {
                  if (queryLower.includes(keyword) && 
                     (title.toLowerCase().includes(keyword) || content.toLowerCase().includes(keyword))) {
                    relevance += 30;
                  }
                });
                
                // Add some randomness for demo
                relevance += Math.floor(Math.random() * 20);
                
                // Only show cards with some relevance
                if (relevance > 30) {
                  foundAny = true;
                  
                  // Create result item
                  const resultItem = document.createElement('div');
                  resultItem.className = 'ai-card-reference';
                  resultItem.setAttribute('data-zettel-id', id);
                  resultItem.innerHTML = `
                    <div class="ai-card-icon">ðŸ“„</div>
                    <div class="ai-card-details">
                      <div class="ai-card-title">${title}</div>
                      <div class="ai-card-id">${id}</div>
                    </div>
                    <div class="ai-card-relevance">${Math.min(relevance, 98)}% match</div>
                  `;
                  
                  // Add click handler
                  resultItem.addEventListener('click', () => {
                    // If in knowledge view, highlight the card
                    if (!isMatrixView) {
                      this.highlightZettelCard(id);
                    } 
                    // If in matrix view, highlight the node
                    else {
                      // Find the corresponding node
                      const node = document.querySelector(`.node[data-id="${id}"]`);
                      
                      if (node) {
                        // Add a highlight effect
                        node.style.boxShadow = '0 0 15px var(--yellow), 0 0 30px var(--yellow)';
                        node.style.zIndex = '10';
                        
                        // Scroll the node into view
                        node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Remove highlight after delay
                        setTimeout(() => {
                          node.style.boxShadow = '';
                          node.style.zIndex = '';
                        }, 5000);
                      }
                    }
                  });
                  
                  resultsContainer.appendChild(resultItem);
                }
              });
              
              // If no results found
              if (!foundAny) {
                resultsContainer.innerHTML = `
                  <div style="padding: 15px; text-align: center; color: #aaa;">
                    No semantically related cards found. Try a different query or create a new card for this topic.
                  </div>
                `;
              }
              
              // Add close button handler
              document.getElementById('close-search-results').addEventListener('click', () => {
                targetContainer.removeChild(resultsBox);
              });
            }, 2000);
          } else {
            showToast('Please enter a search query', 2000);
          }
        });
      },
      
      // Analyze the cross-reference matrix
      analyzeMatrix() {
        showToast('Analyzing cross-reference matrix patterns...', 3000);
        
        // Make sure we're in the matrix view
        if (!document.getElementById('matrix-view').classList.contains('active')) {
          document.querySelector('.view-tab[data-view="matrix-view"]').click();
        }
        
        // Simulate analysis with timeout
        setTimeout(() => {
          // Create an analysis overlay on the matrix
          const matrixAnalysisOverlay = document.createElement('div');
          matrixAnalysisOverlay.className = 'ai-analysis-result';
          matrixAnalysisOverlay.style.position = 'absolute';
          matrixAnalysisOverlay.style.zIndex = '100';
          matrixAnalysisOverlay.style.top = '100px';
          matrixAnalysisOverlay.style.right = '20px';
          matrixAnalysisOverlay.style.width = '350px';
          matrixAnalysisOverlay.style.maxWidth = '80vw';
          matrixAnalysisOverlay.innerHTML = `
            <div class="ai-analysis-header">Matrix Pattern Analysis</div>
            <div class="ai-analysis-content">
              <p>Analysis of your knowledge matrix reveals:</p>
              
              <h3 style="color: var(--cyan-light); margin-top: 10px;">Connection Patterns</h3>
              <ul>
                <li><strong>Central Node</strong>: "Threshold Mappings" forms a hub with multiple connections</li>
                <li><strong>Isolated Nodes</strong>: "Aesthetic Rationality" has limited connections</li>
                <li><strong>Connection Types</strong>: 70% informational, 20% explorative, 10% causal</li>
              </ul>
              
              <h3 style="color: var(--cyan-light); margin-top: 10px;">Matrix Structure</h3>
              <ul>
                <li><strong>Network Topology</strong>: Partial mesh network with central hubs</li>
                <li><strong>Network Density</strong>: 0.42 (medium connectivity)</li>
                <li><strong>Cluster Coefficient</strong>: High around Kasten I nodes</li>
              </ul>
              
              <h3 style="color: var(--cyan-light); margin-top: 10px;">Optimization Suggestions</h3>
              <p>Consider these structural improvements:</p>
              <ol>
                <li>Add dialectical connections between opposing concepts</li>
                <li>Create more connections from "Aesthetic Rationality"</li>
                <li>Balance the connection types for better knowledge flow</li>
              </ol>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 15px;">
              <button class="action-button" id="optimize-matrix">Optimize Matrix</button>
              <button class="action-button" id="close-matrix-analysis">Close</button>
            </div>
          `;
          
          // Add to the matrix view
          document.getElementById('matrix-board').appendChild(matrixAnalysisOverlay);
          
          // Add handlers for buttons
          document.getElementById('optimize-matrix').addEventListener('click', () => {
            showToast('Applying matrix optimization suggestions...', 3000);
            
            // Add some optimized connections
            knowledgeBase.addConnection({
              source: "III.3-B2500", 
              target: "I.1-A2000", 
              type: "contextualizes", 
              label: "contextualizes"
            });
            
            // Update connections
            updateConnections();
            
            // Remove the analysis overlay
            document.getElementById('matrix-board').removeChild(matrixAnalysisOverlay);
            
            showToast('Matrix optimization complete!', 2000);
          });
          
          document.getElementById('close-matrix-analysis').addEventListener('click', () => {
            document.getElementById('matrix-board').removeChild(matrixAnalysisOverlay);
          });
        }, 2000);
      }
    };

    document.addEventListener('DOMContentLoaded', function() {
      // Initialize mermaid
      mermaid.initialize({
        startOnLoad: true,
        theme: 'dark',
        securityLevel: 'loose'
      });
      
      // Initialize the knowledge base and AI assistant
      knowledgeBase.init();
      aiAssistant.init(knowledgeBase);
      
      // Create the initial nodes and connections
      createInitialNodes();
      updateConnections();
      
      // Mobile quick menu handlers
      document.getElementById('mobile-add-node').addEventListener('click', function() {
        document.getElementById('add-node-btn').click();
      });
      
      document.getElementById('mobile-add-connection').addEventListener('click', function() {
        document.getElementById('add-connection-btn').click();
      });
      
      document.getElementById('mobile-layout').addEventListener('click', function() {
        document.getElementById('switch-mode-btn').click();
      });
      
      // Add sidebar toggle functionality
      const sidebarToggle = document.getElementById('sidebar-toggle');
      if (sidebarToggle) {
        const categoryList = document.getElementById('category-list');
        
        sidebarToggle.addEventListener('click', function() {
          categoryList.classList.toggle('open');
          
          if (categoryList.classList.contains('open')) {
            sidebarToggle.innerHTML = 'âœ• Close';
          } else {
            sidebarToggle.innerHTML = 'â˜° KaStEn';
          }
        });
      }
      
      // Matrix/Pin Board node dragging
      let activeNode = null;
      let initialX = 0;
      let initialY = 0;
      let xOffset = 0;
      let yOffset = 0;
      
      // Prepare the matrix board for interacting with nodes
      function setupNodeDragging() {
        const nodes = document.querySelectorAll('.node');
        
        nodes.forEach(node => {
          node.addEventListener('mousedown', dragStart);
          node.addEventListener('touchstart', dragStart, { passive: false });
        });
      }
      
      document.addEventListener('mouseup', dragEnd);
      document.addEventListener('touchend', dragEnd);
      
      document.addEventListener('mousemove', drag);
      document.addEventListener('touchmove', drag, { passive: false });
      
      function dragStart(e) {
        // Only allow dragging if not clicking on a control button or handle
        if (e.target.closest('.node-control-btn') || e.target.closest('.node-handle')) {
          return;
        }
        
        if (e.type === 'touchstart') {
          initialX = e.touches[0].clientX;
          initialY = e.touches[0].clientY;
        } else {
          initialX = e.clientX;
          initialY = e.clientY;
        }
        
        if (e.target === this || this.contains(e.target)) {
          activeNode = this;
          
          // Find position
          const rect = activeNode.getBoundingClientRect();
          xOffset = initialX - rect.left;
          yOffset = initialY - rect.top;
          
          this.style.cursor = 'grabbing';
          this.style.zIndex = '10'; // Bring to front while dragging
        }
        
        e.preventDefault();
      }
      
      function dragEnd(e) {
        if (activeNode) {
          activeNode.style.cursor = 'grab';
          activeNode.style.zIndex = '2'; // Reset z-index
          
          // Update node position in knowledge base
          const nodeId = activeNode.getAttribute('data-id');
          const node = knowledgeBase.getNode(nodeId);
          
          if (node) {
            // Get the current position
            const rect = activeNode.getBoundingClientRect();
            const boardRect = document.getElementById('matrix-board').getBoundingClientRect();
            
            // Update the position in the knowledge base
            node.position = {
              x: rect.left - boardRect.left,
              y: rect.top - boardRect.top
            };
          }
          
          activeNode = null;
        }
      }
      
      function drag(e) {
        if (activeNode) {
          e.preventDefault();
          
          const matrixBoard = document.getElementById('matrix-board');
          const boardRect = matrixBoard.getBoundingClientRect();
          
          let currentX, currentY;
          
          if (e.type === 'touchmove') {
            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
          } else {
            currentX = e.clientX;
            currentY = e.clientY;
          }
          
          // Calculate position relative to board
          const x = currentX - xOffset;
          const y = currentY - yOffset;
          
          // Constrain to board boundaries
          const nodeWidth = activeNode.offsetWidth;
          const nodeHeight = activeNode.offsetHeight;
          
          const maxX = boardRect.width - nodeWidth;
          const maxY = boardRect.height - nodeHeight;
          
          // Set the position
          activeNode.style.left = `${Math.max(0, Math.min(x - boardRect.left, maxX))}px`;
          activeNode.style.top = `${Math.max(0, Math.min(y - boardRect.top, maxY))}px`;
          
          // Update connections
          updateConnections();
        }
      }
      
      // Draw connections between nodes
      function updateConnections() {
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');
        const matrixBoard = document.getElementById('matrix-board');
        
        // Update canvas size
        canvas.width = matrixBoard.scrollWidth;
        canvas.height = matrixBoard.scrollHeight;
        
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Get all nodes
        const nodes = document.querySelectorAll('.node');
        
        // Remove existing connection labels
        document.querySelectorAll('.connection-label').forEach(label => {
          label.remove();
        });
        
        // Draw connections based on the knowledge base
        knowledgeBase.connections.forEach(connection => {
          // Find the source and target nodes
          const sourceNode = document.querySelector(`.node[data-id="${connection.source}"]`);
          const targetNode = document.querySelector(`.node[data-id="${connection.target}"]`);
          
          if (sourceNode && targetNode) {
            const sourceRect = sourceNode.getBoundingClientRect();
            const targetRect = targetNode.getBoundingClientRect();
            const boardRect = matrixBoard.getBoundingClientRect();
            
            // Calculate center points
            const sourceX = (sourceRect.left + sourceRect.right) / 2 - boardRect.left;
            const sourceY = (sourceRect.top + sourceRect.bottom) / 2 - boardRect.top;
            const targetX = (targetRect.left + targetRect.right) / 2 - boardRect.left;
            const targetY = (targetRect.top + targetRect.bottom) / 2 - boardRect.top;
            
            // Draw the connection line
            ctx.beginPath();
            ctx.moveTo(sourceX, sourceY);
            ctx.lineTo(targetX, targetY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Add a connection label
            const labelX = (sourceX + targetX) / 2;
            const labelY = (sourceY + targetY) / 2;
            
            const label = document.createElement('div');
            label.className = 'connection-label';
            label.textContent = connection.label || 'connects to';
            label.style.left = `${labelX}px`;
            label.style.top = `${labelY}px`;
            
            // Add the label to the board
            matrixBoard.appendChild(label);
          }
        });
      }
      
      // Create initial nodes from sample data
      function createInitialNodes() {
        const matrixBoard = document.getElementById('matrix-board');
        
        // Clear any existing nodes
        document.querySelectorAll('.node').forEach(node => {
          node.remove();
        });
        
        // Create nodes from the knowledge base
        knowledgeBase.nodes.forEach(nodeData => {
          // Create the node element
          const node = document.createElement('div');
          node.className = `node ${nodeData.kasten}`;
          node.setAttribute('data-id', nodeData.id);
          node.style.top = `${nodeData.position.y}px`;
          node.style.left = `${nodeData.position.x}px`;
          
          // Generate tag elements
          const tagElements = nodeData.tags.map(tag => {
            // Determine the tag tier
            let tagTier = 'tag-tier1';
            if (tag.match(/^[A-Z]{3}$/)) {
              // 3-letter uppercase tags are tier 1
              tagTier = 'tag-tier1';
            } else if (tag.match(/^[A-Z]{2}[a-z]$/)) {
              // 2 uppercase + 1 lowercase are tier 2
              tagTier = 'tag-tier2';
            } else {
              // Others are tier 3
              tagTier = 'tag-tier3';
            }
            
            return `<span class="node-tag ${tagTier}">${tag}</span>`;
          }).join('');
          
          // Set the node content
          node.innerHTML = `
            <div class="node-header">
              <div>${nodeData.title}</div>
              <div class="node-id">${nodeData.id}</div>
            </div>
            <div class="node-content">
              ${nodeData.content}
            </div>
            <div class="node-tags">
              ${tagElements}
            </div>
            <div class="node-controls">
              <button class="node-control-btn" title="Edit Node">âœï¸</button>
              <button class="node-control-btn" title="Delete Node">ðŸ—‘ï¸</button>
            </div>
            <div class="node-handle handle-top"></div>
            <div class="node-handle handle-right"></div>
            <div class="node-handle handle-bottom"></div>
            <div class="node-handle handle-left"></div>
          `;
          
          // Add the node to the board
          matrixBoard.appendChild(node);
          
          // Add event listeners for node control buttons
          node.querySelector('.node-control-btn[title="Edit Node"]').addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent triggering node dragging
            editNode(nodeData.id);
          });
          
          node.querySelector('.node-control-btn[title="Delete Node"]').addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent triggering node dragging
            deleteNode(nodeData.id);
          });
          
          // Add event listeners for connection handles
          node.querySelectorAll('.node-handle').forEach(handle => {
            handle.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent triggering node dragging
              handleConnectionClick(e, nodeData.id);
            });
          });
        });
        
        // Setup node dragging
        setupNodeDragging();
      }
      
      // Add Node button
      document.getElementById('add-node-btn').addEventListener('click', function() {
        // Show the node form
        document.getElementById('node-form-container').style.display = 'block';
        
        // Focus on the title field
        document.getElementById('node-title').focus();
      });
      
      // Save node form
      document.getElementById('save-node-btn').addEventListener('click', function() {
        // Get the form data
        const title = document.getElementById('node-title').value.trim();
        const id = document.getElementById('node-id').value.trim();
        const content = document.getElementById('node-content').value.trim();
        const kastenType = document.getElementById('node-kasten').value;
        const tagsInput = document.getElementById('node-tags').value.trim();
        
        // Validate
        if (!title || !id || !content) {
          showToast('Please fill in all required fields', 3000);
          return;
        }
        
        // Parse tags
        const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()) : [];
        
        // Create a new node
        const newNode = {
          id,
          title,
          content,
          kasten: kastenType,
          tags,
          position: { x: 50, y: 50 } // Initial position
        };
        
        // Add to knowledge base
        knowledgeBase.addNode(newNode);
        
        // Create the visual node
        createInitialNodes(); // Rebuild all nodes for simplicity
        updateConnections();
        
        // Reset and hide the form
        document.getElementById('node-title').value = '';
        document.getElementById('node-id').value = '';
        document.getElementById('node-content').value = '';
        document.getElementById('node-tags').value = '';
        document.getElementById('node-form-container').style.display = 'none';
        
        showToast('Node added successfully', 3000);
      });
      
      // Cancel node form
      document.getElementById('cancel-node-btn').addEventListener('click', function() {
        // Reset and hide the form
        document.getElementById('node-title').value = '';
        document.getElementById('node-id').value = '';
        document.getElementById('node-content').value = '';
        document.getElementById('node-tags').value = '';
        document.getElementById('node-form-container').style.display = 'none';
      });
      
      // Delete node
      function deleteNode(nodeId) {
        // Remove from knowledge base
        knowledgeBase.removeNode(nodeId);
        
        // Remove from DOM
        const node = document.querySelector(`.node[data-id="${nodeId}"]`);
        if (node) {
          node.remove();
        }
        
        // Update connections
        updateConnections();
        
        showToast(`Node ${nodeId} deleted`, 3000);
      }
      
      // Edit node
      function editNode(nodeId) {
        // Find the node in the knowledge base
        const node = knowledgeBase.getNode(nodeId);
        
        if (node) {
          // Fill the form with node data
          document.getElementById('node-title').value = node.title;
          document.getElementById('node-id').value = node.id;
          document.getElementById('node-content').value = node.content;
          document.getElementById('node-kasten').value = node.kasten;
          document.getElementById('node-tags').value = node.tags.join(', ');
          
          // Show the form
          document.getElementById('node-form-container').style.display = 'block';
          
          // Remove the old node
          knowledgeBase.removeNode(nodeId);
          
          // Focus on the title field
          document.getElementById('node-title').focus();
        }
      }
      
      // Connection variables
      let connectionStartNodeId = null;
      let connectionStartHandle = null;
      let connectionMode = false;
      
      // Add connection mode toggle
      document.getElementById('add-connection-btn').addEventListener('click', function() {
        connectionMode = !connectionMode;
        
        if (connectionMode) {
          // Enable connection mode
          this.classList.add('active');
          showToast('Connection mode enabled - click on a handle to start', 5000);
        } else {
          // Disable connection mode
          this.classList.remove('active');
          resetConnectionState();
          showToast('Connection mode disabled', 3000);
        }
      });
      
      // Handle connection clicks
      function handleConnectionClick(e, nodeId) {
        if (!connectionMode) return;
        
        const handle = e.target;
        
        // If no start node, this is the start
        if (!connectionStartNodeId) {
          // Start connection
          connectionStartNodeId = nodeId;
          connectionStartHandle = handle;
          handle.classList.add('active');
          showToast('Now click on another node handle to connect', 5000);
        } else {
          // Complete connection
          if (nodeId !== connectionStartNodeId) {
            // Show connection type picker
            showConnectionTypePicker(e.clientX, e.clientY, connectionStartNodeId, nodeId);
          } else {
            showToast('Cannot connect a node to itself', 3000);
            resetConnectionState();
          }
        }
      }
      
      // Reset connection state
      function resetConnectionState() {
        if (connectionStartHandle) {
          connectionStartHandle.classList.remove('active');
        }
        connectionStartNodeId = null;
        connectionStartHandle = null;
      }
      
      // Show connection type picker
      function showConnectionTypePicker(x, y, sourceId, targetId) {
        const picker = document.getElementById('connection-type-picker');
        
        // Position the picker
        picker.style.left = `${x}px`;
        picker.style.top = `${y}px`;
        
        // Show the picker
        picker.style.display = 'block';
        
        // Add event listeners to the connection type options
        document.querySelectorAll('.connection-type-option').forEach(option => {
          // Remove any existing listeners
          const clone = option.cloneNode(true);
          option.parentNode.replaceChild(clone, option);
          
          // Add new listener
          clone.addEventListener('click', function() {
            const type = this.getAttribute('data-type');
            createConnection(sourceId, targetId, type);
            picker.style.display = 'none';
          });
        });
      }
      
      // Create connection
      function createConnection(sourceId, targetId, type) {
        // Add connection to knowledge base
        knowledgeBase.addConnection({
          source: sourceId,
          target: targetId,
          type: type,
          label: type
        });
        
        // Update connections
        updateConnections();
        
        // Reset connection state
        resetConnectionState();
        
        showToast(`Connection created: ${type}`, 3000);
      }
      
      // Generate diagram button
      document.getElementById('generate-diagram-btn').addEventListener('click', function() {
        // Build Mermaid diagram from nodes and connections
        let mermaidCode = `graph TD
    classDef kastenI fill:#9C27B0,stroke:#9C27B0,color:white
    classDef kastenII fill:#2196F3,stroke:#2196F3,color:white
    classDef kastenIII fill:#00BFA5,stroke:#00BFA5,color:white
    classDef kastenIV fill:#FF7043,stroke:#FF7043,color:white\n\n`;
        
        // Add nodes
        knowledgeBase.nodes.forEach(node => {
          const nodeId = node.id.replace(/[.\-]/g, '_'); // Mermaid doesn't like periods and hyphens in IDs
          mermaidCode += `    ${nodeId}[${node.id}<br>${node.title}]\n`;
        });
        
        // Add connections
        knowledgeBase.connections.forEach(conn => {
          const sourceId = conn.source.replace(/[.\-]/g, '_');
          const targetId = conn.target.replace(/[.\-]/g, '_');
          mermaidCode += `    ${sourceId} -->|${conn.label}| ${targetId}\n`;
        });
        
        // Add style classes
        knowledgeBase.nodes.forEach(node => {
          const nodeId = node.id.replace(/[.\-]/g, '_');
          let kastenClass = '';
          
          if (node.kasten === 'kasten-i') kastenClass = 'kastenI';
          else if (node.kasten === 'kasten-ii') kastenClass = 'kastenII';
          else if (node.kasten === 'kasten-iii') kastenClass = 'kastenIII';
          else if (node.kasten === 'kasten-iv') kastenClass = 'kastenIV';
          
          if (kastenClass) {
            mermaidCode += `    ${nodeId}:::${kastenClass}\n`;
          }
        });
        
        // Update the mermaid code
        document.getElementById('mermaid-diagram').textContent = mermaidCode;
        
        // Switch to Mermaid view
        document.querySelector('.tab[data-view="mermaid"]').click();
        
        // Render the diagram
        try {
          mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        } catch (e) {
          console.error('Mermaid render error:', e);
          showToast('Error rendering diagram. Check console for details.', 5000);
        }
        
        showToast('Diagram generated from matrix', 3000);
      });
      
      // Clear all button
      document.getElementById('clear-all-btn').addEventListener('click', function() {
        if (confirm('Are you sure you want to clear all nodes and connections?')) {
          // Clear the knowledge base
          knowledgeBase.nodes = [];
          knowledgeBase.connections = [];
          
          // Clear the matrix board
          const matrixBoard = document.getElementById('matrix-board');
          matrixBoard.querySelectorAll('.node').forEach(node => node.remove());
          matrixBoard.querySelectorAll('.connection-label').forEach(label => label.remove());
          
          // Clear the canvas
          const canvas = document.getElementById('matrix-canvas');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          showToast('Matrix cleared', 3000);
        }
      });
      
      // Mode switching
      document.getElementById('switch-mode-btn').addEventListener('click', function() {
        const modes = [
          { name: 'Default', handler: applyDefaultLayout },
          { name: 'Force-Directed', handler: applyForceDirectedLayout },
          { name: 'Hierarchical', handler: applyHierarchicalLayout },
          { name: 'Circular', handler: applyCircularLayout }
        ];
        
        // Get current mode
        const currentModeIndex = parseInt(this.getAttribute('data-mode-index') || '0');
        
        // Calculate next mode
        const nextModeIndex = (currentModeIndex + 1) % modes.length;
        const nextMode = modes[nextModeIndex];
        
        // Update button
        this.setAttribute('data-mode-index', nextModeIndex.toString());
        this.textContent = `Mode: ${nextMode.name}`;
        
        // Apply the layout
        nextMode.handler();
        
        showToast(`Switched to ${nextMode.name} layout`, 3000);
      });
      
      // Layout functions
      function applyDefaultLayout() {
        // Position nodes in a grid
        const nodes = document.querySelectorAll('.node');
        const gridSize = Math.ceil(Math.sqrt(nodes.length));
        const spacing = 250;
        
        nodes.forEach((node, index) => {
          const row = Math.floor(index / gridSize);
          const col = index % gridSize;
          
          node.style.transition = 'top 0.5s ease, left 0.5s ease';
          node.style.top = `${row * spacing + 50}px`;
          node.style.left = `${col * spacing + 50}px`;
          
          // Update position in knowledge base
          const nodeId = node.getAttribute('data-id');
          const nodeData = knowledgeBase.getNode(nodeId);
          if (nodeData) {
            nodeData.position = { x: col * spacing + 50, y: row * spacing + 50 };
          }
        });
        
        // Update connections after transition
        setTimeout(updateConnections, 600);
      }
      
      function applyForceDirectedLayout() {
        // Simulate a simple force-directed layout
        const nodes = document.querySelectorAll('.node');
        const centerX = 300;
        const centerY = 200;
        const radius = 200;
        
        nodes.forEach((node, index) => {
          const angle = (index / nodes.length) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          node.style.transition = 'top 0.5s ease, left 0.5s ease';
          node.style.top = `${y}px`;
          node.style.left = `${x}px`;
          
          // Update position in knowledge base
          const nodeId = node.getAttribute('data-id');
          const nodeData = knowledgeBase.getNode(nodeId);
          if (nodeData) {
            nodeData.position = { x, y };
          }
        });
        
        // Update connections after transition
        setTimeout(updateConnections, 600);
      }
      
      function applyHierarchicalLayout() {
        // Arrange nodes in a tree-like hierarchy
        const nodes = document.querySelectorAll('.node');
        const levels = [1, 2, nodes.length - 3]; // Simplified: root, middle level, leaf nodes
        let currentNodeIndex = 0;
        
        let yPosition = 50;
        const matrixBoard = document.getElementById('matrix-board');
        const boardWidth = matrixBoard.clientWidth || 800;
        
        // Process each level
        for (let level = 0; level < levels.length; level++) {
          const nodesInLevel = Math.min(levels[level], nodes.length - currentNodeIndex);
          const levelWidth = boardWidth / (nodesInLevel + 1);
          
          for (let i = 0; i < nodesInLevel && currentNodeIndex < nodes.length; i++) {
            const node = nodes[currentNodeIndex];
            const x = levelWidth * (i + 1);
            
            node.style.transition = 'top 0.5s ease, left 0.5s ease';
            node.style.top = `${yPosition}px`;
            node.style.left = `${x}px`;
            
            // Update position in knowledge base
            const nodeId = node.getAttribute('data-id');
            const nodeData = knowledgeBase.getNode(nodeId);
            if (nodeData) {
              nodeData.position = { x, y: yPosition };
            }
            
            currentNodeIndex++;
          }
          
          yPosition += 200; // Move down for next level
        }
        
        // Update connections after transition
        setTimeout(updateConnections, 600);
      }
      
      function applyCircularLayout() {
        // Arrange nodes in a circle
        const nodes = document.querySelectorAll('.node');
        const centerX = 400;
        const centerY = 300;
        const radius = 250;
        
        nodes.forEach((node, index) => {
          const angle = (index / nodes.length) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          node.style.transition = 'top 0.5s ease, left 0.5s ease';
          node.style.top = `${y}px`;
          node.style.left = `${x}px`;
          
          // Update position in knowledge base
          const nodeId = node.getAttribute('data-id');
          const nodeData = knowledgeBase.getNode(nodeId);
          if (nodeData) {
            nodeData.position = { x, y };
          }
        });
        
        // Update connections after transition
        setTimeout(updateConnections, 600);
      }
      
      // Tab switching between pin board and mermaid diagram
      document.querySelectorAll('.tabs-container .tab').forEach(tab => {
        tab.addEventListener('click', function() {
          // Get the tab container
          const tabsContainer = this.closest('.tabs-container');
          
          // Get the view to activate
          const view = this.getAttribute('data-view');
          
          // Remove active class from all tabs in this container
          tabsContainer.querySelectorAll('.tab').forEach(t => {
            t.classList.remove('active');
          });
          
          // Add active class to the clicked tab
          this.classList.add('active');
          
          // Handle view switching
          if (view === 'pin-board' || view === 'mermaid') {
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(content => {
              content.classList.remove('active');
            });
            
            // Show the selected tab content
            document.getElementById(`${view}-view`).classList.add('active');
            
            // If mermaid view, re-render the diagram
            if (view === 'mermaid') {
              try {
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
              } catch (e) {
                console.error('Mermaid render error:', e);
              }
            }
          }
        });
      });
      
      // View tab navigation between knowledge and matrix views
      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.addEventListener('click', function() {
          const targetView = this.getAttribute('data-view');
          
          // Update active tab
          document.querySelectorAll('.view-tab').forEach(t => {
            t.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update active view
          document.querySelectorAll('.view-container').forEach(container => {
            container.classList.remove('active');
          });
          
          document.getElementById(targetView).classList.add('active');
          
          showToast(`Switched to ${this.title}`, 2000);
          
          // If switching to matrix view, make sure connections are properly drawn
          if (targetView === 'matrix-view') {
            updateConnections();
          }
        });
      });
      
      // Toggle dark mode
      document.getElementById('toggle-dark-mode').addEventListener('click', function() {
        document.documentElement.classList.toggle('dark');
        
        // Update mermaid theme
        if (document.documentElement.classList.contains('dark')) {
          mermaid.initialize({ theme: 'dark' });
        } else {
          mermaid.initialize({ theme: 'default' });
        }
        
        // Re-render mermaid diagrams
        try {
          mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        } catch (e) {
          console.error('Mermaid re-render error:', e);
        }
        
        showToast('Theme toggled', 2000);
      });
      
      // Initialize dark mode based on system preference
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.classList.add('dark');
        mermaid.initialize({ theme: 'dark' });
      }
      
      // Listen for dark mode changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (e.matches) {
          document.documentElement.classList.add('dark');
          mermaid.initialize({ theme: 'dark' });
        } else {
          document.documentElement.classList.remove('dark');
          mermaid.initialize({ theme: 'default' });
        }
        
        // Re-render mermaid diagrams
        try {
          mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        } catch (e) {
          console.error('Mermaid re-render error:', e);
        }
      });
      
      // Category toggles in sidebar
      document.querySelectorAll('.category-group-header').forEach(toggle => {
        toggle.addEventListener('click', function() {
          const items = this.nextElementSibling;
          const icon = this.querySelector('.category-group-toggle');
          
          // Toggle visibility
          if (items.style.display === 'none') {
            items.style.display = 'block';
            icon.textContent = 'â–¼';
          } else {
            items.style.display = 'none';
            icon.textContent = 'â–º';
          }
        });
      });
      
      // Keep canvas size updated when window is resized
      window.addEventListener('resize', function() {
        updateConnections();
      });
    });
    
    // Show toast message
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('active');
      
      setTimeout(() => {
        toast.classList.remove('active');
      }, duration);
    }
    
    // Make toast function globally available
    window.showToast = showToast;
  </script>
</body>
</html>