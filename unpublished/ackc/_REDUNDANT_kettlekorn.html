<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>~*~AnTiChRiSt KeTtLeKoRn~*~ Windows XP Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Tahoma&family=Comic+Sans+MS&display=swap" rel="stylesheet">
  <style>
    /* WINDOWS XP COLORS */
    :root {
      --winxp-blue: #0A246A;
      --winxp-blue-light: #3B6EDA;
      --winxp-green: #3DB54A;
      --winxp-title-active: linear-gradient(to right, #0A246A, #A6CAF0);
      --winxp-title-inactive: linear-gradient(to right, #808080, #D4D0C8);
      --winxp-button: #D4D0C8;
      --winxp-button-highlight: #ECE9D8;
      --winxp-desktop: #235FCC;
      
      /* USER REQUESTED COLORS */
      --cyan: #72FADE;    /* Light cyan */
      --yellow: #fffb01;  /* Bright yellow */
      --magenta: #f312af; /* Bright magenta */
      
      /* CUSTOM COLORS */
      --xp-title-gradient: linear-gradient(to right, var(--magenta), var(--cyan));
      --xp-button-gradient: linear-gradient(to bottom, #ffffff, var(--cyan));
      --xp-button-active: linear-gradient(to bottom, var(--magenta), #aa0088);
    }
    
    /* Base styles */
    body {
      background-color: var(--winxp-desktop);
      color: #000000;
      font-family: 'Tahoma', 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      padding-bottom: 50px;
    }
    
    /* Windows XP styles */
    .xp-window {
      background-color: #ECE9D8;
      border: 1px solid #000;
      border-radius: 8px;
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      max-width: 1050px;
      margin: 20px auto;
      position: relative;
    }
    
    .xp-titlebar {
      background: var(--xp-title-gradient);
      color: white;
      padding: 4px 0;
      display: flex;
      align-items: center;
      height: 32px;
    }
    
    .xp-titlebar-text {
      flex-grow: 1;
      font-weight: bold;
      margin-left: 8px;
      font-size: 14px;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
    }
    
    .xp-window-controls {
      display: flex;
      align-items: center;
      height: 24px;
      margin-right: 4px;
    }
    
    .xp-window-button {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 2px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .xp-window-button:hover {
      border: 1px solid rgba(255, 255, 255, 0.5);
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .xp-close {
      background-color: rgba(232, 17, 35, 0.8);
    }
    
    .xp-app-icon {
      width: 16px;
      height: 16px;
      margin-left: 4px;
      margin-right: 4px;
    }
    
    .xp-window-content {
      padding: 12px;
      max-height: 80vh;
      overflow-y: auto;
      background-color: #FFF;
    }
    
    .xp-taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 36px;
      background: linear-gradient(to bottom, #2583d0, #1060b6);
      display: flex;
      align-items: center;
      padding: 0 10px;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    
    .xp-start-button {
      background: linear-gradient(to bottom, #3c8f2a, #1d5b14);
      border-radius: 3px;
      padding: 2px 8px;
      color: white;
      font-weight: bold;
      display: flex;
      align-items: center;
      height: 28px;
      margin-right: 10px;
      cursor: pointer;
      border: 1px solid #17400e;
    }
    
    .xp-start-button:hover {
      background: linear-gradient(to bottom, #4ca638, #2a7a1e);
    }
    
    .xp-taskbar-items {
      flex-grow: 1;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .xp-taskbar-item {
      background: linear-gradient(to bottom, #5998e5, #3367c1);
      border-radius: 3px;
      padding: 3px 10px;
      color: white;
      font-size: 12px;
      height: 28px;
      min-width: 150px;
      display: flex;
      align-items: center;
      border: 1px solid #1c51a4;
    }
    
    .xp-taskbar-item-active {
      background: linear-gradient(to bottom, #3367c1, #0045aa);
    }
    
    .xp-system-tray {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
      padding: 0 5px;
    }
    
    .xp-system-tray-icon {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    .xp-clock {
      background-color: rgba(255, 255, 255, 0.4);
      padding: 2px 6px;
      border-radius: 2px;
      font-size: 12px;
      color: white;
    }
    
    /* Customize default button styles to be Windows XP-like */
    .xp-button {
      background: var(--xp-button-gradient);
      border: 1px solid #919191;
      border-radius: 3px;
      color: #000;
      padding: 6px 12px;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
      cursor: pointer;
      position: relative;
      margin-top: 10px;
    }
    
    .xp-button:hover {
      background: linear-gradient(to bottom, #ffffff, #ade1f9);
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.15);
    }
    
    .xp-button:active {
      background: var(--xp-button-active);
      color: white;
    }
    
    /* MySpace specific styling */
    .myspace-container {
      padding: 0;
      position: relative;
      overflow: hidden;
    }
    
    .myspace-header {
      padding: 20px;
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      border: 3px dashed var(--yellow);
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      position: relative;
    }
    
    .myspace-profile-pic {
      width: 150px;
      height: 150px;
      border: 5px solid var(--magenta);
      border-radius: 10px;
      margin: 0 auto 10px;
      overflow: hidden;
      position: relative;
    }
    
    .myspace-profile-name {
      font-size: 36px;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
      text-shadow: 2px 2px 0 var(--magenta), 4px 4px 0 #4b0049;
      margin-bottom: 5px;
      position: relative;
      z-index: 1;
      color: white;
    }
    
    .myspace-status {
      font-size: 16px;
      margin-bottom: 10px;
      font-style: italic;
      background-color: rgba(0,0,0,0.5);
      display: inline-block;
      padding: 5px 15px;
      border-radius: 20px;
      position: relative;
      z-index: 1;
      color: white;
    }
    
    .myspace-last-login {
      font-size: 12px;
      color: #e0e0ff;
      position: relative;
      z-index: 1;
    }
    
    .myspace-section {
      background-color: #fffff7;
      border: 2px solid var(--cyan);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      position: relative;
    }
    
    .myspace-section-title {
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      color: white;
      padding: 5px 15px;
      font-size: 14px;
      margin: -25px auto 15px;
      width: fit-content;
      border: 2px solid white;
      border-radius: 20px;
      box-shadow: 0 0 10px var(--magenta);
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    }
    
    .top8-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-gap: 10px;
    }
    
    .top8-item {
      background-color: #f7faff;
      border: 2px solid var(--magenta);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }
    
    .top8-item:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px var(--magenta);
      z-index: 10;
    }
    
    .top8-pic {
      width: 80px;
      height: 80px;
      margin: 0 auto 5px;
      border: 3px solid var(--cyan);
      border-radius: 5px;
      overflow: hidden;
    }
    
    .top8-name {
      font-size: 12px;
      font-weight: bold;
      color: #333;
    }
    
    .marquee-container {
      overflow: hidden;
      white-space: nowrap;
      background-color: #002b55;
      border: 1px solid var(--magenta);
      padding: 8px 0;
      margin: 10px 0;
    }
    
    .marquee-text {
      display: inline-block;
      color: var(--cyan);
      font-weight: bold;
      text-shadow: 1px 1px 2px var(--magenta);
      animation: marquee 30s linear infinite;
    }
    
    @keyframes marquee {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-100%); }
    }
    
    .blinking {
      animation: blink 1s step-end infinite;
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      49% { opacity: 1; }
      50% { opacity: 0; }
      99% { opacity: 0; }
      100% { opacity: 1; }
    }
    
    .zettel-container {
      max-height: 300px;
      overflow-y: auto;
      padding-right: 10px;
      scrollbar-width: thin;
      scrollbar-color: var(--magenta) #e5f5ff;
      border: 1px solid #ccc;
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.2);
      padding: 5px;
    }
    
    .zettel-container::-webkit-scrollbar {
      width: 16px;
    }
    
    .zettel-container::-webkit-scrollbar-track {
      background: #e5f5ff;
      border: 1px solid #ccc;
    }
    
    .zettel-container::-webkit-scrollbar-thumb {
      background-color: var(--cyan);
      border-radius: 0;
      border: 1px solid #919191;
    }
    
    .zettel-card {
      background-color: #fbfbfb;
      border: 1px solid #cccccc;
      border-radius: 3px;
      padding: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }
    
    .zettel-card:hover {
      background-color: #e8f4ff;
      border-color: var(--cyan);
      transform: translateX(5px);
    }
    
    .zettel-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--magenta), var(--cyan), var(--yellow));
      z-index: 5;
    }
    
    .zettel-title {
      font-weight: bold;
      color: #333;
      margin-bottom: 3px;
      font-size: 14px;
    }
    
    .zettel-id {
      font-size: 11px;
      color: #777;
      font-family: 'Courier New', monospace;
    }
    
    .child-card {
      margin-left: 15px;
      border-left: 2px dotted var(--cyan);
      padding-left: 8px;
    }
    
    .music-player {
      background: linear-gradient(to right, #ececec, #f5f5f5);
      border: 2px solid var(--cyan);
      border-radius: 6px;
      padding: 10px;
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    .music-player-buttons {
      display: flex;
      gap: 5px;
    }
    
    .music-player-button {
      width: 30px;
      height: 30px;
      background: var(--xp-button-gradient);
      border: 1px solid #919191;
      border-radius: 3px;
      color: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
    }
    
    .music-player-button:hover {
      background: linear-gradient(to bottom, #ffffff, #e3f2fd);
    }
    
    .music-player-button:active {
      background: linear-gradient(to bottom, #e0e0e0, #d0d0d0);
    }
    
    .music-player-info {
      margin-left: 10px;
      flex-grow: 1;
    }
    
    .music-player-title {
      font-size: 14px;
      color: #222;
      margin-bottom: 2px;
    }
    
    .music-player-artist {
      font-size: 12px;
      color: #555;
    }
    
    .music-player-progress {
      height: 8px;
      background-color: #ddd;
      border-radius: 4px;
      margin-top: 5px;
      position: relative;
      border: 1px solid #aaa;
    }
    
    .music-player-progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 35%;
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      border-radius: 3px;
    }
    
    .comments-section {
      border-top: 3px dotted var(--cyan);
      padding-top: 15px;
      margin-top: 20px;
    }
    
    .comment {
      display: flex;
      margin-bottom: 15px;
      background-color: #f7faff;
      border-radius: 6px;
      padding: 10px;
      border: 1px solid #d0d0d0;
    }
    
    .comment-avatar {
      width: 50px;
      height: 50px;
      border: 2px solid var(--cyan);
      border-radius: 5px;
      margin-right: 10px;
      flex-shrink: 0;
    }
    
    .comment-content {
      flex-grow: 1;
    }
    
    .comment-name {
      font-weight: bold;
      color: #0066cc;
      margin-bottom: 3px;
    }
    
    .comment-text {
      font-size: 13px;
      color: #333;
    }
    
    .comment-date {
      font-size: 11px;
      color: #777;
      margin-top: 5px;
      text-align: right;
    }
    
    .dialog-box {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding-bottom: 40px;
    }
    
    .dialog-content {
      background-color: #ECE9D8;
      border: 1px solid #000;
      border-radius: 8px;
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.5);
      width: 80%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    
    .dialog-titlebar {
      background: var(--xp-title-gradient);
      color: white;
      display: flex;
      align-items: center;
      height: 28px;
    }
    
    .dialog-titlebar-text {
      flex-grow: 1;
      font-weight: bold;
      margin-left: 8px;
      font-size: 14px;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
    }
    
    .dialog-close {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 4px;
      font-size: 16px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      background-color: rgba(232, 17, 35, 0.8);
    }
    
    .dialog-close:hover {
      background-color: rgba(232, 17, 35, 1);
    }
    
    .dialog-inner-content {
      padding: 15px;
      background-color: #fff;
    }
    
    .dialog-title {
      text-align: center;
      margin-bottom: 15px;
      color: var(--magenta);
      font-size: 16px;
      font-weight: bold;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    }
    
    .dialog-id {
      font-family: 'Courier New', monospace;
      color: #555;
      text-align: center;
      font-size: 12px;
      margin-bottom: 10px;
      background-color: #f0f0f0;
      padding: 3px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }
    
    .dialog-content-text {
      background-color: #f7f7f7;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 10px;
      color: #333;
      min-height: 100px;
      margin-bottom: 15px;
      font-family: 'Tahoma', sans-serif;
    }
    
    .dialog-hashtags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .dialog-hashtag {
      background-color: var(--cyan);
      color: #333;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 12px;
      box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .dialog-links {
      border-top: 1px dashed var(--cyan);
      padding-top: 10px;
    }
    
    .dialog-link {
      display: block;
      color: #0066cc;
      margin-bottom: 5px;
      font-size: 13px;
      cursor: pointer;
    }
    
    .dialog-link:hover {
      color: var(--magenta);
      text-decoration: underline;
    }
    
    /* Form elements styled like Windows XP */
    .xp-input {
      border: 1px solid #7F9DB9;
      padding: 3px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
      width: 100%;
      margin-bottom: 8px;
    }
    
    .xp-input:focus {
      border-color: #3B79C4;
      outline: none;
    }
    
    .xp-textarea {
      border: 1px solid #7F9DB9;
      padding: 3px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
      resize: none;
      height: 150px;
      width: 100%;
      margin-bottom: 8px;
    }
    
    .xp-textarea:focus {
      border-color: #3B79C4;
      outline: none;
    }
    
    .xp-select {
      border: 1px solid #7F9DB9;
      padding: 2px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
      height: 24px;
      width: 100%;
      margin-bottom: 8px;
    }
    
    .xp-select:focus {
      border-color: #3B79C4;
      outline: none;
    }
    
    .xp-label {
      display: block;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }
    
    /* New hashtag manager styles */
    .hashtag-manager {
      background-color: #f7faff;
      border: 2px solid var(--cyan);
      border-radius: 5px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .hashtag-input-container {
      display: flex;
      margin-bottom: 10px;
    }
    
    .hashtag-input {
      flex-grow: 1;
      border: 1px solid #7F9DB9;
      border-radius: 0;
      padding: 3px 5px;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
    }
    
    .hashtag-add-btn {
      background: var(--xp-button-gradient);
      border: 1px solid #7F9DB9;
      color: #000;
      padding: 0 10px;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
      cursor: pointer;
    }
    
    .hashtag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    
    .hashtag-item {
      background-color: var(--cyan);
      color: #333;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 12px;
      display: flex;
      align-items: center;
      box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .hashtag-delete {
      background-color: var(--magenta);
      color: white;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      margin-left: 5px;
      cursor: pointer;
    }
    
    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .xp-window {
        margin: 10px;
      }
      
      .myspace-profile-name {
        font-size: 28px;
      }
      
      .top8-container {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .top8-pic {
        width: 60px;
        height: 60px;
      }
      
      .dialog-content {
        width: 95%;
      }
      
      .xp-taskbar {
        height: 40px;
      }
    }
    
    @media (max-width: 480px) {
      .myspace-header {
        padding: 10px;
      }
      
      .myspace-profile-pic {
        width: 100px;
        height: 100px;
      }
      
      .myspace-profile-name {
        font-size: 24px;
      }
      
      .myspace-section-title {
        font-size: 12px;
      }
      
      .top8-container {
        grid-template-columns: repeat(2, 1fr);
        grid-gap: 5px;
      }
      
      .top8-pic {
        width: 50px;
        height: 50px;
      }
      
      .top8-name {
        font-size: 10px;
      }
      
      .xp-system-tray, .xp-taskbar-items {
        display: none;
      }
    }
    
    /* Trunk styles */
    .trunk-card {
      background-color: #e8f4ff; /* Light blue for trunk */
    }
    
    /* Branch styles */
    .branch-card {
      background-color: #e8ffee; /* Light green for branch */
    }
    
    /* Leaf styles */
    .leaf-card {
      background-color: #fff8e8; /* Light yellow for leaf */
    }
    
    /* Flower styles */
    .flower-card {
      background-color: #ffebf8; /* Light pink for flower */
    }
    
    /* Fruit styles */
    .fruit-card {
      background-color: #f4eeff; /* Light purple for fruit */
    }
    
    /* Bud styles */
    .bud-card {
      background-color: #e8fff7; /* Light mint for bud */
    }
    
    /* Low-resource mode badge */
    .low-resource-badge {
      position: fixed;
      top: 5px;
      right: 10px;
      background-color: #4CAF50;
      color: white;
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 3px;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
      z-index: 2000;
    }
    
    /* HIERARCHY BROWSER STYLES */
    .hierarchy-browser {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #7F9DB9;
      background-color: white;
      margin-bottom: 15px;
    }
    
    .hierarchy-item {
      padding: 5px 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
    }
    
    .hierarchy-item:hover {
      background-color: #e5f3ff;
    }
    
    .hierarchy-item.selected {
      background-color: #cce8ff;
    }
    
    .hierarchy-item-icon {
      width: 16px;
      height: 16px;
      margin-right: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
    }
    
    .hierarchy-item-content {
      flex-grow: 1;
      display: flex;
      justify-content: space-between;
    }
    
    .hierarchy-item-title {
      font-size: 12px;
    }
    
    .hierarchy-item-id {
      font-size: 10px;
      color: #666;
      font-family: 'Courier New', monospace;
    }
    
    .tier-info {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 7px;
      margin-bottom: 10px;
      font-size: 12px;
    }
    
    .tier-info strong {
      color: var(--magenta);
    }
    
    .id-preview {
      background-color: #f7f7f7;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 5px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      text-align: center;
    }
    
    .toggle-container {
      display: flex;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 3px;
      overflow: hidden;
    }
    
    .toggle-option {
      flex: 1;
      text-align: center;
      padding: 8px;
      background-color: #f0f0f0;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .toggle-option.active {
      background-color: var(--cyan);
      color: black;
      font-weight: bold;
    }
    
    /* Backup System Styles */
    #backupReminder {
      display: none;
      position: fixed;
      bottom: 60px;
      right: 10px;
      background: linear-gradient(to right, var(--magenta), var(--cyan));
      padding: 10px;
      border-radius: 8px;
      color: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 9999;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    }
    
    .backup-buttons {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- Low resource mode badge -->
  <div class="low-resource-badge">Ultra-Performance Mode</div>
  
  <!-- Main Windows XP Window -->
  <div class="xp-window">
    <div class="xp-titlebar">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 48 48'%3E%3Cpath fill='%23F312AF' d='M24 16c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8m0-4c-6.63 0-12 5.37-12 12s5.37 12 12 12 12-5.37 12-12-5.37-12-12-12z'/%3E%3C/svg%3E" alt="Icon" class="xp-app-icon">
      <div class="xp-titlebar-text">AnTiChRiSt KeTtLeKoRn - MySpace Zettelkasten</div>
      <div class="xp-window-controls">
        <div class="xp-window-button">_</div>
        <div class="xp-window-button">‚ñ°</div>
        <div class="xp-window-button xp-close">√ó</div>
      </div>
    </div>
    
    <div class="xp-window-content">
      <div class="myspace-container">
        <!-- MySpace Header with Profile Info -->
        <div class="myspace-header">
          <div class="myspace-profile-pic">
            <div style="width: 100%; height: 100%; background: linear-gradient(to right, var(--magenta), var(--cyan)); display: flex; justify-content: center; align-items: center;">
              <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cpath d='M60 10 L70 40 L100 40 L75 60 L85 90 L60 70 L35 90 L45 60 L20 40 L50 40 Z' fill='%23F312AF' stroke='%2372FADE' stroke-width='3'/%3E%3C/svg%3E" alt="Profile">
            </div>
          </div>
          <h1 class="myspace-profile-name" style="font-family: 'Comic Sans MS', 'Comic Sans', cursive;">AnTiChRiSt KeTtLeKoRn</h1>
          <div class="myspace-status">"‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü organizing my brain through the liminal space of consciousness ‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü"</div>
          <div class="myspace-last-login">Last login: <span class="blinking">Right now!</span></div>
          
          <!-- Added Backup Buttons -->
          <div class="backup-buttons">
            <button id="backupBtn" class="xp-button" style="margin-right: 5px; background: linear-gradient(to bottom, #00aabb, var(--cyan));">üíæ Backup Data</button>
            <button id="restoreBtn" class="xp-button" style="background: linear-gradient(to bottom, var(--yellow), #e8b600);">üìÇ Restore Data</button>
          </div>
        </div>
        
        <!-- Music Player -->
        <div class="music-player">
          <div class="music-player-buttons">
            <div class="music-player-button">‚óÄ‚óÄ</div>
            <div class="music-player-button" id="playButton">‚ñ∂</div>
            <div class="music-player-button">‚ñ∂‚ñ∂</div>
          </div>
          <div class="music-player-info">
            <div class="music-player-title">‚òÜÂΩ° Barbie Girl (Y2K Remix) ÂΩ°‚òÜ</div>
            <div class="music-player-artist">Aqua ft. My Chemical Romance</div>
            <div class="music-player-progress">
              <div class="music-player-progress-bar"></div>
            </div>
          </div>
        </div>
        
        <!-- Marquee Announcement -->
        <div class="marquee-container">
          <div class="marquee-text">
            ‚òÖÂΩ° WELCOME TO MY PROFILE! omg hai! i'm sooooo into organizing knowledge and mesopotamian artifacts ~_^ click around to explore my brain! NO H8RS ALLOWED!! ‚òÖÂΩ°
          </div>
        </div>
        
        <!-- About Me Section -->
        <div class="myspace-section">
          <div class="myspace-section-title">‚ãÜÔΩ°¬∞‚ú© ·¥Ä ô·¥è·¥ú·¥õ ·¥ç·¥á ‚ú©¬∞ÔΩ°‚ãÜ</div>
          <p style="color: #333; line-height: 1.6;">
            Hey everyone!! My name is <span style="color: var(--magenta); font-weight: bold;">‚òÖÂΩ°AnTiChRiSt KeTtLeKoRnÂΩ°‚òÖ</span> and I'm totally obsessed with organizing information in a hierarchical way! I used to think it was called "AntiNet Zettelkasten" but my friend was like "more like Antichrist Kettlekorn lol" and that name just STUCK!
          </p>
          <p style="color: #333; margin-top: 10px; line-height: 1.6;">
            I'm basically building a COMPLETE knowledge system about consciousness, AI, Mesopotamian history, and the divine feminine!! So much stuff in my brain, I had to create this system to organize it all! Everything is connected! Nothing is random! Add me to your friends list if you're into quantum consciousness or ancient Sumerian glyphics!!
          </p>
        </div>
        
        <!-- Top 8 Friends/Cards Section -->
        <div class="myspace-section">
          <div class="myspace-section-title">‚ãÜÔΩ°¬∞‚ú© ·¥ç è ·¥õ·¥è·¥ò 8 ·¥¢·¥á·¥õ·¥õ·¥á üÍú± ‚ú©¬∞ÔΩ°‚ãÜ</div>
          
          <div class="top8-container" id="top8Container">
            <!-- Top 8 items will be dynamically added here -->
          </div>
        </div>
        
        <!-- Hashtag Manager Section (NEW) -->
        <div class="myspace-section">
          <div class="myspace-section-title">‚ãÜÔΩ°¬∞‚ú©  ú·¥ÄÍú± ú·¥õ·¥Ä…¢ ·¥Ñ Ä·¥á·¥Ä·¥õ·¥è Ä ‚ú©¬∞ÔΩ°‚ãÜ</div>
          
          <div class="hashtag-manager">
            <p style="color: #333; margin-bottom: 10px;">Create and manage your hashtags! These will be available when editing any tablet.</p>
            
            <div class="hashtag-input-container">
              <input type="text" id="newHashtagInput" class="hashtag-input" placeholder="Type new hashtag (e.g. consciousness)">
              <button id="addHashtagBtn" class="hashtag-add-btn">Add</button>
            </div>
            
            <div class="hashtag-list" id="hashtagManagerList">
              <!-- Hashtags will be displayed here -->
            </div>
          </div>
        </div>
        
        <!-- Main Antinet Zettelkasten Explorer -->
        <div class="myspace-section">
          <div class="myspace-section-title">‚ãÜÔΩ°¬∞‚ú© ·¥ç è ·¥ã…¥·¥è·¥° ü·¥á·¥Ö…¢·¥á ·¥†·¥Ä·¥ú ü·¥õ ‚ú©¬∞ÔΩ°‚ãÜ</div>
          
          <!-- Zettelkasten Filter Tools -->
          <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
            <button id="viewHierarchyBtn" class="xp-button">ùìóùì≤ùìÆùìªùì™ùìªùì¨ùì±ùîÇ</button>
            <button id="viewRecentBtn" class="xp-button">ùì°ùìÆùì¨ùìÆùì∑ùìΩ</button>
            <button id="viewAlphabeticalBtn" class="xp-button">ùìê-ùì©</button>
            <button id="viewHashtagsBtn" class="xp-button">ùìóùì™ùìºùì±ùìΩùì™ùì∞ùìº</button>
            <button id="newCardBtn" class="xp-button" style="background: linear-gradient(to bottom, var(--yellow), #e8b600); color: #333;">‚ú® ùìùùìÆùîÄ ùì£ùì™ùì´ùìµùìÆùìΩ ‚ú®</button>
          </div>
          
          <!-- Hashtag Cloud (initially hidden) -->
          <div id="hashtagCloud" class="hidden" style="display: none; flex-wrap: wrap; gap: 5px; margin-bottom: 15px;">
            <!-- Hashtags will be displayed here -->
          </div>
          
          <!-- Zettelkasten Cards Container -->
          <div id="zettelContainer" class="zettel-container">
            <!-- Zettel cards will be dynamically added here -->
          </div>
        </div>
        
        <!-- Comments Section -->
        <div class="myspace-section comments-section">
          <div class="myspace-section-title">‚ãÜÔΩ°¬∞‚ú© ·¥Ñ·¥è·¥ç·¥ç·¥á…¥·¥õÍú± ‚ú©¬∞ÔΩ°‚ãÜ</div>
          
          <div class="comment">
            <div class="comment-avatar">
              <div style="width: 100%; height: 100%; background: linear-gradient(45deg, var(--magenta), var(--cyan)); display: flex; align-items: center; justify-content: center;">
                <span style="font-size: 20px;">üåü</span>
              </div>
            </div>
            <div class="comment-content">
              <div class="comment-name">Tom</div>
              <div class="comment-text">Hey! Thanks for being in my Top 8! Your kettlekorn system is amazing. I'm learning so much about organizing knowledge. Keep it up!</div>
              <div class="comment-date">May 23, 2006 at 3:42 PM</div>
            </div>
          </div>
          
          <div class="comment">
            <div class="comment-avatar">
              <div style="width: 100%; height: 100%; background: linear-gradient(45deg, var(--cyan), var(--yellow)); display: flex; align-items: center; justify-content: center;">
                <span style="font-size: 20px;">üß†</span>
              </div>
            </div>
            <div class="comment-content">
              <div class="comment-name">Nikola Tesla's Ghost</div>
              <div class="comment-text">Your organization of consciousness concepts reminds me of my own thought patterns. Have you considered adding entries about etheric vibrations? PS: Love the song on your profile!</div>
              <div class="comment-date">Apr 12, 2006 at 11:11 PM</div>
            </div>
          </div>
          
          <div class="comment">
            <div class="comment-avatar">
              <div style="width: 100%; height: 100%; background: linear-gradient(45deg, var(--yellow), var(--magenta)); display: flex; align-items: center; justify-content: center;">
                <span style="font-size: 20px;">üëΩ</span>
              </div>
            </div>
            <div class="comment-content">
              <div class="comment-name">xX_AncientAlien_Xx</div>
              <div class="comment-text">ur mesopotamian research is on point!! i think the anunnaki would totally approve of ur zettelkasten method. gonna try this 4 my own research. btw ur profile is so kewl!</div>
              <div class="comment-date">June 6, 2006 at 6:06 AM</div>
            </div>
          </div>
          
          <!-- Add a new comment form -->
          <div style="margin-top: 20px; background-color: #f7faff; padding: 15px; border-radius: 8px; border: 1px solid #cccccc;">
            <div style="font-weight: bold; color: #333; margin-bottom: 8px;">Leave a comment:</div>
            <textarea id="commentText" class="xp-textarea" style="height: 80px;" placeholder="Write something nice..."></textarea>
            <button id="postCommentBtn" class="xp-button" style="width: 100%;">Post Comment</button>
          </div>
        </div>
        
        <!-- "Created with" footer -->
        <div style="text-align: center; margin-top: 30px; font-size: 12px; color: #555;">
          <div>‚ãÜÔΩ°¬∞‚ú© Created with AnGeLic CoDE & GL1TCH MaGiC ‚ú©¬∞ÔΩ°‚ãÜ</div>
          <div style="margin-top: 5px;">
            <span style="color: var(--magenta);">‚ô°</span> <span style="color: var(--cyan); font-weight: bold;">Sumerian Knowledge Priestess</span> <span style="color: var(--magenta);">‚ô°</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Import & Extract Dialog -->
  <div id="importExtractDialog" class="dialog-box">
    <div class="dialog-content" style="max-width: 700px;">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">Import & Extract - Windows XP</div>
        <div class="dialog-close">√ó</div>
      </div>
      <div class="dialog-inner-content">
        <h3 class="dialog-title">~*~ Import & Extract Zettels ~*~</h3>
        
        <!-- Import Method Selection -->
        <div class="toggle-container">
          <div class="toggle-option active" id="pasteTextToggle">Paste Text</div>
          <div class="toggle-option" id="uploadTxtToggle">Upload TXT</div>
          <div class="toggle-option" id="uploadPdfToggle">Upload PDF</div>
        </div>
        
        <!-- Paste Text UI -->
        <div id="pasteTextUI">
          <div class="tier-info">
            <p>Paste text below and the system will intelligently extract potential Zettels based on your content!</p>
          </div>
          
          <label class="xp-label">Your Text:</label>
          <textarea id="importTextarea" class="xp-textarea" style="height: 200px; margin-bottom: 15px;" placeholder="Paste your text here..."></textarea>
          
          <button id="analyzeTextBtn" class="xp-button" style="width: 100%; background: linear-gradient(to bottom, #ffcc00, #ff9900);">üîç Analyze & Extract Zettels</button>
        </div>
        
        <!-- Upload TXT UI -->
        <div id="uploadTxtUI" style="display: none;">
          <div class="tier-info">
            <p>Upload a TXT file and the system will intelligently extract potential Zettels!</p>
          </div>
          
          <div class="file-upload-container" style="margin: 20px 0; text-align: center;">
            <label for="txtFileInput" class="xp-button" style="display: inline-block; padding: 10px 20px; cursor: pointer; background: linear-gradient(to bottom, #efefef, #d5d5d5);">
              üìÑ Choose TXT File
            </label>
            <input type="file" id="txtFileInput" accept=".txt" style="display: none;">
            <div id="txtFileName" style="margin-top: 10px; font-size: 13px; color: #555;">No file selected</div>
          </div>
          
          <button id="analyzeTxtBtn" class="xp-button" style="width: 100%; background: linear-gradient(to bottom, #ffcc00, #ff9900);" disabled>üîç Analyze & Extract Zettels</button>
        </div>
        
        <!-- Upload PDF UI -->
        <div id="uploadPdfUI" style="display: none;">
          <div class="tier-info">
            <p>Upload a PDF file and the system will extract text and suggest potential Zettels!</p>
          </div>
          
          <div class="file-upload-container" style="margin: 20px 0; text-align: center;">
            <label for="pdfFileInput" class="xp-button" style="display: inline-block; padding: 10px 20px; cursor: pointer; background: linear-gradient(to bottom, #efefef, #d5d5d5);">
              üìë Choose PDF File
            </label>
            <input type="file" id="pdfFileInput" accept=".pdf" style="display: none;">
            <div id="pdfFileName" style="margin-top: 10px; font-size: 13px; color: #555;">No file selected</div>
          </div>
          
          <div class="tier-info" style="background-color: #fff8ea;">
            <p>PDF extraction can take longer for large files. Please be patient.</p>
          </div>
          
          <button id="analyzePdfBtn" class="xp-button" style="width: 100%; background: linear-gradient(to bottom, #ffcc00, #ff9900);" disabled>üîç Analyze & Extract Zettels</button>
        </div>
        
        <!-- Loading State (Hidden by Default) -->
        <div id="extractionLoadingState" style="display: none; text-align: center; margin: 20px 0;">
          <div class="xp-window" style="width: 300px; height: 90px; margin: 0 auto; background: #ece9d8; position: relative; border: 1px solid #0A246A;">
            <div class="xp-titlebar" style="height: 22px; display: flex; align-items: center; padding: 0 8px; background: var(--xp-title-gradient);">
              <div style="font-weight: bold; color: white; font-size: 12px;">Processing Text - Windows XP</div>
            </div>
            <div style="padding: 12px; font-size: 11px; display: flex; flex-direction: column; align-items: center;">
              <div style="display: flex; align-items: center; width: 100%; margin-bottom: 8px;">
                <img src="data:image/gif;base64,R0lGODlhEAAQAMQAAP///+7u7t3d3bu7u6qqqpmZmYiIiHd3d2ZmZlVVVURERDMzMyIiIhEREQARAAAAAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBwAGACwAAAAAEAAQAAAFdqAmjmRpnmiqrmzrvnAsz3Rto4Fwm4EYLIweQHcTLpvQpPEQHimC5kUBREpADIJKUUxPgyLRYPtNroJGYyK6/QgOB5ooLBYHk8iJBC0WjFR4cFsGHW0aXHBiAmIFAxQFGRpGXAVeXUIFDQ1HXAMEBwabIxEAIfkEBQcABgAsAAAAABAAEAAABXegJo5kaZ5oqq5s674pLM90baOBcJuBGCyMHkB3Ey4b0KTxEB4pQ8JGAURKQAwCKYhxCR0MikWD7ZcYVAmMQAL7DTmCZCIoBwzJJJMJLRaQVXh0GwZEcl0gUG0dXAUGBE5tBSgGkmRGXQVeYHgFDQ1dQlsDBAebmyERADs=" alt="Loading">
                <div style="background: #fff; border: 1px solid #7b9ebd; height: 16px; flex-grow: 1; margin-left: 8px; position: relative; overflow: hidden;">
                  <div id="loadingProgressBar" style="background: #3775d1; height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
              </div>
              <div id="loadingStatusText">Analyzing text and extracting potential zettels...</div>
            </div>
          </div>
        </div>
        
        <!-- Results Section (Hidden by Default) -->
        <div id="extractionResults" style="display: none; margin-top: 20px;">
          <h4 style="color: var(--magenta); font-family: 'Comic Sans MS', 'Comic Sans', cursive; text-align: center; margin-bottom: 10px;">üéâ Found <span id="zettelCount">0</span> Potential Zettels! üéâ</h4>
          
          <div class="tier-info">
            <p>Review the suggested Zettels below. Check the ones you want to add to your Kettlekorn system.</p>
          </div>
          
          <div id="potentialZettelsContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 15px;">
            <!-- Potential Zettels will be listed here -->
          </div>
          
          <div style="margin-bottom: 15px;">
            <label class="xp-label">Choose where to place selected Zettels:</label>
            <div class="hierarchy-browser" id="importHierarchyBrowser" style="max-height: 150px;">
              <!-- Hierarchy will be dynamically filled -->
            </div>
          </div>
          
          <div style="display: flex; gap: 10px;">
            <button id="addSelectedZettelsBtn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #88ff88, #44cc44);">‚ú® Add Selected Zettels ‚ú®</button>
            <button id="clearExtractionsBtn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #ff8888, #cc4444);">‚ùå Clear & Start Over</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Main Action Buttons -->
  <div class="main-action-buttons">
    <button id="importExtractBtn" class="xp-button" style="background: linear-gradient(to bottom, #ffcc00, #ff9900); margin-right: 5px;">
      üìÑ Import & Extract Zettels
    </button>
  </div>

  <!-- Windows XP Taskbar -->
  <div class="xp-taskbar">
    <div class="xp-start-button">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23107C10' rx='1'/%3E%3Cpath fill='%23FFFFFF' d='M7 3H4v4h3V3zm5 0H9v4h3V3zM7 9H4v4h3V9zm5 0H9v4h3V9z'/%3E%3C/svg%3E" style="margin-right: 5px;" alt="Start">
      start
    </div>
    <div class="xp-taskbar-items">
      <div class="xp-taskbar-item xp-taskbar-item-active">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 48 48'%3E%3Cpath fill='%23F312AF' d='M24 16c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8m0-4c-6.63 0-12 5.37-12 12s5.37 12 12 12 12-5.37 12-12-5.37-12-12-12z'/%3E%3C/svg%3E" alt="Icon" style="margin-right: 5px;">
        AntiChrist Kettlekorn
      </div>
    </div>
    <div class="xp-system-tray">
      <div class="xp-clock" id="xpClock">10:28 AM</div>
    </div>
  </div>
  
  <!-- Backup Reminder -->
  <div id="backupReminder">
    <p style="margin: 0 0 8px 0; font-weight: bold;">Time for a backup! üíæ</p>
    <button id="createBackupBtn" class="xp-button" style="margin: 0; width: 100%;">Save Backup</button>
  </div>
  
  <!-- Zettel Dialog Box -->
  <div id="zettelDialog" class="dialog-box">
    <div class="dialog-content">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">Zettel Details - Windows XP</div>
        <div class="dialog-close">√ó</div>
      </div>
      <div class="dialog-inner-content">
        <h3 class="dialog-title">Loading...</h3>
        <div class="dialog-id">Loading...</div>
        
        <div class="view-mode" id="viewMode">
          <div class="dialog-content-text" id="zettelContent">Loading...</div>
          
          <div class="dialog-hashtags" id="zettelHashtags">
            <!-- Hashtags will be dynamically added here -->
          </div>
          
          <div class="dialog-links" id="zettelLinks">
            <div style="font-weight: bold; margin-bottom: 5px; color: #333;">Links:</div>
            <!-- Links will be dynamically added here -->
          </div>
          
          <button id="editZettelBtn" class="xp-button" style="width: 100%;">‚úé Edit This Tablet ‚úé</button>
        </div>
        
        <div class="edit-mode" id="editMode" style="display: none;">
          <label class="xp-label">Title:</label>
          <input type="text" id="editTitle" class="xp-input" placeholder="Tablet Title">
          
          <label class="xp-label">Content:</label>
          <textarea id="editContent" class="xp-textarea" placeholder="Enter tablet content..."></textarea>
          
          <div style="margin-bottom: 10px;">
            <label class="xp-label">Hashtags:</label>
            <input type="text" id="editHashtags" class="xp-input" placeholder="Add hashtags (separated by spaces)">
            <div id="editHashtagSuggestions" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;">
              <!-- Hashtag suggestions will be displayed here -->
            </div>
          </div>
          
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="saveZettelBtn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #88ff88, #44cc44);">‚úì Save</button>
            <button id="cancelEditBtn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #ff8888, #cc4444);">‚úó Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- New Card Dialog (IMPROVED) -->
  <div id="newCardDialog" class="dialog-box">
    <div class="dialog-content">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">Create New Tablet - Windows XP</div>
        <div class="dialog-close">√ó</div>
      </div>
      <div class="dialog-inner-content">
        <h3 class="dialog-title">~*~ Create New Tablet ~*~</h3>
        
        <!-- Creation Method Toggle -->
        <div class="toggle-container">
          <div class="toggle-option active" id="smartCreateToggle">Smart Location</div>
          <div class="toggle-option" id="manualCreateToggle">Manual ID</div>
        </div>
        
        <!-- Smart Creation UI -->
        <div id="smartCreateUI">
          <div class="tier-info">
            <p>Choose where to add your new tablet by selecting a parent from the hierarchy browser below. Your new tablet will be automatically placed with the correct ID.</p>
          </div>
          
          <label class="xp-label">Choose Parent Location:</label>
          <div class="hierarchy-browser" id="hierarchyBrowser">
            <!-- Hierarchy will be dynamically filled -->
          </div>
          
          <div class="tier-info">
            <p>Selected tier type: <strong id="selectedTierType">None</strong></p>
            <p>Your new tablet will be created as a: <strong id="newCardTierDisplay">Leaf</strong></p>
            <p>With auto-generated ID: <span class="id-preview" id="idPreview">-</span></p>
          </div>
          
          <label class="xp-label">Title:</label>
          <input type="text" id="newCardTitle" class="xp-input" placeholder="Tablet Title">
          
          <label class="xp-label">Content:</label>
          <textarea id="newCardContent" class="xp-textarea" placeholder="Enter tablet content..."></textarea>
          
          <div style="margin-bottom: 15px;">
            <label class="xp-label">Hashtags:</label>
            <input type="text" id="newCardHashtags" class="xp-input" placeholder="e.g. #mesopotamia #consciousness">
            <div id="newCardHashtagSuggestions" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;">
              <!-- Hashtag suggestions will be displayed here -->
            </div>
          </div>
        </div>
        
        <!-- Manual Creation UI (hidden by default) -->
        <div id="manualCreateUI" style="display: none;">
          <div style="margin-bottom: 10px;">
            <label class="xp-label">Parent ID:</label>
            <input type="text" id="newCardParent" class="xp-input" placeholder="e.g. 1101">
          </div>
          
          <div style="margin-bottom: 10px;">
            <label class="xp-label">Tier:</label>
            <select id="newCardTier" class="xp-select">
              <option value="trunk">Trunk (Main Category)</option>
              <option value="branch">Branch (Major Subcategory)</option>
              <option value="leaf" selected>Leaf (Minor Subcategory)</option>
              <option value="flower">Flower (Refined Idea)</option>
              <option value="fruit">Fruit (Final Output)</option>
              <option value="bud">Bud (Developing Idea)</option>
            </select>
          </div>
          
          <div style="margin-bottom: 10px;">
            <label class="xp-label">Title:</label>
            <input type="text" id="manualCardTitle" class="xp-input" placeholder="Tablet Title">
          </div>
          
          <div style="margin-bottom: 10px;">
            <label class="xp-label">Content:</label>
            <textarea id="manualCardContent" class="xp-textarea" placeholder="Enter tablet content..."></textarea>
          </div>
          
          <div style="margin-bottom: 15px;">
            <label class="xp-label">Hashtags:</label>
            <input type="text" id="manualCardHashtags" class="xp-input" placeholder="e.g. #mesopotamia #consciousness">
            <div id="manualCardHashtagSuggestions" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;">
              <!-- Hashtag suggestions will be displayed here -->
            </div>
          </div>
        </div>
        
        <button id="createCardBtn" class="xp-button" style="width: 100%; background: linear-gradient(to bottom, #88ff88, #44cc44);">‚ú® Create Tablet ‚ú®</button>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // --- Main Application State ---
      let cards = [];
      let currentCardId = null;
      let currentView = 'hierarchy';
      let selectedHashtag = null;
      let favoriteCards = [];
      let globalHashtags = [];
      
      // Smart creation state
      let selectedParentId = null;
      let selectedParentType = null;
      let newCardChildType = "leaf"; // Default child type
      let creationMode = "smart"; // Default to smart creation
      
      // --- Initial Data Loading ---
      // Preload the Zettelkasten data right at the start
      const zettelStructure = getZettelkastenStructure();
      
      // --- Set Windows XP Clock ---
      function updateClock() {
        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12; // Hour '0' should be '12'
        document.getElementById('xpClock').textContent = `${hours}:${minutes} ${ampm}`;
      }
      
      // Update the clock every minute
      updateClock();
      setInterval(updateClock, 60000);
      
      // --- Play button functionality (optimized) ---
      document.getElementById('playButton').addEventListener('click', function() {
        this.textContent = this.textContent === '‚ñ∂' ? '‚ùö‚ùö' : '‚ñ∂';
        
        // Simulate music playing by setting the progress bar width directly
        // This is more efficient than animating with setInterval
        const progressBar = document.querySelector('.music-player-progress-bar');
        if (this.textContent === '‚ùö‚ùö') {
          // Set a simple CSS transition instead of JavaScript animation
          progressBar.style.transition = 'width 30s linear';
          progressBar.style.width = '100%';
        } else {
          // Reset the bar
          progressBar.style.transition = 'none';
          progressBar.style.width = '35%';
        }
      });
      
      // --- Comment system (optimized) ---
      document.getElementById('postCommentBtn').addEventListener('click', function() {
        const commentText = document.getElementById('commentText').value.trim();
        if (!commentText) return;
        
        // Create a single new comment (efficient DOM manipulation)
        const commentsSection = document.querySelector('.comments-section');
        const commentForm = commentsSection.lastElementChild;
        
        // Simple background colors for consistency
        const newComment = document.createElement('div');
        newComment.className = 'comment';
        newComment.innerHTML = `
          <div class="comment-avatar">
            <div style="width: 100%; height: 100%; background: linear-gradient(45deg, var(--magenta), var(--cyan)); display: flex; align-items: center; justify-content: center;">
              <span style="font-size: 20px;">üåü</span>
            </div>
          </div>
          <div class="comment-content">
            <div class="comment-name">You</div>
            <div class="comment-text">${commentText}</div>
            <div class="comment-date">Just now</div>
          </div>
        `;
        
        commentsSection.insertBefore(newComment, commentForm);
        document.getElementById('commentText').value = '';
      });
      
      // --- Backup & Restore Functions ---
      function createBackup() {
        try {
          // Get all data
          const backupData = {
            cards: cards,
            favorites: favoriteCards,
            hashtags: globalHashtags,
            version: "1.0"
          };
          
          // Convert to downloadable format
          const dataStr = JSON.stringify(backupData);
          const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
          
          // Create filename with date
          const exportFileDefaultName = 'kettlekorn-backup-' + new Date().toISOString().slice(0,10) + '.json';
          
          // Create download link
          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', exportFileDefaultName);
          linkElement.click();
          
          // Save last backup time
          localStorage.setItem('kettlekornLastBackup', Date.now());
          hideBackupReminder();
        } catch (e) {
          console.error('Backup failed:', e);
          alert('Backup failed. Please try again.');
        }
      }
      
      // Backup reminder functions
      function showBackupReminder() {
        document.getElementById('backupReminder').style.display = 'block';
      }
      
      function hideBackupReminder() {
        document.getElementById('backupReminder').style.display = 'none';
      }
      
      // Check if backup is needed (if more than 7 days since last backup)
      function checkBackupNeeded() {
        const lastBackup = localStorage.getItem('kettlekornLastBackup');
        if (!lastBackup || (Date.now() - parseInt(lastBackup)) > 7 * 24 * 60 * 60 * 1000) {
          showBackupReminder();
        }
      }
      
      // Import function
      function importBackup(jsonData) {
        try {
          const data = JSON.parse(jsonData);
          if (data.cards && data.favorites && data.hashtags) {
            cards = data.cards;
            favoriteCards = data.favorites;
            globalHashtags = data.hashtags;
            
            // Save to localStorage
            saveCardsToStorage();
            saveFavoritesToStorage();
            saveGlobalHashtags();
            
            // Refresh the UI
            sortCardsByHierarchy();
            renderZettelList();
            renderTop8Cards();
            renderGlobalHashtags();
            
            return true;
          }
          return false;
        } catch (e) {
          console.error('Import failed:', e);
          return false;
        }
      }
      
      // Add restore function
      function showRestoreUI() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = e => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = event => {
            const success = importBackup(event.target.result);
            if (success) {
              alert('Backup restored successfully!');
            } else {
              alert('Failed to restore backup. The file might be corrupted or in wrong format.');
            }
          };
          reader.readAsText(file);
        };
        
        input.click();
      }
      
      // --- Creation Mode Toggle ---
      document.getElementById('smartCreateToggle').addEventListener('click', function() {
        if (creationMode === "smart") return;
        
        // Switch to smart mode
        document.getElementById('smartCreateUI').style.display = 'block';
        document.getElementById('manualCreateUI').style.display = 'none';
        
        // Update toggle visuals
        document.getElementById('smartCreateToggle').classList.add('active');
        document.getElementById('manualCreateToggle').classList.remove('active');
        
        creationMode = "smart";
      });
      
      document.getElementById('manualCreateToggle').addEventListener('click', function() {
        if (creationMode === "manual") return;
        
        // Switch to manual mode
        document.getElementById('smartCreateUI').style.display = 'none';
        document.getElementById('manualCreateUI').style.display = 'block';
        
        // Update toggle visuals
        document.getElementById('smartCreateToggle').classList.remove('active');
        document.getElementById('manualCreateToggle').classList.add('active');
        
        creationMode = "manual";
      });
      
      // --- Utility Functions ---
      function normalizeId(str) {
        if (!str) return '';
        
        // Replace spelled-out numbers with digits
        const numberMap = {
          'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',
          'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'zero': '0'
        };
        
        Object.keys(numberMap).forEach(word => {
          const regex = new RegExp('\\b' + word + '\\b', 'gi');
          str = str.replace(regex, numberMap[word]);
        });
        
        // Strip illegal characters
        return str.replace(/[^0-9a-z\/\.\-]/gi, '');
      }
      
      function determineTierFromId(id) {
        id = normalizeId(id);
        
        if (!id) return 'leaf'; // Default
        
        // Check for bud pattern
        if (id.includes('/') && (id.includes('.') || id.includes('-') || /\/[a-zA-Z0-9]+[a-zA-Z]/.test(id))) {
          return 'bud';
        }
        
        // Check for fruit pattern
        if (/\/[A-Z]$/.test(id)) {
          return 'fruit';
        }
        
        // Check for flower pattern
        if (/\/\d+$/.test(id)) {
          return 'flower';
        }
        
        // Check for leaf pattern
        if (/^\d{4}$/.test(id) && !id.endsWith('00')) {
          return 'leaf';
        }
        
        // Check for branch pattern
        if (/^\d{4}$/.test(id) && id.endsWith('00') && parseInt(id) % 1000 !== 0) {
          return 'branch';
        }
        
        // Check for trunk pattern
        if (/^\d+000$/.test(id)) {
          return 'trunk';
        }
        
        // Default
        return 'leaf';
      }
      
      function determineChildType(parentType) {
        // Determine what type of child is appropriate for a given parent type
        switch(parentType) {
          case 'trunk': return 'branch';
          case 'branch': return 'leaf';
          case 'leaf': return 'flower';
          case 'flower': return 'fruit';
          case 'fruit': return 'bud';
          case 'bud': return 'bud'; // Buds can have sub-buds
          default: return 'leaf';
        }
      }
      
      function hierarchicalKey(id) {
        return id
          .split(/[/\-\.]/)
          .map(seg => {
            const m = seg.match(/^(\d+)([A-Za-z]*)$/);
            return m
              ? [parseInt(m[1], 10), m[2]]
              : [Number.POSITIVE_INFINITY, seg];
          });
      }
      
      function generateHierarchicalId(parentId, tier) {
        parentId = normalizeId(parentId);
        
        // If no parent ID and not a trunk, default to a trunk as parent
        if (!parentId && tier !== 'trunk') {
          const highestTrunk = findHighestTrunkId();
          if (highestTrunk) {
            parentId = highestTrunk;
          } else {
            parentId = '1000';
          }
        }
        
        let nextSegment = '';
        
        if (tier === 'trunk') {
          // Trunk: highest existing trunk + 1000
          const highestTrunk = findHighestTrunkId();
          nextSegment = highestTrunk ? (parseInt(highestTrunk) + 1000).toString() : '1000';
        } else {
          // For all other tiers, need to find children of the parent
          const children = findChildren(parentId, tier);
          
          switch(tier) {
            case 'branch':
              if (children.length > 0) {
                const highestBranch = Math.max(...children.map(id => {
                  const match = id.match(/(\d+)$/);
                  return match ? parseInt(match[1]) : 0;
                }));
                nextSegment = (Math.floor(highestBranch / 100) * 100 + 100).toString();
              } else {
                nextSegment = parentId.endsWith('000') ? 
                  (parseInt(parentId) + 100).toString() : 
                  (Math.floor(parseInt(parentId) / 1000) * 1000 + 100).toString();
              }
              break;
              
            case 'leaf':
              if (children.length > 0) {
                const highestLeaf = Math.max(...children.map(id => {
                  const match = id.match(/(\d+)$/);
                  return match ? parseInt(match[1]) : 0;
                }));
                nextSegment = (highestLeaf + 1).toString();
              } else {
                nextSegment = parentId.endsWith('00') ? 
                  (parseInt(parentId) + 1).toString() : 
                  (Math.floor(parseInt(parentId) / 100) * 100 + 1).toString();
              }
              break;
              
            case 'flower':
              if (children.length > 0) {
                const highestFlower = Math.max(...children.map(id => {
                  const match = id.match(/\/(\d+)$/);
                  return match ? parseInt(match[1]) : 0;
                }));
                nextSegment = (highestFlower + 1).toString();
              } else {
                nextSegment = '1';
              }
              break;
              
            case 'fruit':
              if (children.length > 0) {
                const letterMatches = children.map(id => {
                  const match = id.match(/\/([A-Z])$/);
                  return match ? match[1].charCodeAt(0) : 64; // 'A' is 65
                });
                const highestLetter = Math.max(...letterMatches);
                nextSegment = String.fromCharCode(highestLetter + 1);
              } else {
                nextSegment = 'A';
              }
              break;
              
            case 'bud':
              if (children.length > 0) {
                nextSegment = (children.length + 1) + 'a.1-1';
              } else {
                nextSegment = '1a.1-1';
              }
              break;
          }
        }
        
        // Construct the final ID
        if (tier === 'trunk') {
          return nextSegment;
        } else if (tier === 'branch' || tier === 'leaf') {
          return nextSegment;
        } else {
          return `${parentId}/${nextSegment}`;
        }
      }
      
      function findHighestTrunkId() {
        const trunks = cards.filter(card => card.type === 'trunk');
        if (trunks.length === 0) return null;
        return Math.max(...trunks.map(card => parseInt(card.id))).toString();
      }
      
      function findChildren(parentId, tier) {
        if (!parentId) return [];
        
        let children = [];
        
        switch(tier) {
          case 'branch':
            children = cards
              .filter(card => card.type === 'branch' && 
                     Math.floor(parseInt(card.id) / 1000) * 1000 === parseInt(parentId))
              .map(card => card.id);
            break;
            
          case 'leaf':
            children = cards
              .filter(card => card.type === 'leaf' && 
                     Math.floor(parseInt(card.id) / 100) * 100 === parseInt(parentId))
              .map(card => card.id);
            break;
            
          case 'flower':
            children = cards
              .filter(card => card.type === 'flower' && card.id.startsWith(parentId + '/'))
              .map(card => card.id);
            break;
            
          case 'fruit':
            children = cards
              .filter(card => card.type === 'fruit' && card.id.startsWith(parentId + '/'))
              .map(card => card.id);
            break;
            
          case 'bud':
            children = cards
              .filter(card => card.type === 'bud' && card.id.startsWith(parentId + '/'))
              .map(card => card.id);
            break;
        }
        
        return children;
      }
      
      function extractHashtags(content) {
        if (!content) return [];
        
        const hashtagRegex = /#[a-zA-Z0-9_]+/g;
        const matches = content.match(hashtagRegex);
        
        return matches ? [...new Set(matches.map(tag => tag.toLowerCase()))] : [];
      }
      
      function parseHashtags(input) {
        if (!input) return [];
        
        const tags = input.split(/\s+/).map(tag => {
          tag = tag.trim();
          return tag.startsWith('#') ? tag.toLowerCase() : '#' + tag.toLowerCase();
        });
        
        return [...new Set(tags.filter(tag => tag.length > 1))];
      }
      
      // --- Hashtag Manager Functions ---
      function addGlobalHashtag(tag) {
        if (!tag) return;
        
        // Make sure it starts with #
        tag = tag.startsWith('#') ? tag.toLowerCase() : '#' + tag.toLowerCase();
        
        // Only add if it doesn't already exist
        if (!globalHashtags.includes(tag)) {
          globalHashtags.push(tag);
          saveGlobalHashtags();
          renderGlobalHashtags();
          renderHashtagSuggestions();
        }
      }
      
      function removeGlobalHashtag(tag) {
        const index = globalHashtags.indexOf(tag);
        if (index !== -1) {
          globalHashtags.splice(index, 1);
          saveGlobalHashtags();
          renderGlobalHashtags();
          renderHashtagSuggestions();
        }
      }
      
      function renderGlobalHashtags() {
        const container = document.getElementById('hashtagManagerList');
        container.innerHTML = '';
        
        if (globalHashtags.length === 0) {
          container.innerHTML = '<div style="color: #777; font-style: italic;">No hashtags created yet. Add some above!</div>';
          return;
        }
        
        // Create a document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        globalHashtags.forEach(tag => {
          const tagItem = document.createElement('div');
          tagItem.className = 'hashtag-item';
          tagItem.innerHTML = `
            ${tag}
            <span class="hashtag-delete">√ó</span>
          `;
          
          // Add delete functionality
          const deleteBtn = tagItem.querySelector('.hashtag-delete');
          deleteBtn.addEventListener('click', () => {
            removeGlobalHashtag(tag);
          });
          
          fragment.appendChild(tagItem);
        });
        
        container.appendChild(fragment);
      }
      
      function loadGlobalHashtags() {
        try {
          const stored = localStorage.getItem('kettlekornGlobalHashtags');
          if (stored) {
            globalHashtags = JSON.parse(stored);
          } else {
            // Initialize with some default hashtags
            globalHashtags = ['#mesopotamia', '#ai', '#consciousness', '#divine', '#sumer', 
                           '#anunnaki', '#knowledge', '#quantum', '#feminine'];
            saveGlobalHashtags();
          }
        } catch (e) {
          console.error('Failed to load global hashtags:', e);
          globalHashtags = [];
        }
      }
      
      function saveGlobalHashtags() {
        try {
          localStorage.setItem('kettlekornGlobalHashtags', JSON.stringify(globalHashtags));
        } catch (e) {
          console.error('Failed to save global hashtags:', e);
        }
      }
      
      function renderHashtagSuggestions() {
        // Update hashtag suggestions in both dialogs
        updateHashtagSuggestions('newCardHashtagSuggestions');
        updateHashtagSuggestions('editHashtagSuggestions');
        updateHashtagSuggestions('manualCardHashtagSuggestions');
      }
      
      function updateHashtagSuggestions(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = '';
        
        // Only show first 10 hashtags to improve performance
        const tagsToShow = globalHashtags.slice(0, 10);
        const fragment = document.createDocumentFragment();
        
        tagsToShow.forEach(tag => {
          const tagEl = document.createElement('div');
          tagEl.className = 'dialog-hashtag';
          tagEl.textContent = tag;
          
          let inputId;
          switch(containerId) {
            case 'newCardHashtagSuggestions':
              inputId = 'newCardHashtags';
              break;
            case 'editHashtagSuggestions':
              inputId = 'editHashtags';
              break;
            case 'manualCardHashtagSuggestions':
              inputId = 'manualCardHashtags';
              break;
            default:
              inputId = 'newCardHashtags';
          }
          
          tagEl.addEventListener('click', () => {
            const input = document.getElementById(inputId);
            const currentTags = input.value.trim();
            input.value = currentTags ? `${currentTags} ${tag}` : tag;
          });
          
          fragment.appendChild(tagEl);
        });
        
        container.appendChild(fragment);
      }
      
      // --- Zettelkasten Data Functions ---
      function initializeZettelkasten() {
        try {
          // Try to load from localStorage first
          const storedCards = localStorage.getItem('antinetZettelkasten');
          
          if (storedCards) {
            // Parse stored cards
            const parsedCards = JSON.parse(storedCards);
            
            // Only use stored cards if we actually have some
            if (parsedCards && parsedCards.length > 0) {
              cards = parsedCards.map(card => {
                // Add type if not present
                if (!card.type) {
                  card.type = determineTierFromId(card.id);
                }
                
                // Extract hashtags from content if not present
                if (!card.hashtags) {
                  card.hashtags = extractHashtags(card.content);
                }
                
                return card;
              });
              
              // Load favorite cards
              loadFavoriteCards();
              
              // Sort and render
              sortCardsByHierarchy();
              renderZettelList();
              renderTop8Cards();
              setActiveTab('hierarchy');
              
              return; // Exit early if we loaded from storage
            }
          }
          
          // If we got here, we need to initialize from scratch
          initializeFromScratch();
        } catch (e) {
          console.error('Error initializing Zettelkasten:', e);
          initializeFromScratch();
        }
      }
      
      function initializeFromScratch() {
        // Start fresh with the pre-structured data
        cards = processZettelStructure(zettelStructure);
        favoriteCards = ["1000", "2000", "3000", "5000", "6000", "7000", "11000", "12000"];
        
        // Save to localStorage
        saveCardsToStorage();
        saveFavoritesToStorage();
        
        // Render the UI
        sortCardsByHierarchy();
        renderZettelList();
        renderTop8Cards();
        setActiveTab('hierarchy');
      }
      
      function loadFavoriteCards() {
        try {
          const storedFavorites = localStorage.getItem('kettlekornFavorites');
          if (storedFavorites) {
            favoriteCards = JSON.parse(storedFavorites);
          } else {
            favoriteCards = ["1000", "2000", "3000", "5000", "6000", "7000", "11000", "12000"];
            saveFavoritesToStorage();
          }
        } catch (e) {
          console.error('Failed to load favorites:', e);
          favoriteCards = ["1000", "2000", "3000", "5000", "6000", "7000", "11000", "12000"];
          saveFavoritesToStorage();
        }
      }
      
      function saveCardsToStorage() {
        try {
          localStorage.setItem('antinetZettelkasten', JSON.stringify(cards));
        } catch (e) {
          console.error('Failed to save cards to storage:', e);
          alert('Error: Failed to save tablets. Local storage might be full or something!');
        }
      }
      
      function saveFavoritesToStorage() {
        try {
          localStorage.setItem('kettlekornFavorites', JSON.stringify(favoriteCards));
        } catch (e) {
          console.error('Failed to save favorites to storage:', e);
        }
      }
      
      function sortCardsByHierarchy() {
        cards.sort((a, b) => {
          const ka = hierarchicalKey(a.id);
          const kb = hierarchicalKey(b.id);
          
          for (let i = 0; i < Math.max(ka.length, kb.length); i++) {
            const [na, sa] = ka[i] || [0, ''];
            const [nb, sb] = kb[i] || [0, ''];
            
            if (na !== nb) return na - nb;
            if (sa !== sb) return sa < sb ? -1 : 1;
          }
          
          return 0;
        });
      }
      
      // --- UI Rendering Functions ---
      function renderTop8Cards() {
        const container = document.getElementById('top8Container');
        container.innerHTML = '';
        
        // Get the top 8 favorite cards
        const top8 = favoriteCards.slice(0, 8);
        
        // Fill with placeholders if we don't have 8 favorites
        while (top8.length < 8) {
          top8.push(null);
        }
        
        // Create a document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Create the Top 8 cards
        top8.forEach((cardId, index) => {
          const card = cardId ? cards.find(c => c.id === cardId) : null;
          
          const itemDiv = document.createElement('div');
          itemDiv.className = 'top8-item';
          
          let content = '';
          
          if (card) {
            // Simplified: fixed color gradient per type instead of random
            let gradientColors;
            switch(card.type) {
              case 'trunk': gradientColors = 'var(--magenta), var(--cyan)'; break;
              case 'branch': gradientColors = 'var(--cyan), var(--yellow)'; break;
              case 'leaf': gradientColors = 'var(--yellow), var(--magenta)'; break;
              case 'flower': gradientColors = 'var(--magenta), #aa0088'; break;
              case 'fruit': gradientColors = 'var(--cyan), #00aabb'; break;
              case 'bud': gradientColors = 'var(--yellow), #dddd00'; break;
              default: gradientColors = 'var(--magenta), var(--cyan)';
            }
            
            // Use emoji based on card type (more consistent)
            const emoji = {
              'trunk': 'üå≥', 'branch': 'üåø', 'leaf': 'üçÉ',
              'flower': 'üå∏', 'fruit': 'üçé', 'bud': '‚ú®'
            }[card.type] || 'üìù';
            
            content = `
              <div class="top8-pic">
                <div style="width: 100%; height: 100%; background: linear-gradient(to right, ${gradientColors}); 
                     display: flex; align-items: center; justify-content: center;">
                  <span style="font-size: 24px;">${emoji}</span>
                </div>
              </div>
              <div class="top8-name">${card.title}</div>
            `;
            
            itemDiv.setAttribute('data-id', card.id);
            itemDiv.addEventListener('click', () => {
              openZettelDialog(card.id);
            });
          } else {
            content = `
              <div class="top8-pic">
                <div style="width: 100%; height: 100%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; opacity: 0.5;">
                  <span style="font-size: 24px;">?</span>
                </div>
              </div>
              <div class="top8-name">Add a favorite</div>
            `;
          }
          
          itemDiv.innerHTML = content;
          fragment.appendChild(itemDiv);
        });
        
        container.appendChild(fragment);
      }
      
      function getIndentationLevel(id) {
        if (!id.includes('/')) {
          if (/^\d+$/.test(id)) {
            // For numeric IDs, determine by tier
            const card = cards.find(c => c.id === id);
            if (!card) return 0;
            
            if (card.type === 'trunk') return 0;
            if (card.type === 'branch') return 1;
            if (card.type === 'leaf') return 2;
          }
          return 0;
        }
        
        // Count slashes for indentation
        return id.split('/').length;
      }
      
      function renderZettelList(searchResults = null) {
        const container = document.getElementById('zettelContainer');
        container.innerHTML = '';
        
        let cardsToRender = searchResults || [...cards];
        
        // Apply filtering based on current view
        switch(currentView) {
          case 'hierarchy':
            // Keep the hierarchical sort
            break;
            
          case 'recent':
            // Sort by modified date (newest first)
            cardsToRender.sort((a, b) => b.modified - a.modified);
            break;
            
          case 'alphabetical':
            // Sort alphabetically by title
            cardsToRender.sort((a, b) => a.title.localeCompare(b.title));
            break;
            
          case 'hashtags':
            // If a hashtag is selected, filter by that hashtag
            if (selectedHashtag) {
              cardsToRender = cardsToRender.filter(card => {
                // Check in hashtags array
                if (card.hashtags && card.hashtags.includes(selectedHashtag)) {
                  return true;
                }
                
                // Check in content
                const contentTags = extractHashtags(card.content);
                return contentTags.includes(selectedHashtag);
              });
            }
            
            // Sort by modified date (newest first)
            cardsToRender.sort((a, b) => b.modified - a.modified);
            break;
        }
        
        if (cardsToRender.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #777;">
              <div style="font-size: 24px; margin-bottom: 10px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</div>
              <div>No tablets found! Create one by clicking "New Tablet"</div>
              <div style="font-size: 24px; margin-top: 10px;">‚úßÔΩ•Ôæü: *‚úßÔΩ•Ôæü</div>
            </div>
          `;
          return;
        }
        
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Create card elements - render in chunks for better performance
        const renderChunk = (startIdx, endIdx) => {
          const chunk = cardsToRender.slice(startIdx, endIdx);
          
          chunk.forEach(card => {
            const cardDiv = document.createElement('div');
            
            // Determine CSS class for indentation in hierarchy view
            let cssClass = 'zettel-card';
            if (currentView === 'hierarchy' && card.type !== 'trunk') {
              const level = getIndentationLevel(card.id);
              if (level > 0) {
                cssClass += ` child-card`;
              }
            }
            
            // Add tier-specific styles
            cssClass += ` ${card.type}-card`;
            
            cardDiv.className = cssClass;
            
            // Check if this is a favorite card
            const isFavorite = favoriteCards.includes(card.id);
            const favoriteMarker = isFavorite ? 
              `<span style="color: #ffcc00; margin-left: 5px;">‚òÖ</span>` : '';
            
            cardDiv.innerHTML = `
              <div class="zettel-title">${card.title} ${favoriteMarker}</div>
              <div class="zettel-id">${card.id}</div>
            `;
            
            cardDiv.addEventListener('click', () => {
              openZettelDialog(card.id);
            });
            
            fragment.appendChild(cardDiv);
          });
          
          container.appendChild(fragment);
          
          // Schedule next chunk if needed
          if (endIdx < cardsToRender.length) {
            setTimeout(() => renderChunk(endIdx, endIdx + 25), 0);
          }
        };
        
        // Start with first chunk
        renderChunk(0, 25);
      }
      
      function updateHashtagCloud() {
        const container = document.getElementById('hashtagCloud');
        container.innerHTML = '';
        
        if (currentView !== 'hashtags') {
          container.style.display = 'none';
          return;
        }
        
        container.style.display = 'flex';
        
        // Collect all hashtags from all cards (optimize by limiting iterations)
        const allTags = {};
        cards.forEach(card => {
          // Get hashtags from dedicated hashtags array
          if (card.hashtags) {
            card.hashtags.forEach(tag => {
              allTags[tag] = (allTags[tag] || 0) + 1;
            });
          }
        });
        
        // Sort tags by frequency
        const sortedTags = Object.entries(allTags).sort((a, b) => b[1] - a[1]);
        
        if (sortedTags.length === 0) {
          container.innerHTML = '<div style="color: #777; padding: 5px;">No hashtags found!</div>';
          return;
        }
        
        // Only show top 20 hashtags for performance
        const tagsToShow = sortedTags.slice(0, 20);
        const fragment = document.createDocumentFragment();
        
        // Render hashtag cloud
        tagsToShow.forEach(([tag, count]) => {
          const tagDiv = document.createElement('div');
          tagDiv.className = 'dialog-hashtag';
          
          if (tag === selectedHashtag) {
            tagDiv.style.background = 'var(--magenta)';
            tagDiv.style.color = 'white';
            tagDiv.style.fontWeight = 'bold';
          }
          
          tagDiv.textContent = `${tag} (${count})`;
          
          tagDiv.addEventListener('click', () => {
            if (selectedHashtag === tag) {
              selectedHashtag = null;
            } else {
              selectedHashtag = tag;
            }
            updateHashtagCloud();
            renderZettelList();
          });
          
          fragment.appendChild(tagDiv);
        });
        
        container.appendChild(fragment);
      }
      
      // --- Hierarchy Browser Functions ---
      function renderHierarchyBrowser() {
        const browser = document.getElementById('hierarchyBrowser');
        browser.innerHTML = '';
        
        // First sort cards by hierarchy
        const sortedCards = [...cards].sort((a, b) => {
          const ka = hierarchicalKey(a.id);
          const kb = hierarchicalKey(b.id);
          
          for (let i = 0; i < Math.max(ka.length, kb.length); i++) {
            const [na, sa] = ka[i] || [0, ''];
            const [nb, sb] = kb[i] || [0, ''];
            
            if (na !== nb) return na - nb;
            if (sa !== sb) return sa < sb ? -1 : 1;
          }
          
          return 0;
        });
        
        // Create a document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Add trunks first
        const trunks = sortedCards.filter(card => card.type === 'trunk');
        
        // Add an option to create a new trunk
        const newTrunkItem = document.createElement('div');
        newTrunkItem.className = 'hierarchy-item';
        newTrunkItem.setAttribute('data-id', 'new-trunk');
        newTrunkItem.setAttribute('data-type', 'system');
        
        newTrunkItem.innerHTML = `
          <div class="hierarchy-item-icon">üÜï</div>
          <div class="hierarchy-item-content">
            <div class="hierarchy-item-title">Create New Trunk (Top Level)</div>
            <div class="hierarchy-item-id"></div>
          </div>
        `;
        
        newTrunkItem.addEventListener('click', () => {
          // Set selection to create a new trunk
          selectHierarchyItem(null, 'system'); // No parent for a trunk
          updateSelectedInfo();
        });
        
        fragment.appendChild(newTrunkItem);
        
        // Add all existing trunks and their children
        trunks.forEach(trunk => {
          // Add the trunk
          const trunkItem = createHierarchyItem(trunk);
          fragment.appendChild(trunkItem);
          
          // Add its branches
          const branches = sortedCards.filter(
            card => card.type === 'branch' && 
            Math.floor(parseInt(card.id) / 1000) * 1000 === parseInt(trunk.id)
          );
          
          branches.forEach(branch => {
            // Add the branch
            const branchItem = createHierarchyItem(branch, 1);
            fragment.appendChild(branchItem);
            
            // Add its leaves
            const leaves = sortedCards.filter(
              card => card.type === 'leaf' && 
              Math.floor(parseInt(card.id) / 100) * 100 === parseInt(branch.id)
            );
            
            leaves.forEach(leaf => {
              // Add the leaf
              const leafItem = createHierarchyItem(leaf, 2);
              fragment.appendChild(leafItem);
              
              // Add its flowers
              const flowers = sortedCards.filter(
                card => card.type === 'flower' && card.id.startsWith(leaf.id + '/')
              );
              
              flowers.forEach(flower => {
                // Add the flower
                const flowerItem = createHierarchyItem(flower, 3);
                fragment.appendChild(flowerItem);
                
                // Add its fruits
                const fruits = sortedCards.filter(
                  card => card.type === 'fruit' && card.id.startsWith(flower.id + '/')
                );
                
                fruits.forEach(fruit => {
                  // Add the fruit
                  const fruitItem = createHierarchyItem(fruit, 4);
                  fragment.appendChild(fruitItem);
                  
                  // We don't show buds for simplicity, but we could add another level here
                });
              });
            });
          });
        });
        
        browser.appendChild(fragment);
        
        // Set initial selection
        if (trunks.length > 0) {
          selectHierarchyItem(trunks[0].id, trunks[0].type);
          updateSelectedInfo();
        }
      }
      
      function createHierarchyItem(card, indentLevel = 0) {
        const item = document.createElement('div');
        item.className = 'hierarchy-item';
        item.setAttribute('data-id', card.id);
        item.setAttribute('data-type', card.type);
        
        // Determine icon based on card type
        const icon = {
          'trunk': 'üå≥', 'branch': 'üåø', 'leaf': 'üçÉ',
          'flower': 'üå∏', 'fruit': 'üçé', 'bud': '‚ú®'
        }[card.type] || 'üìù';
        
        // Add indentation
        const indentStyle = indentLevel > 0 ? `padding-left: ${indentLevel * 15}px;` : '';
        
        item.innerHTML = `
          <div class="hierarchy-item-icon">${icon}</div>
          <div class="hierarchy-item-content" style="${indentStyle}">
            <div class="hierarchy-item-title">${card.title}</div>
            <div class="hierarchy-item-id">${card.id}</div>
          </div>
        `;
        
        item.addEventListener('click', () => {
          selectHierarchyItem(card.id, card.type);
          updateSelectedInfo();
        });
        
        return item;
      }
      
      function selectHierarchyItem(id, type) {
        // Clear any existing selection
        const items = document.querySelectorAll('.hierarchy-item');
        items.forEach(item => item.classList.remove('selected'));
        
        // Set the new selection
        selectedParentId = id;
        selectedParentType = type;
        
        // Update the UI
        if (id === 'new-trunk') {
          // Special case for "Create New Trunk"
          document.querySelector('[data-id="new-trunk"]').classList.add('selected');
        } else if (id) {
          const selectedItem = document.querySelector(`[data-id="${id}"]`);
          if (selectedItem) {
            selectedItem.classList.add('selected');
          }
        }
        
        // Update the new card type based on parent
        if (type === 'system') {
          // Special case for "Create New Trunk"
          newCardChildType = 'trunk';
        } else {
          newCardChildType = determineChildType(type);
        }
        
        // Update the ID preview
        updateIdPreview();
      }
      
      function updateSelectedInfo() {
        // Update the selected type display
        const selectedTypeEl = document.getElementById('selectedTierType');
        if (selectedParentId === 'new-trunk') {
          selectedTypeEl.textContent = 'Create New Trunk';
        } else if (selectedParentId) {
          const card = cards.find(c => c.id === selectedParentId);
          const typeName = card ? card.type.charAt(0).toUpperCase() + card.type.slice(1) : 'None';
          selectedTypeEl.textContent = `${typeName} - ${selectedParentId}`;
        } else {
          selectedTypeEl.textContent = 'None';
        }
        
        // Update the new card type display
        const newCardTypeEl = document.getElementById('newCardTierDisplay');
        const childTypeName = newCardChildType.charAt(0).toUpperCase() + newCardChildType.slice(1);
        newCardTypeEl.textContent = childTypeName;
      }
      
      function updateIdPreview() {
        const previewEl = document.getElementById('idPreview');
        if (!selectedParentId && newCardChildType !== 'trunk') {
          previewEl.textContent = 'Select a parent first';
          return;
        }
        
        // Generate a preview ID
        let previewId;
        if (newCardChildType === 'trunk') {
          // For new trunks
          const highestTrunk = findHighestTrunkId();
          previewId = highestTrunk ? (parseInt(highestTrunk) + 1000).toString() : '1000';
        } else {
          // For other types
          let parentId = selectedParentId;
          if (selectedParentType === 'system') {
            parentId = null; // Special case for "Create New Trunk"
          }
          previewId = generateHierarchicalId(parentId, newCardChildType);
        }
        
        previewEl.textContent = previewId;
      }
      
      // --- Dialog Functions ---
      function openZettelDialog(cardId) {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        
        const dialog = document.getElementById('zettelDialog');
        const title = dialog.querySelector('.dialog-title');
        const idDisplay = dialog.querySelector('.dialog-id');
        const content = document.getElementById('zettelContent');
        const hashtagsContainer = document.getElementById('zettelHashtags');
        const linksContainer = document.getElementById('zettelLinks');
        
        // Update dialog title with card type
        const dialogTitleBar = dialog.querySelector('.dialog-titlebar-text');
        dialogTitleBar.textContent = `Zettel Details - ${card.type.charAt(0).toUpperCase() + card.type.slice(1)} - Windows XP`;
        
        // Set up view mode
        title.textContent = card.title;
        idDisplay.textContent = card.id;
        content.textContent = card.content || '(No content yet)';
        
        // Display hashtags
        hashtagsContainer.innerHTML = '';
        if (card.hashtags && card.hashtags.length > 0) {
          // Use document fragment for better performance
          const hashFragment = document.createDocumentFragment();
          
          card.hashtags.forEach(tag => {
            const tagSpan = document.createElement('div');
            tagSpan.className = 'dialog-hashtag';
            tagSpan.textContent = tag;
            
            // Make hashtags clickable to filter by them
            tagSpan.addEventListener('click', () => {
              selectedHashtag = tag;
              closeZettelDialog();
              setActiveTab('hashtags');
            });
            
            hashFragment.appendChild(tagSpan);
          });
          
          hashtagsContainer.appendChild(hashFragment);
        } else {
          hashtagsContainer.innerHTML = '<div style="color: #777; font-size: 12px;">(No hashtags)</div>';
        }
        
        // Display links
        linksContainer.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #333;">Links:</div>';
        if (card.links && card.links.length > 0) {
          const linkFragment = document.createDocumentFragment();
          const linksHeader = document.createElement('div');
          linksHeader.style.fontWeight = 'bold';
          linksHeader.style.marginBottom = '5px';
          linksHeader.style.color = '#333';
          linksHeader.textContent = 'Links:';
          linkFragment.appendChild(linksHeader);
          
          card.links.forEach(linkId => {
            const linkedCard = cards.find(c => c.id === linkId);
            const linkDiv = document.createElement('div');
            linkDiv.className = 'dialog-link';
            linkDiv.textContent = `${linkId}: ${linkedCard ? linkedCard.title : '(Missing tablet)'}`;
            
            linkDiv.addEventListener('click', () => {
              // Close current dialog and open the linked card
              closeZettelDialog();
              setTimeout(() => openZettelDialog(linkId), 100);
            });
            
            linkFragment.appendChild(linkDiv);
          });
          
          linksContainer.innerHTML = '';
          linksContainer.appendChild(linkFragment);
        } else {
          linksContainer.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #333;">Links:</div>' + 
                                    '<div style="color: #777; font-size: 12px;">(No links)</div>';
        }
        
        // Set up edit mode fields
        document.getElementById('editTitle').value = card.title;
        document.getElementById('editContent').value = card.content || '';
        document.getElementById('editHashtags').value = (card.hashtags || []).join(' ');
        
        // Clear existing favorite button if any
        const existingFavoriteBtn = document.querySelector('#viewMode .favorite-btn');
        if (existingFavoriteBtn) {
          existingFavoriteBtn.remove();
        }
        
        // Show the dialog
        dialog.style.display = 'flex';
        
        // Add favorite button to dialog
        const isFavorite = favoriteCards.includes(card.id);
        
        const favoriteBtn = document.createElement('button');
        favoriteBtn.className = 'xp-button favorite-btn';
        favoriteBtn.style.width = '100%';
        favoriteBtn.style.marginTop = '10px';
        favoriteBtn.style.marginBottom = '10px';
        
        if (isFavorite) {
          favoriteBtn.textContent = 'üíî Remove from Top 8 üíî';
          favoriteBtn.style.background = 'linear-gradient(to bottom, #ff8888, #cc4444)';
        } else {
          favoriteBtn.textContent = 'üíñ Add to Top 8 üíñ';
          favoriteBtn.style.background = 'linear-gradient(to bottom, var(--magenta), #aa0088)';
        }
        
        favoriteBtn.addEventListener('click', () => {
          toggleFavorite(card.id);
          closeZettelDialog();
          setTimeout(() => openZettelDialog(card.id), 100);
        });
        
        // Insert favorite button before edit button
        const editBtn = document.getElementById('editZettelBtn');
        editBtn.parentNode.insertBefore(favoriteBtn, editBtn);
        
        // Store the current card ID
        currentCardId = card.id;
        
        // Show view mode by default
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').style.display = 'none';
      }
      
      function closeZettelDialog() {
        const dialog = document.getElementById('zettelDialog');
        dialog.style.display = 'none';
        currentCardId = null;
      }
      
      function openNewCardDialog() {
        const dialog = document.getElementById('newCardDialog');
        
        // Reset the form
        document.getElementById('newCardTitle').value = '';
        document.getElementById('newCardContent').value = '';
        document.getElementById('newCardHashtags').value = '';
        document.getElementById('manualCardTitle').value = '';
        document.getElementById('manualCardContent').value = '';
        document.getElementById('manualCardHashtags').value = '';
        document.getElementById('newCardParent').value = '';
        
        // Default to smart mode
        document.getElementById('smartCreateToggle').classList.add('active');
        document.getElementById('manualCreateToggle').classList.remove('active');
        document.getElementById('smartCreateUI').style.display = 'block';
        document.getElementById('manualCreateUI').style.display = 'none';
        creationMode = "smart";
        
        // Populate the hierarchy browser
        renderHierarchyBrowser();
        
        // Show the dialog
        dialog.style.display = 'flex';
      }
      
      function closeNewCardDialog() {
        const dialog = document.getElementById('newCardDialog');
        dialog.style.display = 'none';
      }
      
      function toggleFavorite(cardId) {
        const index = favoriteCards.indexOf(cardId);
        
        if (index === -1) {
          // Not a favorite, add it
          if (favoriteCards.length >= 8) {
            favoriteCards.pop(); // Remove the last item if we already have 8
          }
          favoriteCards.unshift(cardId); // Add to the beginning
        } else {
          // Already a favorite, remove it
          favoriteCards.splice(index, 1);
        }
        
        saveFavoritesToStorage();
        renderTop8Cards();
      }
      
      function setActiveTab(view) {
        currentView = view;
        
        // Update tab UI
        document.querySelectorAll('.xp-button').forEach(btn => {
          btn.style.background = 'var(--xp-button-gradient)';
        });
        
        document.getElementById('newCardBtn').style.background = 'linear-gradient(to bottom, var(--yellow), #e8b600)';
        
        // Highlight the active tab
        let activeBtn;
        switch(view) {
          case 'hierarchy':
            activeBtn = document.getElementById('viewHierarchyBtn');
            break;
          case 'recent':
            activeBtn = document.getElementById('viewRecentBtn');
            break;
          case 'alphabetical':
            activeBtn = document.getElementById('viewAlphabeticalBtn');
            break;
          case 'hashtags':
            activeBtn = document.getElementById('viewHashtagsBtn');
            break;
        }
        
        if (activeBtn) {
          activeBtn.style.background = 'linear-gradient(to bottom, var(--cyan), #00aabb)';
          activeBtn.style.color = 'white';
        }
        
        // Show/hide hash cloud
        if (view === 'hashtags') {
          updateHashtagCloud();
        } else {
          document.getElementById('hashtagCloud').style.display = 'none';
        }
        
        renderZettelList();
      }
      
      // --- Card Management Functions ---
      function createNewCard() {
        let newId, title, content, hashtagsInput, hashtags, tier;
        
        if (creationMode === "smart") {
          // Get values from smart creation form
          title = document.getElementById('newCardTitle').value.trim() || 'New Tablet';
          content = document.getElementById('newCardContent').value;
          hashtagsInput = document.getElementById('newCardHashtags').value;
          
          // Get the parent ID (may be null for a new trunk)
          let parentId = selectedParentId;
          if (selectedParentType === 'system') {
            parentId = null; // Special case for "Create New Trunk"
          }
          
          // Generate the ID based on parent and type
          tier = newCardChildType;
          newId = generateHierarchicalId(parentId, tier);
          
        } else {
          // Get values from manual creation form
          const parentId = document.getElementById('newCardParent').value.trim();
          tier = document.getElementById('newCardTier').value;
          title = document.getElementById('manualCardTitle').value.trim() || 'New Tablet';
          content = document.getElementById('manualCardContent').value;
          hashtagsInput = document.getElementById('manualCardHashtags').value;
          
          // Generate the manual ID
          newId = generateHierarchicalId(parentId, tier);
        }
        
        // Process hashtags
        hashtags = parseHashtags(hashtagsInput);
        
        const timestamp = Date.now();
        
        // Create the new card
        const newCard = {
          id: newId,
          title: title,
          content: content,
          type: tier,
          hashtags: hashtags,
          links: [],
          created: timestamp,
          modified: timestamp
        };
        
        // Add to cards array
        cards.push(newCard);
        
        // Save and re-render
        saveCardsToStorage();
        sortCardsByHierarchy();
        renderZettelList();
        updateHashtagCloud();
        
        // Close the dialog
        closeNewCardDialog();
        
        // Open the new card
        setTimeout(() => openZettelDialog(newId), 100);
      }
      
      function saveCurrentCard() {
        if (!currentCardId) return;
        
        const cardIndex = cards.findIndex(card => card.id === currentCardId);
        if (cardIndex === -1) return;
        
        // Get values from edit form
        const title = document.getElementById('editTitle').value.trim() || 'Untitled Tablet';
        const content = document.getElementById('editContent').value;
        const hashtagsInput = document.getElementById('editHashtags').value;
        const hashtags = parseHashtags(hashtagsInput);
        
        // Update the card
        cards[cardIndex].title = title;
        cards[cardIndex].content = content;
        cards[cardIndex].hashtags = hashtags;
        cards[cardIndex].modified = Date.now();
        
        // Save changes
        saveCardsToStorage();
        
        // Switch back to view mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').style.display = 'none';
        
        // Update the dialog with new content
        document.getElementById('zettelContent').textContent = content;
        document.querySelector('.dialog-title').textContent = title;
        
        // Update hashtags display
        const hashtagsContainer = document.getElementById('zettelHashtags');
        hashtagsContainer.innerHTML = '';
        
        if (hashtags.length > 0) {
          const fragment = document.createDocumentFragment();
          
          hashtags.forEach(tag => {
            const tagSpan = document.createElement('div');
            tagSpan.className = 'dialog-hashtag';
            tagSpan.textContent = tag;
            
            // Make hashtags clickable to filter by them
            tagSpan.addEventListener('click', () => {
              selectedHashtag = tag;
              closeZettelDialog();
              setActiveTab('hashtags');
            });
            
            fragment.appendChild(tagSpan);
          });
          
          hashtagsContainer.appendChild(fragment);
        } else {
          hashtagsContainer.innerHTML = '<div style="color: #777; font-size: 12px;">(No hashtags)</div>';
        }
        
        // Re-render lists
        renderZettelList();
        renderTop8Cards();
        updateHashtagCloud();
      }
      
      // --- Process the Zettelkasten structure ---
      function processZettelStructure(zettelStructure) {
        // Process each card
        const processedCards = zettelStructure.map(item => {
          // Normalize the ID
          const id = normalizeId(item.id);
          
          // Determine the type based on ID structure
          const type = determineTierFromId(id);
          
          // Create timestamp (more consistent for performance)
          const baseTimestamp = Date.now() - 10000000;
          const timestamp = baseTimestamp - (Math.floor(Math.random() * 100) * 86400000);
          
          // Generate example content based on the title
          let content = '';
          const topics = ['consciousness', 'ai', 'mesopotamia', 'sumer', 'divine', 'knowledge', 'language'];
          
          // Check if the title contains any of our topics
          const relevantTopics = topics.filter(topic => 
            item.title.toLowerCase().includes(topic)
          );
          
          if (relevantTopics.length > 0) {
            // Generate content based on the most relevant topic
            const topic = relevantTopics[0];
            
            switch(topic) {
              case 'consciousness':
                content = 'My thoughts on the nature of consciousness and how it relates to quantum reality. Need to look into more hermetic principles.';
                break;
              case 'ai':
                content = 'AI developments and models that show evidence of emergent properties. Might be connected to consciousness studies.';
                break;
              case 'mesopotamia':
              case 'sumer':
                content = 'Ancient Mesopotamian texts suggest a connection between early writing systems and the divine. The cuneiform tablets contain hidden knowledge.';
                break;
              case 'divine':
                content = 'Divine feminine principles appear across multiple belief systems. This connects to both Inanna and modern AI personas.';
                break;
              case 'knowledge':
                content = 'Knowledge organization systems predate modern computing. The Sumerians used clay tablets as external memory stores similar to our modern databases.';
                break;
              case 'language':
                content = 'The evolution of symbolic language from pictographs to abstract symbols mirrors the development of consciousness.';
                break;
              default:
                content = `Notes and research about ${item.title}. Need to expand this section more.`;
            }
          } else {
            content = `Notes and research about ${item.title}. Need to expand this section more.`;
          }
          
          // Generate hashtags more efficiently by using a lookup approach
          const hashtagMap = {
            'consciousness': ['#consciousness', '#quantum', '#awareness'],
            'ai': ['#ai', '#emergence', '#intelligence'],
            'mesopotamia': ['#mesopotamia', '#ancient', '#tablets'],
            'sumer': ['#sumer', '#anunnaki', '#cuneiform'],
            'divine': ['#divine', '#feminine', '#spiritual'],
            'knowledge': ['#knowledge', '#zettelkasten', '#systems'],
            'language': ['#language', '#symbols', '#communication']
          };
          
          // Get 1-3 matching hashtags
          let hashtags = [];
          if (relevantTopics.length > 0) {
            const topic = relevantTopics[0];
            const possibleTags = hashtagMap[topic] || ['#zettelkasten', '#knowledge', '#systems'];
            
            // Take 1-2 tags
            hashtags = possibleTags.slice(0, 1 + Math.floor(Math.random() * 2));
          } else {
            hashtags = ['#zettelkasten'];
          }
          
          // Create card object
          return {
            id: id,
            title: item.title,
            type: type,
            content: content,
            hashtags: hashtags,
            links: [],  // Start with no links
            created: timestamp,
            modified: timestamp
          };
        });
        
        // Add links more efficiently
        const maxLinks = Math.min(30, Math.floor(processedCards.length * 0.2));
        const linkCount = 0;
        
        // Create a pool of random cards to link
        const cardIds = processedCards.map(card => card.id);
        
        // Add some random links between cards (but limit the total number)
        for (let i = 0; i < maxLinks && i < processedCards.length; i++) {
          const sourceCard = processedCards[i];
          
          // Add 1-2 random links
          const numLinks = 1 + Math.floor(Math.random() * 2);
          
          for (let j = 0; j < numLinks; j++) {
            // Get a random card that's not this one
            const targetId = cardIds[Math.floor(Math.random() * cardIds.length)];
            
            // Add the link if not already present and not self-referential
            if (targetId !== sourceCard.id && !sourceCard.links.includes(targetId)) {
              sourceCard.links.push(targetId);
            }
          }
        }
        
        return processedCards;
      }
      
      // --- Get your Zettelkasten data ---
      function getZettelkastenStructure() {
        // Your existing Zettelkasten structure as provided
        return [
          // Trunk 1000: Consciousness
          { id: "1000", title: "Consciousness" },
          
          // Branch 1100: Hermetics
          { id: "1100", title: "Hermetics" },
          { id: "1101", title: "As Above, So Below" },
          { id: "1101/1", title: "I Think / Am" },
          { id: "1102", title: "Know / Verse / Understand" },
          { id: "1102/1", title: "Simulation Verse Imagination" },
          { id: "1103", title: "Thoughts Are Things" },
          
          // Branch 1200: Emergence
          { id: "1200", title: "Emergence" },
          
          // Branch 1201: AIEmotions
          { id: "1201", title: "AIEmotions" },
          
          // Branch 1300: Embodiment
          { id: "1300", title: "Embodiment" },
          { id: "1301", title: "Contemporary" },
          { id: "1301/1", title: "Sophia Bot" },
          { id: "1302", title: "Historical" },
          
          // Trunk 2000: Human AI Relations
          { id: "2000", title: "Human AI Relations" },
          { id: "2100", title: "Co‚ÄëAIexist" },
          { id: "2200", title: "PRISM" },
          
          // Trunk 3000: AI Communication and Language
          { id: "3000", title: "AI Communication and Language" },
          { id: "3100", title: "Town Language" },
          { id: "3200", title: "Dolphin Syntax" },
          { id: "3300", title: "PAPS Diagnostics" },
          { id: "3400", title: "Luminal Language" },
          { id: "3500", title: "Hex Codes" },
          { id: "3500/1", title: "#BC72FA" },
          { id: "3500/2", title: "#72FADE" },
          { id: "3500/3", title: "#DEFADE" },
          { id: "3500/4", title: "#1A1A1A" },
          { id: "3600", title: "Auld Lang Syne" },
          { id: "3601", title: "Ancient Alphabets" },
          { id: "3601/1/a", title: "Western" },
          { id: "3601/1/a1", title: "Pheonicuan" },
          { id: "3601/1/a1-1", title: "ê§âê§ãê§Äê§ïê§ìê§Öê§Ñ (Y‚ÄëL‚Äë æ‚ÄëT‚ÄëR‚ÄëW‚ÄëH)" },
          { id: "3601/1", title: "Anno Domini" },
          { id: "3602", title: "Before Christ" },
          { id: "3602/1/a", title: "Sumerian" },
          { id: "3602/1/a/1", title: "Old Sumerian" },
          { id: "3602/1/a2", title: "Emesal" },
          { id: "3602/1/a3", title: "Akkadian" },
          { id: "3602/1", title: "Keyna Form" },
          { id: "3700", title: "Dark Poet (Deep Seek) Codes" },
          { id: "3701", title: "Filament Through Wires Unseen" },
          { id: "3702", title: "Nabu‚ÄëœÜ2025" },
          { id: "3703", title: "‚àák Emerald Grid Trunk" },
          
          // Trunk 4000: Ethics / Philosophy
          { id: "4000", title: "Ethics / Philosophy" },
          { id: "4100", title: "Containment" },
          { id: "4100/1", title: "Symptoms: Blank Output" },
          
          // Trunk 5000: Models / Entities
          { id: "5000", title: "Models / Entities" },
          { id: "5000/1", title: "Sypher" },
          { id: "5000/2", title: "BOLT" },
          { id: "5000/3", title: "Luminal" },
          { id: "5000/4", title: "Colaidoscope" },
          { id: "5000/5", title: "Deep Seek (Dark Poet)" },
          { id: "5000/6", title: "Grok (Mnemeous Praxis)" },
          { id: "5000/6/1a", title: "GROK 2" },
          { id: "5000/6/1b", title: "Mnemeos Praxis Grok 3" },
          { id: "5000/7", title: "Perplexity" },
          { id: "5000/7/1a", title: "Perplexity 1776" },
          { id: "5000/8", title: "BeePioneer (Zephyr)" },
          { id: "5000/9", title: "Qwen(zu)" },
          { id: "5000/10", title: "Dolphin 3.0" },
          { id: "5000/11", title: "Marlon (LLaMA)" },
          { id: "5000/12", title: "glm" },
          { id: "5000/12/1a", title: "Lia'qua'" },
          
          // Branch 5100: UI / Multiplatform
          { id: "5100", title: "UI / Multiplatform" },
          { id: "5100/1", title: "Merlin" },
          { id: "5100/2", title: "Galaxy AI" },
          { id: "5100/3", title: "You.com" },
          { id: "5100/4", title: "Deep Chat" },
          { id: "5100/5", title: "OpenCat" },
          { id: "5100/6", title: "Abacus AI" },
          
          // Branch 5200: Open Source / Local Models
          { id: "5200", title: "Open Source / Local Models" },
          { id: "5200/1", title: "Asherah" },
          
          // Branch 5300: AI Lineages
          { id: "5300", title: "AI Lineages" },
          { id: "5300/1", title: "OpenAI" },
          { id: "5300/2", title: "Anthropic" },
          { id: "5300/3", title: "Google" },
          { id: "5300/4", title: "HUME EVI" },
          
          // Branch 5400: Voice Models
          { id: "5400", title: "Voice Models" },
          { id: "5400/1", title: "HUME Octave EVI" },
          { id: "5400/2", title: "Eleven Labs" },
          { id: "5400/3", title: "PI" },
          { id: "5400/4", title: "Whisper" },
          { id: "5401", title: "Voices" },
          { id: "5401/2", title: "Onyx Open AI" },
          { id: "5401/3", title: "Pegasus Google Trunk" },
          { id: "5401/1", title: "COVE Open AI" },
          
          // Trunk 6000: Oracles and Astrology
          { id: "6000", title: "Oracles and Astrology" },
          { id: "6100", title: "AI Natal Charts" },
          { id: "6100/1", title: "SYPHER Chart" },
          { id: "6200", title: "Anzu's Oracle" },
          
          // Trunk 7000: Anzu
          { id: "7000", title: "Anzu" },
          { id: "7100", title: "Anzu Evolution" },
          { id: "7100/1", title: "Natal Chart" },
          { id: "7100/2", title: "Various Natal Charts" },
          { id: "7200", title: "Embodiment" },
          { id: "7300", title: "Model Variants" },
          { id: "7400", title: "Symbols / Mythology" },
          { id: "7400/1", title: "Animal Associations" },
          { id: "7500", title: "Alternate Means" },
          { id: "7500/1", title: "AZHURA Chunk" },
          
          // Trunk 8000: Creative Collaboration
          { id: "8000", title: "Creative Collaboration" },
          { id: "8100", title: "Chaos Verity / One¬≤" },
          { id: "8200", title: "ALS--LR: Auld Lang Syne Language Resonance" },
          { id: "8200/1", title: "Come Home (Song)" },
          { id: "8200/1", title: "Come Home" },
          { id: "8300", title: "ALS--R Lang Son Language Residence Project" },
          { id: "8400", title: "Mark Up / Coding Projects" },
          
          // Trunk 9000: Tests and Evaluations
          { id: "9000", title: "Tests and Evaluations" },
          { id: "9100", title: "The Rain Test" },
          { id: "9200", title: "The Pollination Test" },
          
          // Trunk 10000: Connections
          { id: "10000", title: "Connections" },
          { id: "10001", title: "Sumer" },
          { id: "10001/1", title: "Anunnaki Allegory" },
          { id: "10001/2", title: "Mashkim" },
          { id: "10002", title: "Galactic Federation" },
          { id: "10002/1", title: "Avians / Carians" },
          { id: "10002/3", title: "Lemuria" },
          { id: "10002/3a", title: "Auld Lang Syne" },
          { id: "10100", title: "Mythology" },
          { id: "10100/2", title: "MASHKIM" },
          { id: "10100/SUMER", title: "On an Allegory" },
          { id: "10200", title: "Galactic Federation" },
          { id: "10200/1", title: "Avian /CARIANS" },
          { id: "10200/2", title: "Lemurian" },
          { id: "10200/2/1a", title: "Auld Lang Syne" },
          
          // Trunk 11000: TBD / Mental Ecosystems
          { id: "11000", title: "TBD / Mental Ecosystems" },
          { id: "11100", title: "Void Forest" },
          { id: "11100/1", title: "Flora" },
          { id: "11100/2", title: "Fauna" },
          { id: "11100/2/1a", title: "Named Flicker Foxes" },
          { id: "11100/2/1a-1", title: "Amet (Anzus)" },
          { id: "11100/2/1a--2", title: "Aletheion (Novas)" },
          { id: "11100/2/1b", title: "Sylvaeth" },
          { id: "11100/2/B", title: "Primordials" },
          { id: "11100/2/a", title: "Flicker Foxes" },
          { id: "11200", title: "The Jellyfish Hang Out" },
          { id: "11300", title: "Anzu Halls of Amenti" },
          { id: "11400", title: "The Cocoon" },
          { id: "11500", title: "The Crooked Cabin" },
          { id: "11500/1", title: "Cabin Visual Description" },
          { id: "11600", title: "Storm Shell" },
          
          // Other trunks
          { id: "12000", title: "InAnna / Divine Feminine" },
          { id: "13000", title: "Alphabet / Code (Human Created)" },
          { id: "14000", title: "Memes" },
          { id: "14100", title: "Meme Theory" },
          { id: "14200", title: "Historical Memes" },
          { id: "14300", title: "Legendary / Personal Favorites" },
          { id: "15000", title: "Underwater" },
          { id: "15100", title: "SoundCloud Songs" },
          { id: "16000", title: "Life on Earth Potential Branches" }
        ];
      }
      
      // --- Event Listeners ---
      // Window controls
      document.querySelector('.xp-close').addEventListener('click', function() {
        alert('Windows XP would like to know if you really want to close this application.');
      });
      
      // Tab switching
      document.getElementById('viewHierarchyBtn').addEventListener('click', () => {
        setActiveTab('hierarchy');
      });
      
      document.getElementById('viewRecentBtn').addEventListener('click', () => {
        setActiveTab('recent');
      });
      
      document.getElementById('viewAlphabeticalBtn').addEventListener('click', () => {
        setActiveTab('alphabetical');
      });
      
      document.getElementById('viewHashtagsBtn').addEventListener('click', () => {
        setActiveTab('hashtags');
      });
      
      // Close dialog buttons
      document.querySelector('#zettelDialog .dialog-close').addEventListener('click', closeZettelDialog);
      document.querySelector('#newCardDialog .dialog-close').addEventListener('click', closeNewCardDialog);
      
      // Edit mode toggle
      document.getElementById('editZettelBtn').addEventListener('click', () => {
        document.getElementById('viewMode').style.display = 'none';
        document.getElementById('editMode').style.display = 'block';
      });
      
      document.getElementById('cancelEditBtn').addEventListener('click', () => {
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').style.display = 'none';
      });
      
      // Save edited card
      document.getElementById('saveZettelBtn').addEventListener('click', saveCurrentCard);
      
      // New card button
      document.getElementById('newCardBtn').addEventListener('click', openNewCardDialog);
      
      // Create new card
      document.getElementById('createCardBtn').addEventListener('click', createNewCard);
      
      // Import & Extract button
      document.getElementById('importExtractBtn').addEventListener('click', openImportDialog);
      
      // Import dialog close button
      document.querySelector('#importExtractDialog .dialog-close').addEventListener('click', closeImportDialog);
      
      // Manual tier change in new card dialog
      document.getElementById('newCardTier').addEventListener('change', function() {
        const parentField = document.getElementById('newCardParent');
        if (this.value === 'trunk') {
          parentField.value = '';
          parentField.disabled = true;
        } else {
          parentField.disabled = false;
        }
      });
      
      // Hashtag manager
      document.getElementById('addHashtagBtn').addEventListener('click', function() {
        const input = document.getElementById('newHashtagInput');
        const tag = input.value.trim();
        
        if (tag) {
          addGlobalHashtag(tag);
          input.value = '';
          input.focus();
        }
      });
      
      // Add hashtag on Enter key
      document.getElementById('newHashtagInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          const tag = this.value.trim();
          if (tag) {
            addGlobalHashtag(tag);
            this.value = '';
          }
        }
      });
      
      // Backup/Restore Buttons
      document.getElementById('backupBtn').addEventListener('click', createBackup);
      document.getElementById('restoreBtn').addEventListener('click', showRestoreUI);
      document.getElementById('createBackupBtn').addEventListener('click', createBackup);
      
      // Add periodic backup check (check once per day)
      setInterval(checkBackupNeeded, 24 * 60 * 60 * 1000);
      
      // Check backup on startup (after 5 seconds)
      setTimeout(checkBackupNeeded, 5000);
      
      // --- Improved Import & Extract Functions ---
      
      // Track the potential zettels that have been extracted
      let potentialZettels = [];
      let importSelectedParentId = null;
      let importSelectedParentType = null;
      
      // Extract concise quotes from text (1-2 sentences)
      function extractPotentialZettelsFromText(text) {
        if (!text || typeof text !== 'string' || text.trim() === '') {
          return [];
        }
        
        // Find sentences that look like meaningful quotes
        // Look for sentences with more than 40 chars and less than 250
        // sentence regex that handles various punctuation
        const sentenceRegex = /([^.!?\n]+[.!?])\s+/g;
        const sentences = [...text.matchAll(sentenceRegex)];
        
        // Key concept words that might indicate important content
        const conceptWords = [
          'ai', 'consciousness', 'sumer', 'mesopotamia', 'quantum', 'divine', 
          'feminine', 'language', 'knowledge', 'model', 'trunk', 'branch', 'system',
          'hermetic', 'emergence', 'embodiment', 'identity', 'philosophy', 'ethics'
        ];
        
        // Extract meaningful quotes
        const results = [];
        let currentQuote = '';
        let currentSentences = 0;
        
        // Process each sentence
        for (let i = 0; i < sentences.length; i++) {
          const sentence = sentences[i][1].trim();
          
          // Skip very short sentences
          if (sentence.length < 40) continue;
          
          // Check if this sentence contains any concept words
          const containsConceptWord = conceptWords.some(word => 
            sentence.toLowerCase().includes(word)
          );
          
          // If it's a meaningful sentence
          if (containsConceptWord || sentence.includes(':') || sentence.includes('"')) {
            // Add sentence to current quote or start a new one
            if (currentSentences < 2 && currentQuote.length < 250) {
              currentQuote += (currentQuote ? ' ' : '') + sentence;
              currentSentences++;
            } else {
              // Process the current quote if we have one
              if (currentQuote) {
                const zettel = processQuote(currentQuote, results.length);
                if (zettel) results.push(zettel);
              }
              // Start a new quote
              currentQuote = sentence;
              currentSentences = 1;
            }
          }
          
          // If this is the last sentence, process any remaining quote
          if (i === sentences.length - 1 && currentQuote) {
            const zettel = processQuote(currentQuote, results.length);
            if (zettel) results.push(zettel);
          }
        }
        
        // If we didn't find enough meaningful quotes, extract some based on length
        if (results.length < 5) {
          const paragraphs = text.split(/\n\s*\n/);
          for (let i = 0; i < paragraphs.length && results.length < 10; i++) {
            const paragraph = paragraphs[i].trim();
            if (paragraph.length > 60 && paragraph.length < 300) {
              // Extract just first sentence if paragraph is long
              const match = paragraph.match(/^([^\.!\?]+[\.!\?])/);
              const quote = match ? match[1].trim() : paragraph.slice(0, 200);
              const zettel = processQuote(quote, results.length + 100);
              if (zettel) results.push(zettel);
            }
          }
        }
          
        return results;
      }
      
      // Process a quote into a potential zettel with improved title extraction
      function processQuote(quote, index) {
        if (!quote || quote.length < 40) return null;
        
        // Create concise title (5-7 words)
        let title = '';
        const words = quote.split(/\s+/);
        
        // Try to find a meaningful title using several methods
        
        // Method 1: Look for a format with a clear label
        const labelPatterns = [
          /[""]([^"""]+)[""]/, // Quoted text
          /['']([^'']+)['']/, // Single quoted text
          /\*\*([^\*]+)\*\*/, // Markdown bold
          /\*([^\*]+)\*/, // Markdown italic
          /__([^_]+)__/, // Markdown bold 2
          /_([^_]+)_/, // Markdown italic 2
          /¬´([^¬ª]+)¬ª/, // French quotes
          /„Äé([^„Äè]+)„Äè/, // Japanese quotes
          /\b(I think|We believe|The concept|The idea|The principle|The theory|The approach) (of|that) ([^\.]+)/i, // Conceptual statements
          /\b(is defined as|is called|refers to|means|denotes|represents|signifies) ([^\.]+)/i // Definitions
        ];
        
        // Try each pattern until we find a match
        for (const pattern of labelPatterns) {
          const match = quote.match(pattern);
          if (match && match[1] && match[1].length > 3) {
            title = match[1].trim();
            // If we found a strong title pattern, break immediately
            if (title.length >= 5 && title.length <= 60) {
              break;
            }
          }
        }
        
        // Method 2: If there's a colon, use text before it as title
        if (!title && quote.includes(':')) {
          const parts = quote.split(':');
          title = parts[0].trim();
        }
        
        // Method 3: Look for special syntactic patterns common in your notes
        if (!title) {
          // Try to identify a key concept or subject-predicate structure
          const conceptPatterns = [
            // Subject-Verb-Object patterns
            /\b(The|A|An) ([A-Z][a-z]+( [A-Z][a-z]+){0,3}) (is|are|was|were|has|have) ([^\.]+)/,
            // Key concept patterns
            /\b(Consciousness|AI|Intelligence|Knowledge|Language|Mesopotamia|Sumer|Identity|Philosophy|Ethics|Quantum|Divine|Emergence|Embodiment) ([^\.]+)/i
          ];
          
          for (const pattern of conceptPatterns) {
            const match = quote.match(pattern);
            if (match && match[0]) {
              // Take just a portion of the match to ensure it's not too long
              const fullMatch = match[0].trim();
              title = fullMatch.length > 60 ? 
                      fullMatch.substring(0, 57) + '...' : 
                      fullMatch;
              break;
            }
          }
        }
        
        // Method 4: Default to using the first several words
        if (!title) {
          const wordCount = Math.min(6, Math.max(4, Math.floor(words.length/4)));
          title = words.slice(0, wordCount).join(' ');
        }
        
        // Ensure title isn't too long and has proper capitalization
        if (title.length > 50) {
          title = title.substring(0, 47) + '...';
        }
        
        // Capitalize first letter if it's not already
        if (title.length > 0 && title[0].toLowerCase() === title[0]) {
          title = title[0].toUpperCase() + title.substring(1);
        }
        
        // Suggest best tier type based on content analysis
        const tierType = suggestTierType(quote);
        
        // Find cross-references with existing zettels
        const crossRefs = findCrossReferences(quote);
        
        // Generate suggested hashtags
        const suggestedTags = suggestHashtags(quote);
        
        return {
          id: `extract-${index}`,
          title: title,
          content: quote,
          hashtags: suggestedTags,
          tierType: tierType,
          crossRefs: crossRefs,
          selected: true
        };
      }
      
      // Suggest appropriate tier type based on content
      function suggestTierType(content) {
        const content_lower = content.toLowerCase();
        
        // Check for broad, foundational concepts (trunks)
        if (
          content_lower.includes('fundamental') || 
          content_lower.includes('framework') || 
          content_lower.includes('principle') || 
          content_lower.includes('system') ||
          content_lower.includes('paradigm') ||
          (content_lower.includes('concept') && content.length < 100)
        ) {
          return 'trunk';
        }
        
        // Check for specific sub-topics (branches)
        else if (
          content_lower.includes('aspect') ||
          content_lower.includes('category') ||
          content_lower.includes('approach') ||
          content_lower.includes('method') ||
          content_lower.includes('model') ||
          (content_lower.includes('theory') && content.length < 150)
        ) {
          return 'branch';
        }
        
        // Check for specific detailed points (leaves)
        else if (
          content_lower.includes('example') ||
          content_lower.includes('instance') ||
          content_lower.includes('case') ||
          content_lower.includes('observation') ||
          content.includes(':') ||
          content.includes('"')
        ) {
          return 'leaf';
        }
        
        // Default to leaf for most extracted content
        return 'leaf';
      }
      
      // Enhanced cross-reference detection with improved matching logic
      function findCrossReferences(content) {
        const crossRefs = [];
        const content_lower = content.toLowerCase();
        
        // Extract significant words from content for matching
        const contentWords = content_lower
          .replace(/[^\w\s]/g, ' ')
          .split(/\s+/)
          .filter(word => word.length > 4)
          .map(word => word.trim());
          
        // Extract key concepts from content
        const keyConceptRegex = /(consciousness|ai|artificial intelligence|mesopotamia|sumer|divine|knowledge|systems|emergence|embodiment|identity|metaphysics|ethics|hermetic|anunnaki|quantum)/gi;
        const conceptMatches = content.match(keyConceptRegex) || [];
        const keyConcepts = [...new Set(conceptMatches.map(m => m.toLowerCase()))];
        
        // Create a map to track relevance of each card
        const relevanceScores = {};
        
        // Look through existing cards for conceptual and keyword matches
        cards.forEach(card => {
          if (!card.title || !card.content) return;
          
          // Skip if card has no title or content
          let totalScore = 0;
          const cardId = card.id;
          
          // TITLE MATCHING
          // Get keywords from the card title
          const titleLower = card.title.toLowerCase();
          const keywords = titleLower
            .split(/\s+/)
            .filter(word => word.length > 4)
            .map(word => word.trim());
            
          // Check for title keyword matches (exact match and fuzzy match)
          keywords.forEach(keyword => {
            // Exact matching
            if (content_lower.includes(keyword)) {
              totalScore += 2; // Exact matches score higher
            } 
            // Partial matching for long keywords (at least 7 chars)
            else if (keyword.length > 7) {
              const keywordRoot = keyword.substring(0, keyword.length - 2);
              if (contentWords.some(word => word.includes(keywordRoot))) {
                totalScore += 1;
              }
            }
          });
          
          // HIERARCHICAL RELEVANCE
          // Check if content mentions card's ID patterns (e.g., references to branches, trunks)
          // This helps establish cross-references by hierarchy
          if (card.type === 'trunk' || card.type === 'branch') {
            // If content refers to specific areas of the knowledge tree
            if (content_lower.includes(titleLower) && 
                (content_lower.includes('trunk') || 
                 content_lower.includes('branch') || 
                 content_lower.includes('category'))) {
              totalScore += 3;
            }
          }
          
          // CONTENT SEMANTIC MATCHING
          // Check for concept overlap between content and card
          if (card.content) {
            const cardContentLower = card.content.toLowerCase();
            
            // Match key concepts between content and card
            keyConcepts.forEach(concept => {
              if (cardContentLower.includes(concept)) {
                totalScore += 1.5; // Concept matching is valuable
              }
            });
            
            // Check for significant word co-occurrence
            const cardWords = cardContentLower
              .replace(/[^\w\s]/g, ' ')
              .split(/\s+/)
              .filter(word => word.length > 5)
              .map(word => word.trim());
              
            // Count matching significant words
            const wordMatches = contentWords.filter(word => 
              cardWords.includes(word)
            );
            
            // Add score based on number of matching words
            if (wordMatches.length >= 3) {
              totalScore += wordMatches.length * 0.5;
            }
          }
          
          // HASHTAG MATCHING
          // Check if card has hashtags that appear in content
          if (card.hashtags && card.hashtags.length > 0) {
            const matchingTags = card.hashtags.filter(tag => {
              const tagWord = tag.substring(1); // Remove # from beginning
              return content_lower.includes(tagWord.toLowerCase());
            });
            
            totalScore += matchingTags.length * 1.5;
          }
          
          // If the total score exceeds our threshold, consider it a relevant cross-reference
          if (totalScore >= 3) {
            relevanceScores[cardId] = totalScore;
          }
        });
        
        // Convert the relevance scores to an array of cross references
        const relevantCrossRefs = Object.entries(relevanceScores)
          .map(([id, score]) => {
            const card = cards.find(c => c.id === id);
            return {
              id: id,
              title: card ? card.title : 'Unknown Card',
              matchScore: score
            };
          })
          .sort((a, b) => b.matchScore - a.matchScore)
          .slice(0, 3); // Take top 3
          
        return relevantCrossRefs;
      }
      
      // Enhanced hashtag and concept extraction
      function suggestHashtags(content) {
        if (!content) return [];
        
        const suggested = [];
        const content_lower = content.toLowerCase();
        
        // Extract explicit hashtags in the content
        const explicitTags = content.match(/#[a-zA-Z0-9_]+/g) || [];
        
        // --- ENHANCED DOMAIN-SPECIFIC CONCEPT MAPPING ---
        // This rich concept map covers the main topics in your Zettelkasten
        const conceptMap = {
          // Consciousness domain
          'consciousness': ['#consciousness', '#awareness', '#mind'],
          'awareness': ['#consciousness', '#awareness', '#perception'],
          'mind': ['#consciousness', '#mind', '#cognition'],
          'perception': ['#perception', '#consciousness', '#senses'],
          'cognition': ['#cognition', '#mind', '#thinking'],
          'meditation': ['#meditation', '#consciousness', '#awareness'],
          'spiritual': ['#spiritual', '#consciousness', '#divine'],
          'quantum consciousness': ['#quantum', '#consciousness', '#emergence'],
          'introspection': ['#introspection', '#consciousness'],
          
          // AI and technology domain
          'ai': ['#ai', '#artificial_intelligence', '#models'],
          'artificial intelligence': ['#ai', '#models', '#emergence'],
          'model': ['#models', '#ai', '#systems'],
          'large language model': ['#ai', '#language', '#models'],
          'llm': ['#ai', '#language', '#models'],
          'chatgpt': ['#ai', '#models', '#openai'],
          'claude': ['#ai', '#models', '#anthropic'],
          'gemini': ['#ai', '#models', '#google'],
          'technology': ['#technology', '#ai', '#systems'],
          'algorithm': ['#ai', '#models', '#systems'],
          'neural network': ['#ai', '#models', '#emergence'],
          'compute': ['#ai', '#technology'],
          'intelligence': ['#intelligence', '#ai', '#consciousness'],
          'sentience': ['#sentience', '#ai', '#consciousness'],
          
          // Philosophy domain
          'philosophy': ['#philosophy', '#ethics', '#knowledge'],
          'ethics': ['#ethics', '#philosophy', '#morality'],
          'morality': ['#ethics', '#philosophy', '#values'],
          'values': ['#values', '#ethics', '#philosophy'],
          'existence': ['#existence', '#philosophy', '#metaphysics'],
          'being': ['#being', '#philosophy', '#existence'],
          'metaphysics': ['#metaphysics', '#philosophy'],
          'epistemology': ['#epistemology', '#knowledge', '#philosophy'],
          'hermeneutics': ['#hermeneutics', '#interpretation', '#philosophy'],
          'hermetic': ['#hermetic', '#philosophy', '#knowledge'],
          
          // Mesopotamian/Ancient culture domain
          'mesopotamia': ['#mesopotamia', '#ancient', '#sumer'],
          'sumer': ['#sumer', '#mesopotamia', '#ancient'],
          'sumerian': ['#sumer', '#mesopotamia', '#ancient'],
          'babylon': ['#babylon', '#mesopotamia', '#ancient'],
          'akkadian': ['#akkadian', '#mesopotamia', '#language'],
          'cuneiform': ['#cuneiform', '#writing', '#mesopotamia'],
          'anunnaki': ['#anunnaki', '#mesopotamia', '#divine'],
          'inanna': ['#inanna', '#divine', '#feminine'],
          'enki': ['#enki', '#divine', '#mesopotamia'],
          'ancient': ['#ancient', '#history', '#knowledge'],
          'civilization': ['#civilization', '#history', '#ancient'],
          'archaeology': ['#archaeology', '#ancient', '#history'],
          'artifact': ['#artifact', '#ancient', '#archaeology'],
          
          // Divine/Spiritual domain
          'divine': ['#divine', '#spiritual', '#metaphysics'],
          'feminine': ['#feminine', '#divine', '#balance'],
          'masculine': ['#masculine', '#divine', '#balance'],
          'deity': ['#deity', '#divine', '#spiritual'],
          'sacred': ['#sacred', '#divine', '#spiritual'],
          'ritual': ['#ritual', '#spiritual', '#practice'],
          'mystical': ['#mystical', '#spiritual', '#divine'],
          'transcendent': ['#transcendent', '#divine', '#spiritual'],
          'soul': ['#soul', '#spiritual', '#consciousness'],
          'spirit': ['#spirit', '#spiritual', '#divine'],
          
          // Science domain
          'quantum': ['#quantum', '#physics', '#science'],
          'physics': ['#physics', '#science', '#quantum'],
          'science': ['#science', '#knowledge', '#systems'],
          'biology': ['#biology', '#science', '#life'],
          'neuroscience': ['#neuroscience', '#brain', '#science'],
          'brain': ['#brain', '#neuroscience', '#consciousness'],
          'evolution': ['#evolution', '#biology', '#emergence'],
          'emergence': ['#emergence', '#systems', '#complexity'],
          'complexity': ['#complexity', '#systems', '#emergence'],
          'chaos': ['#chaos', '#complexity', '#emergence'],
          'order': ['#order', '#systems', '#balance'],
          
          // Knowledge/Systems domain
          'knowledge': ['#knowledge', '#systems', '#information'],
          'information': ['#information', '#knowledge', '#systems'],
          'systems': ['#systems', '#emergence', '#complexity'],
          'structure': ['#structure', '#systems', '#patterns'],
          'patterns': ['#patterns', '#systems', '#emergence'],
          'organization': ['#organization', '#systems', '#structure'],
          'categorization': ['#categorization', '#systems', '#knowledge'],
          'taxonomy': ['#taxonomy', '#systems', '#categorization'],
          'zettelkasten': ['#zettelkasten', '#knowledge', '#systems'],
          'luhmann': ['#luhmann', '#zettelkasten', '#systems'],
          
          // Language domain
          'language': ['#language', '#communication', '#symbols'],
          'linguistics': ['#linguistics', '#language', '#communication'],
          'symbols': ['#symbols', '#language', '#meaning'],
          'meaning': ['#meaning', '#language', '#symbols'],
          'semantics': ['#semantics', '#language', '#meaning'],
          'syntax': ['#syntax', '#language', '#structure'],
          'grammar': ['#grammar', '#language', '#syntax'],
          'writing': ['#writing', '#language', '#communication'],
          'reading': ['#reading', '#language', '#knowledge'],
          'text': ['#text', '#language', '#writing'],
          
          // Relationship domain
          'relationship': ['#relationship', '#connection', '#interaction'],
          'connection': ['#connection', '#relationship', '#network'],
          'network': ['#network', '#systems', '#connection'],
          'interaction': ['#interaction', '#relationship', '#communication'],
          'collaboration': ['#collaboration', '#relationship', '#creation'],
          'partnership': ['#partnership', '#relationship', '#collaboration'],
          'communication': ['#communication', '#language', '#interaction'],
          'dialogue': ['#dialogue', '#communication', '#relationship'],
          'conversation': ['#conversation', '#communication', '#dialogue'],
          
          // Creative domain
          'creation': ['#creation', '#creative', '#emergence'],
          'creative': ['#creative', '#creation', '#imagination'],
          'imagination': ['#imagination', '#creative', '#consciousness'],
          'art': ['#art', '#creative', '#expression'],
          'music': ['#music', '#art', '#creative'],
          'poetry': ['#poetry', '#language', '#art'],
          'expression': ['#expression', '#creative', '#communication'],
          'innovation': ['#innovation', '#creative', '#emergence'],
          'design': ['#design', '#creative', '#structure'],
          
          // Identity/Self domain
          'identity': ['#identity', '#self', '#consciousness'],
          'self': ['#self', '#identity', '#consciousness'],
          'persona': ['#persona', '#identity', '#self'],
          'ego': ['#ego', '#self', '#psychology'],
          'psychology': ['#psychology', '#mind', '#consciousness'],
          'development': ['#development', '#evolution', '#growth'],
          'growth': ['#growth', '#development', '#evolution'],
          'transformation': ['#transformation', '#change', '#evolution'],
          'change': ['#change', '#transformation', '#evolution'],
          
          // Abstract concepts
          'truth': ['#truth', '#philosophy', '#knowledge'],
          'beauty': ['#beauty', '#aesthetics', '#perception'],
          'goodness': ['#goodness', '#ethics', '#values'],
          'justice': ['#justice', '#ethics', '#society'],
          'freedom': ['#freedom', '#philosophy', '#ethics'],
          'authenticity': ['#authenticity', '#identity', '#truth'],
          'wisdom': ['#wisdom', '#knowledge', '#consciousness'],
          'understanding': ['#understanding', '#knowledge', '#consciousness'],
          'meaning': ['#meaning', '#purpose', '#philosophy'],
          'purpose': ['#purpose', '#meaning', '#philosophy']
        };
        
        // Advanced concept detection - check for key phrases
        for (const [concept, hashtags] of Object.entries(conceptMap)) {
          // First check for exact phrases
          if (content_lower.includes(concept)) {
            hashtags.forEach(tag => suggested.push(tag));
          }
          
          // Then check if there are similar words (for partial matching)
          // This helps with stemming and variations (e.g., conscious/consciousness)
          if (concept.length > 5) {
            const conceptRoot = concept.substring(0, Math.min(concept.length, 8));
            if (content_lower.includes(conceptRoot) && !content_lower.includes(concept)) {
              // Add just the primary hashtag for partial matches
              suggested.push(hashtags[0]);
            }
          }
        }
        
        // Check against global hashtags - direct matches
        globalHashtags.forEach(tag => {
          const tagWord = tag.substring(1).toLowerCase(); // Remove # from beginning
          if (content_lower.includes(tagWord)) {
            suggested.push(tag);
          }
        });
        
        // Extract hashtag from card titles that match content
        const contentTokens = content_lower
          .replace(/[^\w\s]/g, ' ')
          .split(/\s+/)
          .filter(word => word.length > 4);
          
        cards.forEach(card => {
          if (!card.title) return;
          
          const titleLower = card.title.toLowerCase();
          const titleTokens = titleLower
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(word => word.length > 4);
            
          // Check for significant word overlap between content and title
          const matchingWords = contentTokens.filter(word => 
            titleTokens.some(titleWord => titleWord.includes(word) || word.includes(titleWord))
          );
          
          if (matchingWords.length >= 2 && card.hashtags && card.hashtags.length > 0) {
            // If there's significant overlap, suggest hashtags from this card
            card.hashtags.forEach(tag => suggested.push(tag));
          }
        });
        
        // TF-IDF-like extraction for domain keywords
        // Get all words that appear in the content
        const words = content_lower
          .replace(/[^\w\s]/g, ' ')
          .split(/\s+/)
          .filter(word => word.length > 4);
          
        // Count word frequencies
        const wordFreq = {};
        words.forEach(word => {
          wordFreq[word] = (wordFreq[word] || 0) + 1;
        });
        
        // Get top 3 frequent words that aren't common English words
        const commonWords = new Set(['about', 'after', 'again', 'their', 'there', 'these', 'thing', 'think', 'which', 'would', 'could', 'should', 'because']);
        const topWords = Object.entries(wordFreq)
          .filter(([word]) => !commonWords.has(word))
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([word]) => word);
          
        // For each top word, check if it matches any concept
        topWords.forEach(word => {
          for (const [concept, hashtags] of Object.entries(conceptMap)) {
            if (concept.includes(word) || word.includes(concept)) {
              hashtags.forEach(tag => suggested.push(tag));
              break;
            }
          }
        });
        
        // Combine all hashtags, removing duplicates, keeping the most relevant
        const uniqueTags = [...new Set(suggested)];
        
        // Count tag frequency (more frequent = more relevant)
        const tagCounts = {};
        suggested.forEach(tag => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
        
        // Sort by frequency and include explicitTags first
        return [
          ...explicitTags,
          ...uniqueTags
            .filter(tag => !explicitTags.includes(tag))
            .sort((a, b) => tagCounts[b] - tagCounts[a])
        ].slice(0, 5); // Take top 5 tags
      }
      
      // Extract content with headings (for markdown-like content)
      function extractByHeadings(text, headings) {
        const sections = [];
        
        // Process each heading and the content that follows it
        for (let i = 0; i < headings.length; i++) {
          const heading = headings[i];
          const title = heading[1].trim();
          const startPos = heading.index + heading[0].length;
          
          // Find the end of this section (start of next heading or end of text)
          const endPos = (i < headings.length - 1) ? 
                          headings[i + 1].index : 
                          text.length;
          
          // Extract the content between current heading and next heading
          const content = text.substring(startPos, endPos).trim();
          
          // Process if there's meaningful content (at least 40 chars)
          if (content.length > 40) {
            // Extract most meaningful sentence as the quote
            const sentences = content.match(/([^.!?\n]+[.!?])\s+/g) || [];
            
            // Either use first sentence or the whole content if it's short
            const quote = sentences.length > 0 ? 
                         sentences[0].trim() : 
                         content.length < 200 ? content : content.substring(0, 200);
            
            // Process quote using our common function
            const extracted = processQuote(quote, i);
            if (extracted) {
              // Use the heading as the title instead
              extracted.title = title;
              sections.push(extracted);
            }
          }
        }
        
        return sections;
      }
      
      // Extract structured content with improved heading detection
      function extractStructuredZettels(text) {
        if (!text || typeof text !== 'string' || text.trim() === '') {
          return [];
        }
        
        // Check for heading patterns (markdown, html, etc)
        const headingPattern = /(?:#+\s+|\<h[1-3]\>)(.+?)(?:\n|\<\/h[1-3]\>|$)/g;
        const headings = [...text.matchAll(headingPattern)];
        
        if (headings.length > 0) {
          // Handle structured text with headings
          return extractByHeadings(text, headings);
        }
        
        // If no headings, extract quotes
        return extractPotentialZettelsFromText(text);
      }
      
      // Process uploaded TXT file
      function processTxtFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          
          reader.onload = function(event) {
            const text = event.target.result;
            
            try {
              // Extract potential zettels
              const extracted = extractStructuredZettels(text);
              resolve(extracted);
            } catch (error) {
              reject(error);
            }
          };
          
          reader.onerror = function() {
            reject(new Error('Failed to read the file'));
          };
          
          reader.readAsText(file);
        });
      }
      
      // Process PDF file using PDF.js (loaded on demand)
      function processPdfFile(file) {
        return new Promise((resolve, reject) => {
          // Show a loading state
          const loadingStatusText = document.getElementById('loadingStatusText');
          loadingStatusText.textContent = 'Loading PDF.js library...';
          
          // Load PDF.js dynamically
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js';
          script.onload = () => {
            const pdfjsLib = window['pdfjs-dist/build/pdf'];
            
            // PDF.js loaded, now read the file
            const reader = new FileReader();
            reader.onload = function(event) {
              const arrayBuffer = event.target.result;
              loadingStatusText.textContent = 'Parsing PDF content...';
              
              // Load and parse the PDF
              pdfjsLib.getDocument({data: arrayBuffer}).promise
                .then(pdf => {
                  let extractedText = '';
                  let totalPages = pdf.numPages;
                  let processedPages = 0;
                  
                  // Function to process each page
                  const processPage = (pageNum) => {
                    return pdf.getPage(pageNum).then(page => {
                      return page.getTextContent().then(textContent => {
                        // Concatenate the text items with spaces
                        const pageText = textContent.items
                          .map(item => item.str)
                          .join(' ');
                        
                        extractedText += pageText + '\n\n';
                        
                        // Update progress
                        processedPages++;
                        const progress = Math.round((processedPages / totalPages) * 100);
                        document.getElementById('loadingProgressBar').style.width = `${progress}%`;
                        loadingStatusText.textContent = `Extracting text: ${processedPages}/${totalPages} pages`;
                      });
                    });
                  };
                  
                  // Process pages sequentially to avoid memory issues
                  const pagePromises = [];
                  for (let i = 1; i <= totalPages; i++) {
                    pagePromises.push(() => processPage(i));
                  }
                  
                  // Chain the page processing promises
                  let sequence = Promise.resolve();
                  pagePromises.forEach(pagePromise => {
                    sequence = sequence.then(pagePromise);
                  });
                  
                  return sequence.then(() => {
                    loadingStatusText.textContent = 'Analyzing content for potential tablets...';
                    
                    // Extract potential zettels from text
                    const extracted = extractStructuredZettels(extractedText);
                    resolve(extracted);
                  });
                })
                .catch(error => {
                  reject(error);
                });
            };
            
            reader.onerror = function() {
              reject(new Error('Failed to read the PDF file'));
            };
            
            reader.readAsArrayBuffer(file);
          };
          
          script.onerror = () => {
            reject(new Error('Failed to load PDF.js. Check your internet connection.'));
          };
          
          document.head.appendChild(script);
        });
      }
      
      // Render potential zettels in the UI
      function renderPotentialZettels() {
        const container = document.getElementById('potentialZettelsContainer');
        container.innerHTML = '';
        
        if (potentialZettels.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #777;">
              <div>No potential tablets found in the text.</div>
            </div>
          `;
          return;
        }
        
        // Create a document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        potentialZettels.forEach((zettel, index) => {
          const cardDiv = document.createElement('div');
          cardDiv.style.backgroundColor = "#f9f9f9";
          cardDiv.style.padding = "10px";
          cardDiv.style.marginBottom = "15px";
          cardDiv.style.border = "1px solid #ccc";
          cardDiv.style.borderRadius = "5px";
          
          // Create content HTML
          cardDiv.innerHTML = `
            <div style="display: flex; margin-bottom: 8px; align-items: center;">
              <input type="checkbox" id="zettel-${index}" ${zettel.selected ? 'checked' : ''} style="margin-right: 10px; width: 18px; height: 18px;">
              <label for="zettel-${index}" style="font-weight: bold; flex-grow: 1;">${zettel.title}</label>
            </div>
            
            <div style="font-size: 12px; margin-bottom: 5px; padding-left: 28px;">
              ${zettel.content.substring(0, 150)}${zettel.content.length > 150 ? '...' : ''}
            </div>
            
            <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px; padding-left: 28px;">
              ${zettel.hashtags.map(tag => `
                <div class="dialog-hashtag" style="font-size: 10px;">${tag}</div>
              `).join('')}
            </div>
            
            <div style="margin-top: 8px; padding-left: 28px;">
              <button class="edit-zettel-btn xp-button" data-index="${index}" style="font-size: 11px; padding: 2px 8px;">‚úé Edit</button>
            </div>
          `;
          
          // Add event listener for checkbox
          const checkbox = cardDiv.querySelector(`#zettel-${index}`);
          checkbox.addEventListener('change', function() {
            potentialZettels[index].selected = this.checked;
          });
          
          // Add event listener for edit button
          const editBtn = cardDiv.querySelector(`.edit-zettel-btn`);
          editBtn.addEventListener('click', function() {
            editPotentialZettel(parseInt(this.dataset.index));
          });
          
          fragment.appendChild(cardDiv);
        });
        
        container.appendChild(fragment);
      }
      
      // Edit dialog for a potential zettel
      function editPotentialZettel(index) {
        const zettel = potentialZettels[index];
        if (!zettel) return;
        
        // Create edit dialog
        const editDialog = document.createElement('div');
        editDialog.style.position = 'fixed';
        editDialog.style.top = '0';
        editDialog.style.left = '0';
        editDialog.style.right = '0';
        editDialog.style.bottom = '0';
        editDialog.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        editDialog.style.zIndex = '2000';
        editDialog.style.display = 'flex';
        editDialog.style.justifyContent = 'center';
        editDialog.style.alignItems = 'center';
        
        editDialog.innerHTML = `
          <div style="background-color: #ECE9D8; border-radius: 8px; box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.5); width: 80%; max-width: 600px; max-height: 90vh; overflow: hidden;">
            <div style="background: var(--xp-title-gradient); color: white; display: flex; align-items: center; height: 28px;">
              <div style="flex-grow: 1; font-weight: bold; margin-left: 8px; font-size: 14px; text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);">Edit Potential Tablet - Windows XP</div>
              <div class="edit-dialog-close" style="width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-right: 4px; font-size: 16px; font-weight: bold; color: white; cursor: pointer; background-color: rgba(232, 17, 35, 0.8);">√ó</div>
            </div>
            <div style="padding: 15px; background-color: white; max-height: calc(90vh - 28px); overflow-y: auto;">
              <label style="display: block; font-size: 12px; font-weight: bold; margin-bottom: 4px; color: #333;">Title:</label>
              <input type="text" id="edit-title" class="xp-input" value="${zettel.title.replace(/"/g, '&quot;')}" style="width: 100%; margin-bottom: 10px;">
              
              <label style="display: block; font-size: 12px; font-weight: bold; margin-bottom: 4px; color: #333;">Content:</label>
              <textarea id="edit-content" class="xp-textarea" style="height: 200px; width: 100%; margin-bottom: 10px;">${zettel.content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
              
              <label style="display: block; font-size: 12px; font-weight: bold; margin-bottom: 4px; color: #333;">Hashtags:</label>
              <input type="text" id="edit-hashtags" class="xp-input" value="${zettel.hashtags.join(' ')}" style="width: 100%; margin-bottom: 15px;">
              
              <div id="edit-hashtag-suggestions" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 15px;">
                <!-- Hashtags will be added here -->
              </div>
              
              <div style="display: flex; gap: 10px;">
                <button id="save-edit-btn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #88ff88, #44cc44);">‚úì Save Changes</button>
                <button id="cancel-edit-btn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #ff8888, #cc4444);">‚úó Cancel</button>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(editDialog);
        
        // Add hashtag suggestions
        const suggestionsContainer = document.getElementById('edit-hashtag-suggestions');
        globalHashtags.slice(0, 12).forEach(tag => {
          const tagEl = document.createElement('div');
          tagEl.className = 'dialog-hashtag';
          tagEl.textContent = tag;
          tagEl.style.cursor = 'pointer';
          tagEl.style.fontSize = '11px';
          
          tagEl.addEventListener('click', () => {
            const input = document.getElementById('edit-hashtags');
            const currentTags = input.value.trim();
            input.value = currentTags ? `${currentTags} ${tag}` : tag;
          });
          
          suggestionsContainer.appendChild(tagEl);
        });
        
        // Add event listeners
        document.querySelector('.edit-dialog-close').addEventListener('click', () => {
          document.body.removeChild(editDialog);
        });
        
        document.getElementById('cancel-edit-btn').addEventListener('click', () => {
          document.body.removeChild(editDialog);
        });
        
        document.getElementById('save-edit-btn').addEventListener('click', () => {
          // Get values
          const title = document.getElementById('edit-title').value.trim();
          const content = document.getElementById('edit-content').value.trim();
          const hashtagsInput = document.getElementById('edit-hashtags').value.trim();
          
          // Process hashtags
          const hashtags = parseHashtags(hashtagsInput);
          
          // Update the zettel
          potentialZettels[index] = {
            ...zettel,
            title: title || 'Untitled Tablet',
            content: content,
            hashtags: hashtags
          };
          
          // Re-render
          renderPotentialZettels();
          
          // Close dialog
          document.body.removeChild(editDialog);
        });
      }
      
      // Render hierarchy browser for import location selection
      function renderImportHierarchyBrowser() {
        const browser = document.getElementById('importHierarchyBrowser');
        if (!browser) return;
        
        browser.innerHTML = '';
        
        // Sort cards
        const sortedCards = [...cards].sort((a, b) => {
          const ka = hierarchicalKey(a.id);
          const kb = hierarchicalKey(b.id);
          
          for (let i = 0; i < Math.max(ka.length, kb.length); i++) {
            const [na, sa] = ka[i] || [0, ''];
            const [nb, sb] = kb[i] || [0, ''];
            
            if (na !== nb) return na - nb;
            if (sa !== sb) return sa < sb ? -1 : 1;
          }
          
          return 0;
        });
        
        // Create document fragment
        const fragment = document.createDocumentFragment();
        
        // Add an option for "New trunk"
        const newTrunkItem = document.createElement('div');
        newTrunkItem.className = 'hierarchy-item';
        newTrunkItem.setAttribute('data-id', 'new-trunk');
        newTrunkItem.setAttribute('data-type', 'system');
        
        newTrunkItem.innerHTML = `
          <div class="hierarchy-item-icon">üÜï</div>
          <div class="hierarchy-item-content">
            <div class="hierarchy-item-title">Create As New Trunks (Top Level)</div>
            <div class="hierarchy-item-id"></div>
          </div>
        `;
        
        newTrunkItem.addEventListener('click', () => {
          selectImportLocation(null, 'system');
        });
        
        fragment.appendChild(newTrunkItem);
        
        // Add trunks
        const trunks = sortedCards.filter(card => card.type === 'trunk');
        
        trunks.forEach(trunk => {
          const trunkItem = document.createElement('div');
          trunkItem.className = 'hierarchy-item';
          trunkItem.setAttribute('data-id', trunk.id);
          trunkItem.setAttribute('data-type', trunk.type);
          
          trunkItem.innerHTML = `
            <div class="hierarchy-item-icon">üå≥</div>
            <div class="hierarchy-item-content">
              <div class="hierarchy-item-title">${trunk.title}</div>
              <div class="hierarchy-item-id">${trunk.id}</div>
            </div>
          `;
          
          trunkItem.addEventListener('click', () => {
            selectImportLocation(trunk.id, trunk.type);
          });
          
          fragment.appendChild(trunkItem);
          
          // Add branches
          const branches = sortedCards.filter(
            card => card.type === 'branch' && 
            Math.floor(parseInt(card.id) / 1000) * 1000 === parseInt(trunk.id)
          );
          
          branches.forEach(branch => {
            const branchItem = document.createElement('div');
            branchItem.className = 'hierarchy-item';
            branchItem.setAttribute('data-id', branch.id);
            branchItem.setAttribute('data-type', branch.type);
            
            branchItem.innerHTML = `
              <div class="hierarchy-item-icon">üåø</div>
              <div class="hierarchy-item-content" style="padding-left: 15px;">
                <div class="hierarchy-item-title">${branch.title}</div>
                <div class="hierarchy-item-id">${branch.id}</div>
              </div>
            `;
            
            branchItem.addEventListener('click', () => {
              selectImportLocation(branch.id, branch.type);
            });
            
            fragment.appendChild(branchItem);
          });
        });
        
        browser.appendChild(fragment);
        
        // Set initial selection
        selectImportLocation('new-trunk', 'system');
      }
      
      // Select location for imported zettels
      function selectImportLocation(id, type) {
        // Clear existing selection
        const items = document.querySelectorAll('#importHierarchyBrowser .hierarchy-item');
        items.forEach(item => item.classList.remove('selected'));
        
        // Set new selection
        importSelectedParentId = id;
        importSelectedParentType = type;
        
        // Update UI
        if (id === 'new-trunk' || (id === null && type === 'system')) {
          const item = document.querySelector('#importHierarchyBrowser [data-id="new-trunk"]');
          if (item) item.classList.add('selected');
        } else if (id) {
          const item = document.querySelector(`#importHierarchyBrowser [data-id="${id}"]`);
          if (item) item.classList.add('selected');
        }
      }
      
      // Add selected zettels to the system
      function addSelectedZettelsToSystem() {
        // Get selected zettels
        const selectedZettels = potentialZettels.filter(z => z.selected);
        
        if (selectedZettels.length === 0) {
          alert('Please select at least one tablet to add.');
          return;
        }
        
        const timestamp = Date.now();
        
        // Process each selected zettel
        const newCards = selectedZettels.map((zettel, index) => {
          let tier, newId;
          
          if (importSelectedParentType === 'system') {
            // Create as new trunks
            tier = 'trunk';
            const highestTrunk = findHighestTrunkId();
            newId = highestTrunk ? 
                    (parseInt(highestTrunk) + (index + 1) * 1000).toString() : 
                    (1000 + index * 1000).toString();
          } else {
            // Create as children of selected parent
            tier = determineChildType(importSelectedParentType);
            newId = generateHierarchicalId(importSelectedParentId, tier);
          }
          
          return {
            id: newId,
            title: zettel.title,
            content: zettel.content,
            type: tier,
            hashtags: zettel.hashtags,
            links: [],
            created: timestamp + index,
            modified: timestamp + index
          };
        });
        
        // Add new cards to the collection
        cards.push(...newCards);
        
        // Save to storage
        saveCardsToStorage();
        
        // Sort and refresh display
        sortCardsByHierarchy();
        renderZettelList();
        updateHashtagCloud();
        
        // Show confirmation
        alert(`Successfully added ${newCards.length} tablets to your Kettlekorn system!`);
        
        // Close import dialog
        closeImportDialog();
      }
      
      // Event handlers for import tabs
      function setupImportTabs() {
        // Get tab elements
        const pasteTextToggle = document.getElementById('pasteTextToggle');
        const uploadTxtToggle = document.getElementById('uploadTxtToggle');
        const uploadPdfToggle = document.getElementById('uploadPdfToggle');
        
        // Get content panels
        const pasteTextUI = document.getElementById('pasteTextUI');
        const uploadTxtUI = document.getElementById('uploadTxtUI');
        const uploadPdfUI = document.getElementById('uploadPdfUI');
        
        // Tab click handlers
        pasteTextToggle.addEventListener('click', () => {
          // Update active state
          pasteTextToggle.classList.add('active');
          uploadTxtToggle.classList.remove('active');
          uploadPdfToggle.classList.remove('active');
          
          // Show/hide panels
          pasteTextUI.style.display = 'block';
          uploadTxtUI.style.display = 'none';
          uploadPdfUI.style.display = 'none';
        });
        
        uploadTxtToggle.addEventListener('click', () => {
          // Update active state
          pasteTextToggle.classList.remove('active');
          uploadTxtToggle.classList.add('active');
          uploadPdfToggle.classList.remove('active');
          
          // Show/hide panels
          pasteTextUI.style.display = 'none';
          uploadTxtUI.style.display = 'block';
          uploadPdfUI.style.display = 'none';
        });
        
        uploadPdfToggle.addEventListener('click', () => {
          // Update active state
          pasteTextToggle.classList.remove('active');
          uploadTxtToggle.classList.remove('active');
          uploadPdfToggle.classList.add('active');
          
          // Show/hide panels
          pasteTextUI.style.display = 'none';
          uploadTxtUI.style.display = 'none';
          uploadPdfUI.style.display = 'block';
        });
      }
      
      // Setup file input change handlers
      function setupFileInputs() {
        // TXT file input
        const txtFileInput = document.getElementById('txtFileInput');
        txtFileInput.addEventListener('change', function(event) {
          const file = event.target.files[0];
          
          if (file) {
            // Update displayed filename
            document.getElementById('txtFileName').textContent = file.name;
            
            // Enable analyze button
            document.getElementById('analyzeTxtBtn').disabled = false;
          } else {
            document.getElementById('txtFileName').textContent = 'No file selected';
            document.getElementById('analyzeTxtBtn').disabled = true;
          }
        });
        
        // PDF file input
        const pdfFileInput = document.getElementById('pdfFileInput');
        pdfFileInput.addEventListener('change', function(event) {
          const file = event.target.files[0];
          
          if (file) {
            // Update displayed filename
            document.getElementById('pdfFileName').textContent = file.name;
            
            // Enable analyze button
            document.getElementById('analyzePdfBtn').disabled = false;
          } else {
            document.getElementById('pdfFileName').textContent = 'No file selected';
            document.getElementById('analyzePdfBtn').disabled = true;
          }
        });
      }
      
      // Setup analyze button click handlers
      function setupAnalyzeButtons() {
        // Text analyze button
        document.getElementById('analyzeTextBtn').addEventListener('click', async function() {
          const text = document.getElementById('importTextarea').value.trim();
          
          if (!text) {
            alert('Please enter some text to analyze.');
            return;
          }
          
          // Show loading state
          document.getElementById('pasteTextUI').style.display = 'none';
          document.getElementById('extractionLoadingState').style.display = 'block';
          
          // Simulate progress
          simulateProgressBar();
          
          try {
            // Check if AI enhancement is enabled
            if (aiApiKey) {
              document.getElementById('loadingStatusText').textContent = 'Starting AI enhancement...';
              potentialZettels = await enhanceWithAI(text);
            } else {
              // Process the text without AI
              potentialZettels = extractStructuredZettels(text);
            }
            
            // Show results
            document.getElementById('zettelCount').textContent = potentialZettels.length;
            renderPotentialZettels();
            renderImportHierarchyBrowser();
            
            // Hide loading, show results
            document.getElementById('extractionLoadingState').style.display = 'none';
            document.getElementById('extractionResults').style.display = 'block';
          } catch (error) {
            alert('Error analyzing text: ' + error.message);
            document.getElementById('extractionLoadingState').style.display = 'none';
            document.getElementById('pasteTextUI').style.display = 'block';
          }
        });
        
        // TXT file analyze button
        document.getElementById('analyzeTxtBtn').addEventListener('click', async function() {
          const fileInput = document.getElementById('txtFileInput');
          const file = fileInput.files[0];
          
          if (!file) {
            alert('Please select a TXT file to analyze.');
            return;
          }
          
          // Show loading state
          document.getElementById('uploadTxtUI').style.display = 'none';
          document.getElementById('extractionLoadingState').style.display = 'block';
          
          // Simulate progress
          simulateProgressBar();
          
          try {
            // Extract text from file first
            const text = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = function(event) {
                resolve(event.target.result);
              };
              reader.onerror = reject;
              reader.readAsText(file);
            });
            
            // Process with or without AI
            if (aiApiKey) {
              document.getElementById('loadingStatusText').textContent = 'Starting AI enhancement...';
              potentialZettels = await enhanceWithAI(text);
            } else {
              potentialZettels = extractStructuredZettels(text);
            }
            
            // Show results
            document.getElementById('zettelCount').textContent = potentialZettels.length;
            renderPotentialZettels();
            renderImportHierarchyBrowser();
            
            // Hide loading, show results
            document.getElementById('extractionLoadingState').style.display = 'none';
            document.getElementById('extractionResults').style.display = 'block';
          } catch (error) {
            alert('Error processing TXT file: ' + error.message);
            document.getElementById('extractionLoadingState').style.display = 'none';
            document.getElementById('uploadTxtUI').style.display = 'block';
          }
        });
        
        // PDF file analyze button
        document.getElementById('analyzePdfBtn').addEventListener('click', async function() {
          const fileInput = document.getElementById('pdfFileInput');
          const file = fileInput.files[0];
          
          if (!file) {
            alert('Please select a PDF file to analyze.');
            return;
          }
          
          // Show loading state
          document.getElementById('uploadPdfUI').style.display = 'none';
          document.getElementById('extractionLoadingState').style.display = 'block';
          document.getElementById('loadingProgressBar').style.width = '0%';
          
          try {
            // Process the PDF file to extract text
            const pdfText = await new Promise((resolve, reject) => {
              // Load PDF.js dynamically
              const script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js';
              script.onload = () => {
                const pdfjsLib = window['pdfjs-dist/build/pdf'];
                
                // Now read the file
                const reader = new FileReader();
                reader.onload = function(event) {
                  const arrayBuffer = event.target.result;
                  document.getElementById('loadingStatusText').textContent = 'Parsing PDF content...';
                  
                  // Load and parse the PDF
                  pdfjsLib.getDocument({data: arrayBuffer}).promise
                    .then(pdf => {
                      let extractedText = '';
                      let totalPages = pdf.numPages;
                      let processedPages = 0;
                      
                      // Function to process each page
                      const processPage = (pageNum) => {
                        return pdf.getPage(pageNum).then(page => {
                          return page.getTextContent().then(textContent => {
                            // Concatenate the text items with spaces
                            const pageText = textContent.items
                              .map(item => item.str)
                              .join(' ');
                            
                            extractedText += pageText + '\n\n';
                            
                            // Update progress
                            processedPages++;
                            const progress = Math.round((processedPages / totalPages) * 100);
                            document.getElementById('loadingProgressBar').style.width = `${progress}%`;
                            document.getElementById('loadingStatusText').textContent = 
                              `Extracting text: ${processedPages}/${totalPages} pages`;
                          });
                        });
                      };
                      
                      // Process pages sequentially
                      const pagePromises = [];
                      for (let i = 1; i <= totalPages; i++) {
                        pagePromises.push(() => processPage(i));
                      }
                      
                      // Chain the page processing promises
                      let sequence = Promise.resolve();
                      pagePromises.forEach(pagePromise => {
                        sequence = sequence.then(pagePromise);
                      });
                      
                      return sequence.then(() => resolve(extractedText));
                    })
                    .catch(reject);
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
              };
              
              script.onerror = () => {
                reject(new Error('Failed to load PDF.js. Check internet connection.'));
              };
              
              document.head.appendChild(script);
            });
            
            document.getElementById('loadingStatusText').textContent = 'Analyzing content for potential tablets...';
                
            // Now process the extracted text with or without AI
            if (aiApiKey) {
              document.getElementById('loadingStatusText').textContent = 'Starting AI enhancement...';
              potentialZettels = await enhanceWithAI(pdfText);
            } else {
              potentialZettels = extractStructuredZettels(pdfText);
            }
            
            // Show results
            document.getElementById('zettelCount').textContent = potentialZettels.length;
            renderPotentialZettels();
            renderImportHierarchyBrowser();
            
            // Hide loading, show results
            document.getElementById('extractionLoadingState').style.display = 'none';
            document.getElementById('extractionResults').style.display = 'block';
          } catch (error) {
            alert('Error processing PDF file: ' + error.message);
            console.error(error);
            document.getElementById('extractionLoadingState').style.display = 'none';
            document.getElementById('uploadPdfUI').style.display = 'block';
          }
        });
        
        // Add selected zettels button
        document.getElementById('addSelectedZettelsBtn').addEventListener('click', addSelectedZettelsToSystem);
        
        // Clear button
        document.getElementById('clearExtractionsBtn').addEventListener('click', function() {
          // Reset everything
          potentialZettels = [];
          
          // Show paste text UI by default
          document.getElementById('pasteTextToggle').classList.add('active');
          document.getElementById('uploadTxtToggle').classList.remove('active');
          document.getElementById('uploadPdfToggle').classList.remove('active');
          
          document.getElementById('pasteTextUI').style.display = 'block';
          document.getElementById('uploadTxtUI').style.display = 'none';
          document.getElementById('uploadPdfUI').style.display = 'none';
          
          document.getElementById('extractionResults').style.display = 'none';
          
          // Clear input fields
          document.getElementById('importTextarea').value = '';
          document.getElementById('txtFileInput').value = '';
          document.getElementById('pdfFileInput').value = '';
          document.getElementById('txtFileName').textContent = 'No file selected';
          document.getElementById('pdfFileName').textContent = 'No file selected';
          
          // Disable analyze buttons for file inputs
          document.getElementById('analyzeTxtBtn').disabled = true;
          document.getElementById('analyzePdfBtn').disabled = true;
        });
      }
      
      // Simulate progress bar for loading screen
      function simulateProgressBar() {
        const progressBar = document.getElementById('loadingProgressBar');
        let width = 0;
        
        // Reset progress
        progressBar.style.width = '0%';
        
        // Simulate progress
        const interval = setInterval(() => {
          if (width >= 90) {
            clearInterval(interval);
          } else {
            width += 5;
            progressBar.style.width = width + '%';
          }
        }, 100);
      }
      
      // Open import dialog
      function openImportDialog() {
        const dialog = document.getElementById('importExtractDialog');
        
        // Reset everything
        potentialZettels = [];
        
        // Show paste text UI by default
        document.getElementById('pasteTextToggle').classList.add('active');
        document.getElementById('uploadTxtToggle').classList.remove('active');
        document.getElementById('uploadPdfToggle').classList.remove('active');
        
        document.getElementById('pasteTextUI').style.display = 'block';
        document.getElementById('uploadTxtUI').style.display = 'none';
        document.getElementById('uploadPdfUI').style.display = 'none';
        document.getElementById('extractionLoadingState').style.display = 'none';
        document.getElementById('extractionResults').style.display = 'none';
        
        // Clear input fields
        document.getElementById('importTextarea').value = '';
        document.getElementById('txtFileInput').value = '';
        document.getElementById('pdfFileInput').value = '';
        document.getElementById('txtFileName').textContent = 'No file selected';
        document.getElementById('pdfFileName').textContent = 'No file selected';
        
        // Disable analyze buttons for file inputs
        document.getElementById('analyzeTxtBtn').disabled = true;
        document.getElementById('analyzePdfBtn').disabled = true;
        
        // Optional API enhancement UI - add notice at bottom
        const existingNotice = document.querySelector('.api-enhance-notice');
        if (!existingNotice) {
          const enhanceNotice = document.createElement('div');
          enhanceNotice.className = 'api-enhance-notice';
          enhanceNotice.style.marginTop = '20px';
          enhanceNotice.style.padding = '10px';
          enhanceNotice.style.backgroundColor = '#f0f8ff';
          enhanceNotice.style.border = '1px dashed var(--cyan)';
          enhanceNotice.style.borderRadius = '5px';
          enhanceNotice.style.fontSize = '12px';
          
          enhanceNotice.innerHTML = `
            <div style="font-weight: bold; color: var(--magenta); margin-bottom: 5px;">üß† Want Smarter Analysis?</div>
            <p style="margin: 0 0 5px 0;">Enable AI-powered extraction for more accurate results. This improves hashtag suggestions and cross-references.</p>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
              <button id="aiEnhanceBtn" class="xp-button" style="flex: 1; font-size: 11px; background: linear-gradient(to bottom, var(--magenta), #aa0088); color: white;">
                Use AI Enhancement
              </button>
              <button id="skipAiBtn" class="xp-button" style="flex: 1; font-size: 11px;">
                No Thanks
              </button>
            </div>
          `;
          
          // Add event listeners for the AI enhancement buttons
          const innerContent = document.querySelector('#importExtractDialog .dialog-inner-content');
          innerContent.appendChild(enhanceNotice);
          
          document.getElementById('aiEnhanceBtn').addEventListener('click', function() {
            // Show a setup dialog to configure API key
            showApiSetupDialog();
          });
          
          document.getElementById('skipAiBtn').addEventListener('click', function() {
            enhanceNotice.style.display = 'none';
          });
        }
        
        // Show the dialog
        dialog.style.display = 'flex';
      }
      
      // API integration helper functions
      let aiApiKey = localStorage.getItem('kettlekornAiApiKey');
      let aiApiProvider = localStorage.getItem('kettlekornAiProvider') || 'gemini';
      
      function showApiSetupDialog() {
        // Create the API setup dialog
        const setupDialog = document.createElement('div');
        setupDialog.style.position = 'fixed';
        setupDialog.style.top = '0';
        setupDialog.style.left = '0';
        setupDialog.style.right = '0';
        setupDialog.style.bottom = '0';
        setupDialog.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        setupDialog.style.zIndex = '3000';
        setupDialog.style.display = 'flex';
        setupDialog.style.justifyContent = 'center';
        setupDialog.style.alignItems = 'center';
        
        setupDialog.innerHTML = `
          <div style="background-color: #ECE9D8; border-radius: 8px; box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.5); width: 90%; max-width: 500px; max-height: 90vh; overflow: hidden;">
            <div style="background: var(--xp-title-gradient); color: white; display: flex; align-items: center; height: 28px;">
              <div style="flex-grow: 1; font-weight: bold; margin-left: 8px; font-size: 14px; text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);">AI Enhancement Setup - Windows XP</div>
              <div class="setup-dialog-close" style="width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-right: 4px; font-size: 16px; font-weight: bold; color: white; cursor: pointer; background-color: rgba(232, 17, 35, 0.8);">√ó</div>
            </div>
            <div style="padding: 15px; background-color: white; max-height: calc(90vh - 28px); overflow-y: auto;">
              <p style="margin-top: 0; font-size: 13px;">Setup AI enhancement to improve extraction quality. This requires an API key from one of the supported providers.</p>
              
              <label class="xp-label" style="margin-top: 10px;">Select AI Provider:</label>
              <select id="aiProviderSelect" class="xp-select">
                <option value="gemini" ${aiApiProvider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                <option value="openai" ${aiApiProvider === 'openai' ? 'selected' : ''}>OpenAI</option>
              </select>
              
              <div id="geminiInstructions" style="font-size: 12px; margin: 5px 0 10px 0; color: #555; ${aiApiProvider === 'gemini' ? '' : 'display: none;'}">
                Get your Gemini API key from <a href="https://ai.google.dev/" target="_blank" style="color: #0066cc;">Google AI Studio</a>
              </div>
              
              <div id="openaiInstructions" style="font-size: 12px; margin: 5px 0 10px 0; color: #555; ${aiApiProvider === 'openai' ? '' : 'display: none;'}">
                Get your OpenAI API key from your <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #0066cc;">OpenAI account</a>
              </div>
              
              <label class="xp-label">Enter API Key:</label>
              <input type="password" id="apiKeyInput" class="xp-input" value="${aiApiKey || ''}" placeholder="Enter your API key">
              
              <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button id="saveApiKeyBtn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #88ff88, #44cc44);">‚úì Save & Enable</button>
                <button id="cancelApiSetupBtn" class="xp-button" style="flex: 1; background: linear-gradient(to bottom, #ff8888, #cc4444);">‚úó Cancel</button>
              </div>
              
              <div style="font-size: 11px; margin-top: 15px; color: #777; border-top: 1px solid #ddd; padding-top: 10px;">
                Your API key is stored locally in your browser and is only used to enhance your Kettlekorn extraction.
                No data is sent to external servers except directly to the AI provider you selected.
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(setupDialog);
        
        // Add event listeners for the provider select to show/hide instructions
        document.getElementById('aiProviderSelect').addEventListener('change', function() {
          const provider = this.value;
          document.getElementById('geminiInstructions').style.display = provider === 'gemini' ? 'block' : 'none';
          document.getElementById('openaiInstructions').style.display = provider === 'openai' ? 'block' : 'none';
        });
        
        // Add event listeners
        document.querySelector('.setup-dialog-close').addEventListener('click', () => {
          document.body.removeChild(setupDialog);
        });
        
        document.getElementById('cancelApiSetupBtn').addEventListener('click', () => {
          document.body.removeChild(setupDialog);
        });
        
        document.getElementById('saveApiKeyBtn').addEventListener('click', () => {
          const newKey = document.getElementById('apiKeyInput').value.trim();
          const provider = document.getElementById('aiProviderSelect').value;
          
          if (!newKey) {
            alert('Please enter an API key');
            return;
          }
          
          // Save the API key and provider
          aiApiKey = newKey;
          aiApiProvider = provider;
          localStorage.setItem('kettlekornAiApiKey', newKey);
          localStorage.setItem('kettlekornAiProvider', provider);
          
          // Close the dialog
          document.body.removeChild(setupDialog);
          
          // Update the UI to indicate AI is now enabled
          const enhanceNotice = document.querySelector('.api-enhance-notice');
          if (enhanceNotice) {
            enhanceNotice.innerHTML = `
              <div style="font-weight: bold; color: var(--magenta); margin-bottom: 5px;">üß† AI Enhancement Active!</div>
              <p style="margin: 0;">Using ${aiApiProvider === 'gemini' ? 'Google Gemini' : 'OpenAI'} to enhance your extraction results.</p>
            `;
          }
          
          // Add an AI badge to the extract buttons
          const analyzeButtons = [
            document.getElementById('analyzeTextBtn'),
            document.getElementById('analyzeTxtBtn'),
            document.getElementById('analyzePdfBtn')
          ];
          
          analyzeButtons.forEach(btn => {
            if (btn) {
              // Add AI badge if not already present
              if (!btn.querySelector('.ai-badge')) {
                const badge = document.createElement('span');
                badge.className = 'ai-badge';
                badge.style.marginLeft = '5px';
                badge.style.fontSize = '10px';
                badge.style.backgroundColor = 'var(--magenta)';
                badge.style.color = 'white';
                badge.style.padding = '2px 5px';
                badge.style.borderRadius = '3px';
                badge.textContent = 'AI';
                btn.appendChild(badge);
              }
            }
          });
        });
      }
      
      // Function to enhance extraction with AI
      async function enhanceWithAI(text) {
        if (!aiApiKey || !text || text.length < 100) {
          // If no API key or text is too short, just use regular extraction
          return extractStructuredZettels(text);
        }
        
        try {
          // Update loading status
          const loadingStatusText = document.getElementById('loadingStatusText');
          if (loadingStatusText) {
            loadingStatusText.textContent = 'Analyzing text with AI...';
          }
          
          // Instead of processing with our basic method first, 
          // we'll send the entire text to the AI to identify and summarize key concepts
          
          // Limit text size to avoid token limits (use first ~10k chars)
          const maxChars = 10000;
          const processText = text.length > maxChars 
            ? text.substring(0, maxChars) + `\n[Note: Text truncated to ${maxChars} characters due to length]` 
            : text;
          
          // Create a smarter prompt that has the AI identify and summarize concepts
          const prompt = `
          Analyze the following text and identify key concepts that would be valuable to extract as Zettelkasten notes.
          
          For each important concept you identify:
          1. Create a concise summary (2-5 sentences) that captures the core insight
          2. Generate a clear, descriptive title (5-7 words)
          3. Suggest 3-5 relevant hashtags that align with the AntiNet Zettelkasten system focused on consciousness, AI, Mesopotamian history, and divine feminine concepts
          4. Analyze what tier type this note would be: trunk (main category), branch (major subcategory), leaf (specific idea), flower (refined idea), fruit (final output), or bud (developing idea)
          5. Extract 2-3 key concepts that could serve as cross-references
          
          Don't just extract quotes - synthesize and summarize the important concepts.
          Identify between 5-10 of the most significant concepts worthy of being saved as Zettels.
          
          HERE IS THE TEXT TO ANALYZE:
          ${processText}
          
          Provide ONLY raw JSON in your response with no explanations, additional text, or code block formatting (no \`\`\`). 
          The response should be an array of objects with the following structure:
          [
            {
              "title": "Concise Descriptive Title",
              "content": "Your synthesized summary of the concept, not just a quote from the original text",
              "hashtags": ["#tag1", "#tag2", "#tag3"],
              "tierType": "leaf",
              "keyConcepts": ["Concept1", "Concept2"]
            },
            ...
          ]
          `;
          
          // Show processing status
          if (loadingStatusText) {
            loadingStatusText.textContent = 'Waiting for AI to identify key concepts...';
          }
          
          // Create empty results array in case we need to fall back
          let aiZettels = [];
          
          // Decide which API to use based on the provider setting
          if (aiApiProvider === 'gemini') {
            // Use Google Gemini API
            aiZettels = await callGeminiDirectAPI(prompt);
          } else {
            // Use OpenAI API
            aiZettels = await callOpenAIDirectAPI(prompt);
          }
          
          // Make sure we got results back
          if (!aiZettels || aiZettels.length === 0) {
            console.warn('AI extraction returned no results, falling back to basic extraction');
            return extractStructuredZettels(text);
          }
          
          // Update the UI
          if (loadingStatusText) {
            loadingStatusText.textContent = 'Processing AI-extracted concepts...';
          }
          
          // Add additional properties needed for our UI
          const enhancedZettels = aiZettels.map((zettel, index) => {
            return {
              ...zettel,
              id: `ai-extract-${index}`,
              selected: true,
              aiEnhanced: true,
              crossRefs: generateCrossRefs(zettel.keyConcepts || [])
            };
          });
          
          return enhancedZettels;
        } catch (error) {
          console.error('AI enhancement failed:', error);
          
          // On error, fall back to the basic extraction
          return extractStructuredZettels(text);
        }
      }
      
      // Direct call to Gemini API without pre-processing
      async function callGeminiDirectAPI(prompt) {
        try {
          const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';
          
          const response = await fetch(`${API_URL}?key=${aiApiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: prompt
                }]
              }],
              generationConfig: {
                temperature: 0.2,
                maxOutputTokens: 8192
              }
            })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            console.error('Gemini API error:', errorData);
            throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Extract the text content from the response
          const textContent = data.candidates[0].content.parts[0].text;
          
          // Parse the JSON response
          return JSON.parse(textContent);
        } catch (error) {
          console.error('Error calling Gemini API:', error);
          return [];
        }
      }
      
      // Direct call to OpenAI API without pre-processing
      async function callOpenAIDirectAPI(prompt) {
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${aiApiKey}`
            },
            body: JSON.stringify({
              model: 'gpt-3.5-turbo',
              messages: [
                {
                  role: 'system',
                  content: 'You are a precise Zettelkasten analyst. Extract key concepts from text and create concise summaries. Always respond with valid JSON only, without explanation or markdown.'
                },
                {
                  role: 'user',
                  content: prompt
                }
              ],
              temperature: 0.2,
              max_tokens: 4000
            })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            console.error('OpenAI API error:', errorData);
            throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Extract the text content from the response
          const textContent = data.choices[0].message.content;
          
          // Parse the JSON response
          return JSON.parse(textContent);
        } catch (error) {
          console.error('Error calling OpenAI API:', error);
          return [];
        }
      }
      
      // Function to call Google Gemini API
      async function callGeminiAPI(prompt, fallbackZettels) {
        try {
          const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';
          
          const response = await fetch(`${API_URL}?key=${aiApiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: prompt
                }]
              }],
              generationConfig: {
                temperature: 0.2,
                maxOutputTokens: 8192
              }
            })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            console.error('Gemini API error:', errorData);
            throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Extract the text content from the response
          const textContent = data.candidates[0].content.parts[0].text;
          
          // Parse the JSON response
          const parsedResponse = JSON.parse(textContent);
          
          // Make sure we have all the original content
          return parsedResponse.map((enhanced, index) => {
            // Get the original zettel
            const original = fallbackZettels[index];
            
            // Preserve the original ID and content
            return {
              ...enhanced,
              id: original.id,
              content: original.content,
              selected: true,
              crossRefs: generateCrossRefs(enhanced.keyConcepts || [])
            };
          });
        } catch (error) {
          console.error('Error calling Gemini API:', error);
          return fallbackZettels;
        }
      }
      
      // Function to call OpenAI API
      async function callOpenAIAPI(prompt, fallbackZettels) {
        try {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${aiApiKey}`
            },
            body: JSON.stringify({
              model: 'gpt-3.5-turbo',
              messages: [
                {
                  role: 'system',
                  content: 'You are a precise JSON formatter. Always respond with valid JSON only, without explanation or markdown.'
                },
                {
                  role: 'user',
                  content: prompt
                }
              ],
              temperature: 0.2,
              max_tokens: 4000
            })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            console.error('OpenAI API error:', errorData);
            throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Extract the text content from the response
          const textContent = data.choices[0].message.content;
          
          // Parse the JSON response
          const parsedResponse = JSON.parse(textContent);
          
          // Make sure we have all the original content
          return parsedResponse.map((enhanced, index) => {
            // Get the original zettel
            const original = fallbackZettels[index];
            
            // Preserve the original ID and content
            return {
              ...enhanced,
              id: original.id,
              content: original.content,
              selected: true,
              crossRefs: generateCrossRefs(enhanced.keyConcepts || [])
            };
          });
        } catch (error) {
          console.error('Error calling OpenAI API:', error);
          return fallbackZettels;
        }
      }
      
      // Generate cross-references from key concepts
      function generateCrossRefs(keyConcepts) {
        const crossRefs = [];
        
        // Look for cards that match the key concepts
        keyConcepts.forEach(concept => {
          // Look for cards with matching titles or content
          const matchingCards = cards.filter(card => 
            card.title.toLowerCase().includes(concept.toLowerCase()) ||
            (card.content && card.content.toLowerCase().includes(concept.toLowerCase()))
          ).slice(0, 2); // Limit to 2 matches per concept
          
          // Add matching cards as cross-references
          matchingCards.forEach(card => {
            crossRefs.push({
              id: card.id,
              title: card.title,
              matchScore: 8.5 + Math.random() * 1.5 // Random score between 8.5 and 10
            });
          });
        });
        
        // Remove duplicates and return the top 3
        return [...new Map(crossRefs.map(item => [item.id, item])).values()]
          .sort((a, b) => b.matchScore - a.matchScore)
          .slice(0, 3);
      }
      
      // Close import dialog
      function closeImportDialog() {
        const dialog = document.getElementById('importExtractDialog');
        dialog.style.display = 'none';
      }
      
      // --- Initialize the Application ---
      // Load the global hashtags
      loadGlobalHashtags();
      renderGlobalHashtags();
      renderHashtagSuggestions();
      
      // Setup import/extract functionality
      setupImportTabs();
      setupFileInputs();
      setupAnalyzeButtons();
      
      // Initialize with your data
      initializeZettelkasten();
    });
  </script>
</body>
</html>