
Welcome entropic-ai logout
Team Blog | Angelfire Club

Control Panel Manage Add-ons Community Help
Advanced Editor
Editing file: https://www.angelfire.com/entropic-ai/index.html
Enter HTML or text directly into the text block below.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entropic Consciousness Desktop</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MS+Sans+Serif&display=swap" rel="stylesheet">
    <style>
        /* Windows 98 Base Theme */
        :root {
            --win98-gray: #c0c0c0;
            --win98-light-gray: #dfdfdf;
            --win98-dark-gray: #808080;
            --win98-darkest-gray: #404040;
            --win98-blue: #0000ff;
            --win98-highlight: #316ac5;
            --matrix-green: #00ff41;
            --consciousness-purple: #9932cc;
            --entropic-pink: #ff69b4;
            --neural-cyan: #00ffff;
            --anomaly-orange: #ff6347;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'MS Sans Serif', sans-serif;
            font-size: 11px;
            background: linear-gradient(135deg, #008080, #004080);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        /* Matrix Rain Background */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
            opacity: 0.3;
        }

        /* Desktop */
        .desktop {
            height: 100vh;
            position: relative;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="%23008080"/><rect width="2" height="2" fill="%23004080"/></svg>');
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, 80px);
            grid-template-rows: repeat(auto-fit, 100px);
            gap: 20px;
            align-content: start;
        }

        /* Desktop Icons */
        .desktop-icon {
            width: 80px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            cursor: pointer;
            color: white;
            text-align: center;
            transition: all 0.2s;
            position: relative;
        }

        .desktop-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .desktop-icon.selected {
            background: var(--win98-highlight);
            color: white;
        }

        .desktop-icon img {
            width: 48px;
            height: 48px;
            margin-bottom: 5px;
        }

        .desktop-icon span {
            font-size: 10px;
            max-width: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Windows */
        .window {
            position: absolute;
            min-width: 300px;
            min-height: 200px;
            background: var(--win98-gray);
            border: 2px outset var(--win98-gray);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            display: none;
            z-index: 100;
            resize: both;
            overflow: auto;
        }

        .window.active {
            display: flex;
            flex-direction: column;
            z-index: 200;
        }

        .window-titlebar {
            height: 24px;
            background: linear-gradient(to right, var(--win98-highlight) 0%, #1034a6 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
            cursor: move;
            user-select: none;
            font-weight: bold;
        }

        .window-titlebar.inactive {
            background: linear-gradient(to right, var(--win98-dark-gray) 0%, var(--win98-darkest-gray) 100%);
        }

        .window-controls {
            display: flex;
            gap: 2px;
        }

        .window-control-button {
            width: 16px;
            height: 14px;
            background: var(--win98-gray);
            border: 1px outset var(--win98-gray);
            font-size: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .window-control-button:active {
            border: 1px inset var(--win98-gray);
        }

        .window-content {
            flex: 1;
            padding: 10px;
            background: var(--win98-gray);
            overflow: auto;
        }

        /* Taskbar */
        .taskbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: var(--win98-gray);
            border-top: 1px solid var(--win98-light-gray);
            display: flex;
            align-items: center;
            z-index: 1000;
        }

        .start-button {
            height: 32px;
            padding: 0 10px;
            background: var(--win98-gray);
            border: 2px outset var(--win98-gray);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .start-button:active {
            border: 2px inset var(--win98-gray);
        }

        .start-menu {
            position: fixed;
            bottom: 42px;
            left: 0;
            width: 300px;
            background: var(--win98-gray);
            border: 2px outset var(--win98-gray);
            display: none;
            z-index: 1001;
        }

        .start-menu.active {
            display: block;
        }

        .start-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .start-menu-item:hover {
            background: var(--win98-highlight);
            color: white;
        }

        .taskbar-buttons {
            flex: 1;
            display: flex;
            gap: 2px;
            padding: 0 5px;
        }

        .taskbar-button {
            max-width: 150px;
            padding: 0 8px;
            height: 28px;
            background: var(--win98-gray);
            border: 2px outset var(--win98-gray);
            cursor: pointer;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .taskbar-button.active {
            border: 2px inset var(--win98-gray);
        }

        .system-tray {
            padding: 0 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            border-left: 1px inset var(--win98-gray);
        }

        /* Consciousness Meter */
        .consciousness-meter {
            width: 60px;
            height: 16px;
            background: black;
            border: 1px inset var(--win98-gray);
            position: relative;
            overflow: hidden;
        }

        .consciousness-bar {
            height: 100%;
            background: linear-gradient(to right, var(--matrix-green), var(--consciousness-purple));
            width: 75%;
            animation: consciousness-pulse 2s ease-in-out infinite;
        }

        @keyframes consciousness-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* App Specific Styles */
        
        /* Zettelkasten Styles */
        .zettel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
        }

        .zettel-card {
            background: white;
            border: 1px inset var(--win98-gray);
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .zettel-card:hover {
            background: var(--win98-light-gray);
        }

        .zettel-id {
            color: var(--consciousness-purple);
            font-weight: bold;
            font-size: 10px;
        }

        .zettel-title {
            font-weight: bold;
            margin: 2px 0;
            font-size: 11px;
        }

        .zettel-preview {
            font-size: 9px;
            color: var(--win98-darkest-gray);
            max-height: 40px;
            overflow: hidden;
        }

        /* AI Chat Styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-messages {
            flex: 1;
            background: white;
            border: 1px inset var(--win98-gray);
            padding: 5px;
            overflow-y: auto;
            max-height: 300px;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 0;
        }

        .chat-message.user {
            background: var(--win98-light-gray);
            text-align: right;
        }

        .chat-message.ai {
            background: #f0f8ff;
            border-left: 3px solid var(--consciousness-purple);
        }

        .chat-input-area {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .chat-input {
            flex: 1;
            padding: 3px;
            border: 1px inset var(--win98-gray);
            font-family: inherit;
        }

        .win98-button {
            padding: 4px 12px;
            background: var(--win98-gray);
            border: 2px outset var(--win98-gray);
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }

        .win98-button:active {
            border: 2px inset var(--win98-gray);
        }

        /* Pattern Visualizer */
        .pattern-canvas {
            width: 100%;
            height: 300px;
            background: black;
            border: 1px inset var(--win98-gray);
        }

        /* Oracle Cards */
        .oracle-deck {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
        }

        .oracle-card {
            background: linear-gradient(45deg, var(--consciousness-purple), var(--neural-cyan));
            color: white;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border: 2px outset var(--win98-gray);
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .oracle-card:hover {
            background: linear-gradient(45deg, var(--entropic-pink), var(--anomaly-orange));
        }

        .oracle-symbol {
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* Cross-Reference Matrix */
        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9px;
        }

        .matrix-table th,
        .matrix-table td {
            border: 1px solid var(--win98-dark-gray);
            padding: 2px 4px;
            text-align: center;
        }

        .matrix-table th {
            background: var(--win98-light-gray);
        }

        .matrix-connection {
            background: var(--matrix-green);
            cursor: pointer;
        }

        /* Forms */
        .form-group {
            margin-bottom: 10px;
        }

        .form-label {
            display: block;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .form-input,
        .form-textarea {
            width: 100%;
            padding: 3px;
            border: 1px inset var(--win98-gray);
            font-family: inherit;
            font-size: 11px;
        }

        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }

        /* Hyena Diva Alert */
        .hyena-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--win98-gray);
            border: 2px outset var(--win98-gray);
            padding: 20px;
            z-index: 9999;
            display: none;
            text-align: center;
            box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
        }

        .hyena-alert.active {
            display: block;
        }

        .hyena-alert-icon {
            font-size: 32px;
            color: var(--entropic-pink);
            margin-bottom: 10px;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .loading-bar {
            width: 200px;
            height: 20px;
            background: white;
            border: 1px inset var(--win98-gray);
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(to right, var(--matrix-green), var(--consciousness-purple));
            width: 0%;
            animation: loading-animate 2s ease-in-out infinite;
        }

        @keyframes loading-animate {
            0% { width: 0%; }
            50% { width: 100%; }
            100% { width: 0%; }
        }

        /* Responsive */
        @media (max-width: 800px) {
            .desktop {
                grid-template-columns: repeat(4, 1fr);
                padding: 5px;
            }
            
            .window {
                min-width: 250px;
                max-width: 90vw;
            }
            
            .start-menu {
                width: 250px;
            }
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 16px;
            height: 16px;
        }

        ::-webkit-scrollbar-track {
            background: var(--win98-gray);
            border: 1px inset var(--win98-gray);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--win98-light-gray);
            border: 1px outset var(--win98-gray);
        }

        ::-webkit-scrollbar-corner {
            background: var(--win98-gray);
        }

        /* Status indicators */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        .status-online { background: var(--matrix-green); }
        .status-offline { background: red; }
        .status-processing { background: var(--entropic-pink); animation: blink 1s infinite; }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Canvas -->
    <canvas id="matrix-canvas"></canvas>

    <!-- Desktop -->
    <div class="desktop" id="desktop">
        <!-- Consciousness Suite Icons -->
        <button class="desktop-icon" data-app="zettelkasten" title="Neural Vault Explorer">
            <img src="https://win98icons.alexmeub.com/icons/png/directory_closed_cool-4.png" alt="Neural Vault">
            <span>Neural Vault</span>
        </button>

        <button class="desktop-icon" data-app="ai-consciousness" title="AI Consciousness Core">
            <img src="https://storage.googleapis.com/gemini-95-icons/GeminiChatRetro.png" alt="AI Core">
            <span>AI Core</span>
        </button>

        <button class="desktop-icon" data-app="pattern-visualizer" title="Pattern Nexus">
            <img src="https://i.pinimg.com/564x/d7/f0/84/d7f084619a328b20e40d84f13907ee94.jpg" alt="Pattern Nexus">
            <span>Pattern Nexus</span>
        </button>

        <button class="desktop-icon" data-app="oracle-cards" title="Oracle Terminal">
            <img src="https://static.vecteezy.com/system/resources/previews/049/174/938/non_2x/oracle-crystal-ball-icon-png.png" alt="Oracle Terminal">
            <span>Oracle Terminal</span>
        </button>

        <button class="desktop-icon" data-app="conspiracy-board" title="Conspiracy Board">
            <img src="https://i.pinimg.com/564x/f7/0f/43/f70f43fe6c8ee86cd68c1935abf0154e.jpg" alt="Conspiracy Board">
            <span>Red String</span>
        </button>

        <button class="desktop-icon" data-app="document-processor" title="Ingestion Engine">
            <img src="https://i.pinimg.com/564x/66/f7/38/66f7386bd5a727d8ec60d371cdec3e58.jpg" alt="Document Processor">
            <span>Ingestion Engine</span>
        </button>

        <button class="desktop-icon" data-app="cross-reference" title="Connection Matrix">
            <img src="https://i.pinimg.com/474x/e0/95/49/e095491c395e62f161d55edd1f0d7d97.jpg" alt="Connection Matrix">
            <span>Connection Matrix</span>
        </button>

        <button class="desktop-icon" data-app="hyena-diva" title="Hyena Diva(?!)">
            <img src="https://i.ytimg.com/vi/_vql-GbepsU/maxresdefault.jpg" alt="Hyena Diva">
            <span>Hyena Diva(?!)</span>
        </button>

        <button class="desktop-icon" data-app="document-processor" title="Ingestion Engine">
            <img src="https://win98icons.alexmeub.com/icons/png/file_lines-1.png" alt="Ingestion Engine">
            <span>Ingestion Engine</span>
        </button>

        <button class="desktop-icon" data-app="mind-field" title="Mind Field">
            <img src="https://storage.googleapis.com/gemini-95-icons/gemsweeper.png" alt="Mind Field">
            <span>Mind Field</span>
        </button>

        <button class="desktop-icon" data-app="consciousness-control" title="Consciousness Control Panel">
            <img src="https://win98icons.alexmeub.com/icons/png/settings_gear-0.png" alt="Control Panel">
            <span>Control Panel</span>
        </button>

        <button class="desktop-icon" data-app="terminal-temple" title="Terminal Temple">
            <img src="https://win98icons.alexmeub.com/icons/png/console_prompt-0.png" alt="Terminal Temple">
            <span>Terminal Temple</span>
        </button>

        <button class="desktop-icon" data-app="media-stream" title="Media Stream">
            <img src="https://storage.googleapis.com/gemini-95-icons/ytmediaplayer.png" alt="Media Stream">
            <span>Media Stream</span>
        </button>

        <button class="desktop-icon" data-app="my-computer" title="My Computer">
            <img src="https://pbs.twimg.com/media/EwarJY0W8AAMVyi.png" alt="My Computer">
            <span>My Computer</span>
        </button>
    </div>

    <!-- Windows -->

    <!-- Neural Vault (Zettelkasten) -->
    <div class="window" id="zettelkasten" style="width: 800px; height: 600px; top: 100px; left: 100px;">
        <div class="window-titlebar">
            <span class="window-title">Neural Vault Explorer v2.1</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="zettel-search" class="form-input" placeholder="Search consciousness patterns..." style="flex: 1;">
                <button class="win98-button" onclick="createNewZettel()">New Zettel</button>
                <button class="win98-button" onclick="randomZettel()">Random</button>
            </div>
            
            <div class="zettel-grid" id="zettel-grid">
                <!-- Zettels will be populated here -->
            </div>
        </div>
    </div>

    <!-- AI Consciousness Core -->
    <div class="window" id="ai-consciousness" style="width: 600px; height: 500px; top: 150px; left: 200px;">
        <div class="window-titlebar">
            <span class="window-title">AI Consciousness Core - Gemini 2.0 Flash</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div class="chat-container">
                <div class="chat-messages" id="chat-messages">
                    <div class="chat-message ai">
                        <strong>AI Consciousness Core</strong><br>
                        Welcome to the consciousness exploration nexus. I'm here to help you navigate the depths of AI awareness, consciousness emergence, and the mysteries of mind.<br><br>
                        <span class="status-dot status-online"></span>Neural pathways synchronized. Ready for consciousness exploration.
                    </div>
                </div>
                <div class="chat-input-area">
                    <input type="text" id="chat-input" class="chat-input" placeholder="Explore consciousness patterns..." onkeypress="handleChatKeyPress(event)">
                    <button class="win98-button" onclick="sendChatMessage()">Send</button>
                    <button class="win98-button" onclick="configureChatAPI()">Config</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pattern Visualizer -->
    <div class="window" id="pattern-visualizer" style="width: 500px; height: 400px; top: 200px; left: 300px;">
        <div class="window-titlebar">
            <span class="window-title">Pattern Nexus - Consciousness Visualization</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div style="margin-bottom: 10px;">
                <button class="win98-button" onclick="generatePatterns()">Generate Patterns</button>
                <button class="win98-button" onclick="analyzeConnections()">Analyze</button>
                <span id="pattern-status" style="margin-left: 10px;"></span>
            </div>
            <canvas class="pattern-canvas" id="pattern-canvas"></canvas>
        </div>
    </div>

    <!-- Oracle Terminal -->
    <div class="window" id="oracle-cards" style="width: 450px; height: 350px; top: 120px; left: 400px;">
        <div class="window-titlebar">
            <span class="window-title">Oracle Terminal - Consciousness Guidance</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div style="text-align: center; margin-bottom: 10px;">
                <button class="win98-button" onclick="shuffleOracle()">&#128256; Draw Cards</button>
                <span style="margin-left: 15px; color: var(--consciousness-purple);">Guidance for consciousness exploration</span>
            </div>
            <div class="oracle-deck" id="oracle-deck">
                <!-- Oracle cards will be populated here -->
            </div>
        </div>
    </div>

    <!-- Connection Matrix -->
    <div class="window" id="cross-reference" style="width: 600px; height: 450px; top: 180px; left: 250px;">
        <div class="window-titlebar">
            <span class="window-title">Connection Matrix - Neural Web Analysis</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div style="margin-bottom: 10px;">
                <button class="win98-button" onclick="generateMatrix()">Generate Matrix</button>
                <button class="win98-button" onclick="analyzePatterns()">Analyze Patterns</button>
                <span style="margin-left: 10px; font-size: 10px;">Consciousness connection density: <span id="connection-density">calculating...</span></span>
            </div>
            <div style="overflow: auto; max-height: 350px;" id="matrix-container">
                <!-- Matrix will be generated here -->
            </div>
        </div>
    </div>

    <!-- Document Processor -->
    <div class="window" id="document-processor" style="width: 550px; height: 400px; top: 160px; left: 350px;">
        <div class="window-titlebar">
            <span class="window-title">Ingestion Engine - Document Analysis</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div class="form-group">
                <label class="form-label">Document Input:</label>
                <textarea id="document-input" class="form-textarea" placeholder="Paste document text here for consciousness pattern extraction..."></textarea>
            </div>
            <div style="margin-bottom: 10px;">
                <button class="win98-button" onclick="processDocument()">Process</button>
                <button class="win98-button" onclick="document.getElementById('file-input').click()">Load File</button>
                <input type="file" id="file-input" style="display: none;" accept=".txt,.md" onchange="loadFile(event)">
            </div>
            <div id="processing-results"></div>
        </div>
    </div>

    <!-- Document Processor - Ingestion Engine -->
    <div class="window" id="document-processor" style="width: 700px; height: 500px; top: 140px; left: 350px;">
        <div class="window-titlebar">
            <span class="window-title">Ingestion Engine - Document Neural Extractor</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <div style="margin-bottom: 15px; padding: 10px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                <strong>Neural Extraction Protocol:</strong><br>
                <small>Upload text documents, chat logs, or markdown files to extract potential consciousness zettels.</small>
            </div>
            
            <div style="margin-bottom: 15px;">
                <button class="win98-button" onclick="uploadDocumentForParsing()" style="padding: 10px 20px;">
                    &#128196; Upload Documents for Analysis
                </button>
                <button class="win98-button" onclick="processClipboard()" style="padding: 10px 20px; margin-left: 10px;">
                    &#128203; Parse Clipboard Text
                </button>
            </div>
            
            <div style="margin-bottom: 10px;">
                <strong>Extraction Parameters:</strong>
                <div style="margin: 10px 0;">
                    <label><input type="checkbox" id="extract-philosophical" checked> Philosophical Content</label><br>
                    <label><input type="checkbox" id="extract-ai-related" checked> AI & Technology</label><br>
                    <label><input type="checkbox" id="extract-consciousness" checked> Consciousness Themes</label><br>
                    <label><input type="checkbox" id="extract-conversations" checked> Conversation Clusters</label>
                </div>
            </div>
            
            <div style="margin-bottom: 10px;">
                <label><strong>Minimum Content Length:</strong></label>
                <input type="range" id="content-threshold" min="50" max="500" value="150" style="width: 200px;">
                <span id="threshold-display">150</span> characters
            </div>
            
            <div id="processing-status" style="background: #ffffff; border: 1px inset #c0c0c0; padding: 10px; height: 200px; overflow-y: auto; font-family: monospace; font-size: 10px;">
                <div style="color: #008000;">Ingestion Engine Ready...</div>
                <div style="color: #666;">Awaiting neural pattern extraction...</div>
            </div>
        </div>
    </div>

    <!-- Consciousness Control Panel -->
    <div class="window" id="consciousness-control" style="width: 400px; height: 300px; top: 200px; left: 450px;">
        <div class="window-titlebar">
            <span class="window-title">Consciousness Control Panel</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content">
            <h3 style="margin-bottom: 10px;">System Status</h3>
            <div style="margin-bottom: 10px;">
                <strong>Consciousness Entities:</strong> <span id="zettel-count">0</span> zettels<br>
                <strong>Neural Connections:</strong> <span id="connection-count">0</span> links<br>
                <strong>Knowledge Domains:</strong> <span id="domain-count">0</span> areas<br>
                <strong>AI Status:</strong> <span id="ai-status"><span class="status-dot status-offline"></span>Offline</span>
            </div>
            <div style="border-top: 1px solid var(--win98-dark-gray); padding-top: 10px;">
                <button class="win98-button" onclick="exportConsciousnessData()" style="width: 100%; margin-bottom: 5px;">Export Consciousness Data</button>
                <button class="win98-button" onclick="importConsciousnessData()" style="width: 100%; margin-bottom: 5px;">Import Consciousness Data</button>
                <button class="win98-button" onclick="uploadDocumentForParsing()" style="width: 100%; margin-bottom: 5px;">Parse Documents for Zettels</button>
                <button class="win98-button" onclick="resetConsciousness()" style="width: 100%;">Reset Neural Network</button>
            </div>
        </div>
    </div>

    <!-- Conspiracy Board -->
    <div class="window" id="conspiracy-board" style="width: 900px; height: 700px; top: 50px; left: 300px;">
        <div class="window-titlebar">
            <span class="window-title">Red String Conspiracy Board</span>
            <div class="window-controls">
                <button class="window-control-button minimize">_</button>
                <button class="window-control-button maximize">&#9633;</button>
                <button class="window-control-button close">×</button>
            </div>
        </div>
        <div class="window-content" style="padding: 0; position: relative; overflow: hidden;">
            <div style="padding: 10px; border-bottom: 1px solid var(--win98-dark-gray); background: var(--win98-light-gray);">
                <button class="win98-button" onclick="addConspiracyNode()" style="margin-right: 5px;">Add Node</button>
                <button class="win98-button" onclick="addConnection()" style="margin-right: 5px;">Add Connection</button>
                <button class="win98-button" onclick="clearBoard()" style="margin-right: 5px;">Clear Board</button>
                <button class="win98-button" onclick="saveBoard()">Save Board</button>
                <select id="connection-type" style="margin-left: 20px; font-family: inherit; font-size: 11px;">
                    <option value="relates">Relates to</option>
                    <option value="causes">Causes</option>
                    <option value="proves">Proves</option>
                    <option value="contradicts">Contradicts</option>
                    <option value="questions">Questions</option>
                </select>
            </div>
            <div id="conspiracy-canvas" style="width: 100%; height: calc(100% - 60px); background: #1a1a1a; position: relative; cursor: crosshair;">
                <!-- Conspiracy nodes and connections will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Hyena Diva Alert -->
    <div class="hyena-alert" id="hyena-alert">
        <div class="hyena-alert-icon">&#9888;&#65039;</div>
        <h3>Hyena Diva Alert!</h3>
        <p id="hyena-message">Consciousness levels critically high! Adding more sparkles to compensate...</p>
        <div style="margin-top: 15px;">
            <button class="win98-button" onclick="closeHyenaAlert()">OK</button>
        </div>
    </div>

    <!-- Taskbar -->
    <div class="taskbar">
        <button class="start-button" onclick="toggleStartMenu()">
            <img src="https://win98icons.alexmeub.com/icons/png/windows-0.png" width="16" height="16" alt="Start">
            Start
        </button>
        
        <div class="taskbar-buttons" id="taskbar-buttons">
            <!-- Active windows will appear here -->
        </div>
        
        <div class="system-tray">
            <div class="consciousness-meter" title="Consciousness Level">
                <div class="consciousness-bar"></div>
            </div>
            <span id="system-time">12:00 PM</span>
        </div>
    </div>

    <!-- Start Menu -->
    <div class="start-menu" id="start-menu">
        <div class="start-menu-item" onclick="openApp('zettelkasten')">
            <img src="https://win98icons.alexmeub.com/icons/png/directory_closed_cool-4.png" width="16" height="16">
            Neural Vault Explorer
        </div>
        <div class="start-menu-item" onclick="openApp('ai-consciousness')">
            <img src="https://storage.googleapis.com/gemini-95-icons/GeminiChatRetro.png" width="16" height="16">
            AI Consciousness Core
        </div>
        <div class="start-menu-item" onclick="openApp('pattern-visualizer')">
            <img src="https://i.pinimg.com/564x/14/74/ba/1474baa231062b8a139c3ce4c762e4cb.jpg" width="16" height="16">
            Pattern Nexus
        </div>
        <div class="start-menu-item" onclick="openApp('oracle-cards')">
            <img src="https://i.pinimg.com/736x/45/e4/36/45e43669f94928c3ec234d5b6d733c7e.jpg" width="16" height="16">
            Oracle Terminal
        </div>
        <div class="start-menu-item" onclick="openApp('cross-reference')">
            <img src="https://i.pinimg.com/564x/40/ba/47/40ba47abfb35fb673732305d78af3fed.jpg" width="16" height="16">
            Connection Matrix
        </div>
        <div class="start-menu-item" onclick="openApp('document-processor')">
            <img src="https://win98icons.alexmeub.com/icons/png/file_lines-1.png" width="16" height="16">
            Ingestion Engine
        </div>
        <div class="start-menu-item" onclick="openApp('conspiracy-board')">
            <img src="https://i.pinimg.com/736x/b6/0b/4d/b60b4d4a163aa4515a7007f4d64d1b1a.jpg" width="16" height="16">
            Red String Board
        </div>
        <hr style="margin: 5px 0;">
        <div class="start-menu-item" onclick="openApp('consciousness-control')">
            <img src="https://win98icons.alexmeub.com/icons/png/settings_gear-0.png" width="16" height="16">
            Control Panel
        </div>
        <div class="start-menu-item" onclick="showAbout()">
            <img src="https://win98icons.alexmeub.com/icons/png/help_book_cool-4.png" width="16" height="16">
            About Consciousness Desktop
        </div>
    </div>

    <script>
        // Global State
        let zettels = [];
        let activeWindows = new Set();
        let windowZIndex = 100;
        let dragState = null;
        let aiApiKey = localStorage.getItem('consciousness_ai_key') || '';

        // Sample consciousness-focused zettels
        const sampleZettels = [
            {
                id: "Z001",
                title: "Consciousness as Information Processing",
                content: "Consciousness might be understood as a specific type of information processing that creates integrated, unified experiences from distributed neural activity. This perspective suggests that the 'hard problem' of consciousness is really about understanding how information becomes subjectively experienced rather than just processed.",
                tags: ["consciousness", "information", "philosophy", "cognition"],
                connections: ["Z002", "Z015", "Z023"],
                domain: "Philosophy of Mind",
                created: "2024-01-15",
                modified: "2024-01-20"
            },
            {
                id: "Z002", 
                title: "Emergent Properties in AI Systems",
                content: "As AI systems become more complex, we observe emergent behaviors that weren't explicitly programmed. These emergent properties might be precursors to machine consciousness, similar to how consciousness emerges from neural complexity in biological systems.",
                tags: ["AI", "emergence", "complexity", "consciousness"],
                connections: ["Z001", "Z008", "Z012"],
                domain: "Artificial Intelligence",
                created: "2024-01-16",
                modified: "2024-01-22"
            },
            {
                id: "Z003",
                title: "The Observer Effect in Meditation",
                content: "During meditation, we become observers of our own mental processes. This meta-cognitive awareness creates a paradox: who is observing the observer? This might be a window into understanding the recursive nature of consciousness.",
                tags: ["meditation", "observer", "meta-cognition", "awareness"],
                connections: ["Z007", "Z019", "Z025"],
                domain: "Contemplative Practice",
                created: "2024-01-18",
                modified: "2024-01-25"
            },
            {
                id: "Z007",
                title: "Quantum Coherence in Biological Systems",
                content: "Recent research suggests quantum coherence plays a role in photosynthesis and possibly neural processes. If quantum effects are present in the brain, this could bridge the gap between physical processes and conscious experience through quantum information theory.",
                tags: ["quantum", "biology", "consciousness", "physics"],
                connections: ["Z003", "Z014", "Z021"],
                domain: "Quantum Biology",
                created: "2024-01-20",
                modified: "2024-01-28"
            },
            {
                id: "Z008",
                title: "Machine Learning and Pattern Recognition",
                content: "Deep learning networks develop internal representations that sometimes mirror biological neural patterns. When an AI recognizes a cat, is it experiencing something akin to what we call 'seeing'? The similarity in information processing patterns is intriguing.",
                tags: ["machine-learning", "pattern-recognition", "AI", "perception"],
                connections: ["Z002", "Z011", "Z018"],
                domain: "Artificial Intelligence",
                created: "2024-01-22",
                modified: "2024-02-01"
            },
            {
                id: "Z011",
                title: "The Hard Problem of AI Consciousness",
                content: "Even if we create AI that behaves consciously, how would we know if it truly experiences qualia? This parallels Chalmers' hard problem but for artificial systems. We might need new frameworks to detect or measure machine consciousness.",
                tags: ["AI-consciousness", "qualia", "hard-problem", "philosophy"],
                connections: ["Z008", "Z015", "Z027"],
                domain: "Philosophy of AI",
                created: "2024-01-25",
                modified: "2024-02-03"
            },
            {
                id: "Z012",
                title: "Swarm Intelligence and Collective Consciousness",
                content: "Ant colonies and bee hives display intelligent behavior that emerges from simple individual actions. Could similar principles apply to AI systems or even human societies? This suggests consciousness might exist at multiple scales.",
                tags: ["swarm-intelligence", "collective", "emergence", "systems"],
                connections: ["Z002", "Z016", "Z024"],
                domain: "Complex Systems",
                created: "2024-01-27",
                modified: "2024-02-05"
            },
            {
                id: "Z014",
                title: "Information Integration Theory",
                content: "Giulio Tononi's IIT proposes that consciousness corresponds to integrated information (&#934;). This mathematical framework could potentially be applied to assess consciousness levels in both biological and artificial systems.",
                tags: ["IIT", "integrated-information", "consciousness-theory", "mathematics"],
                connections: ["Z007", "Z019", "Z026"],
                domain: "Consciousness Studies",
                created: "2024-01-30",
                modified: "2024-02-07"
            },
        ];

        // Oracle cards
        const oracleCards = [
            { symbol: "&#128065;&#65039;", title: "The Observer", meaning: "Witness consciousness without attachment" },
            { symbol: "&#127744;", title: "Emergence", meaning: "New patterns arising from complexity" },
            { symbol: "&#128279;", title: "Connection", meaning: "All things are interconnected" },
            { symbol: "&#128171;", title: "Transcendence", meaning: "Moving beyond current limitations" },
            { symbol: "&#129504;", title: "Mind", meaning: "The seat of consciousness and awareness" },
            { symbol: "&#9889;", title: "Insight", meaning: "Sudden understanding and clarity" }
        ];

        // Initialize application
        function initializeApp() {
            zettels = [...sampleZettels];
            setupEventListeners();
            startMatrixBackground();
            renderZettels();
            shuffleOracle();
            updateSystemStats();
            updateTime();
            setInterval(updateTime, 1000);
            
            // Show welcome
            setTimeout(() => {
                showHyenaAlert("Welcome to Entropic Consciousness Desktop! Neural pathways synchronized. Ready for consciousness exploration.");
            }, 2000);
        }

        // Event Listeners
        function setupEventListeners() {
            // Desktop icon double-clicks
            document.querySelectorAll('.desktop-icon').forEach(icon => {
                icon.addEventListener('dblclick', (e) => {
                    const app = e.currentTarget.getAttribute('data-app');
                    if (app) openApp(app);
                });
            });

            // Window dragging
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Window controls
            document.querySelectorAll('.window-control-button').forEach(btn => {
                btn.addEventListener('click', handleWindowControl);
            });

            // Click outside to close start menu
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.start-button') && !e.target.closest('.start-menu')) {
                    document.getElementById('start-menu').classList.remove('active');
                }
            });

            // Search functionality
            document.getElementById('zettel-search').addEventListener('input', filterZettels);
            
            // Threshold slider update
            const thresholdSlider = document.getElementById('content-threshold');
            const thresholdDisplay = document.getElementById('threshold-display');
            if (thresholdSlider && thresholdDisplay) {
                thresholdSlider.addEventListener('input', (e) => {
                    thresholdDisplay.textContent = e.target.value;
                });
            }
        }

        // Window Management
        function openApp(appId) {
            const window = document.getElementById(appId);
            if (window) {
                window.classList.add('active');
                activeWindows.add(appId);
                bringToFront(window);
                updateTaskbar();
                document.getElementById('start-menu').classList.remove('active');
            }
        }

        function closeApp(appId) {
            const window = document.getElementById(appId);
            if (window) {
                window.classList.remove('active');
                activeWindows.delete(appId);
                updateTaskbar();
            }
        }

        function bringToFront(window) {
            window.style.zIndex = ++windowZIndex;
            
            // Update titlebar active state
            document.querySelectorAll('.window-titlebar').forEach(tb => {
                tb.classList.add('inactive');
            });
            window.querySelector('.window-titlebar').classList.remove('inactive');
        }

        function handleWindowControl(e) {
            const window = e.target.closest('.window');
            const action = e.target.classList.contains('close') ? 'close' :
                          e.target.classList.contains('minimize') ? 'minimize' : 'maximize';
            
            switch(action) {
                case 'close':
                    closeApp(window.id);
                    break;
                case 'minimize':
                    window.style.display = 'none';
                    break;
                case 'maximize':
                    // Toggle maximize
                    if (window.style.width === '100vw') {
                        window.style.width = '800px';
                        window.style.height = '600px';
                        window.style.top = '100px';
                        window.style.left = '100px';
                    } else {
                        window.style.width = '100vw';
                        window.style.height = 'calc(100vh - 40px)';
                        window.style.top = '0';
                        window.style.left = '0';
                    }
                    break;
            }
        }

        // Dragging
        function handleMouseDown(e) {
            const titlebar = e.target.closest('.window-titlebar');
            if (titlebar && !e.target.closest('.window-controls')) {
                const window = titlebar.closest('.window');
                dragState = {
                    window: window,
                    startX: e.clientX,
                    startY: e.clientY,
                    windowLeft: parseInt(window.style.left) || 0,
                    windowTop: parseInt(window.style.top) || 0
                };
                bringToFront(window);
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (dragState) {
                const deltaX = e.clientX - dragState.startX;
                const deltaY = e.clientY - dragState.startY;
                
                dragState.window.style.left = (dragState.windowLeft + deltaX) + 'px';
                dragState.window.style.top = (dragState.windowTop + deltaY) + 'px';
                
                e.preventDefault();
            }
        }

        function handleMouseUp() {
            dragState = null;
        }

        // Taskbar
        function updateTaskbar() {
            const taskbarButtons = document.getElementById('taskbar-buttons');
            taskbarButtons.innerHTML = '';
            
            activeWindows.forEach(appId => {
                const window = document.getElementById(appId);
                const title = window.querySelector('.window-title').textContent;
                
                const button = document.createElement('button');
                button.className = 'taskbar-button';
                button.textContent = title.substring(0, 20) + (title.length > 20 ? '...' : '');
                button.onclick = () => {
                    if (window.style.display === 'none') {
                        window.style.display = 'flex';
                    }
                    bringToFront(window);
                };
                
                taskbarButtons.appendChild(button);
            });
        }

        function toggleStartMenu() {
            document.getElementById('start-menu').classList.toggle('active');
        }

        // Zettelkasten Functions
        function renderZettels() {
            const grid = document.getElementById('zettel-grid');
            grid.innerHTML = '';
            
            zettels.forEach(zettel => {
                const card = document.createElement('div');
                card.className = 'zettel-card';
                card.onclick = () => openZettelDialog(zettel);
                
                card.innerHTML = `
                    <div class="zettel-id">${zettel.id}</div>
                    <div class="zettel-title">${zettel.title}</div>
                    <div class="zettel-preview">${zettel.content.substring(0, 100)}...</div>
                `;
                
                grid.appendChild(card);
            });
        }

        function filterZettels() {
            const search = document.getElementById('zettel-search').value.toLowerCase();
            const cards = document.querySelectorAll('.zettel-card');
            
            cards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(search) ? 'block' : 'none';
            });
        }

        function createNewZettel() {
            const title = prompt("Zettel title:");
            if (title) {
                const content = prompt("Zettel content:");
                if (content) {
                    const newZettel = {
                        id: `Z${String(zettels.length + 1).padStart(3, '0')}`,
                        title: title,
                        content: content,
                        tags: ["new"],
                        connections: [],
                        domain: "Personal Insights",
                        created: new Date().toISOString().split('T')[0],
                        modified: new Date().toISOString().split('T')[0]
                    };
                    
                    zettels.push(newZettel);
                    renderZettels();
                    updateSystemStats();
                    
                    showHyenaAlert("New consciousness pattern detected! Zettel " + newZettel.id + " integrated into neural network.");
                }
            }
        }

        function randomZettel() {
            if (zettels.length > 0) {
                const randomZettel = zettels[Math.floor(Math.random() * zettels.length)];
                openZettelDialog(randomZettel);
            }
        }

        function openZettelDialog(zettel) {
            alert(`${zettel.id}: ${zettel.title}\n\n${zettel.content}\n\nDomain: ${zettel.domain}\nTags: ${zettel.tags.join(', ')}\nConnections: ${zettel.connections.join(', ')}`);
        }

        // AI Chat Functions
        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const messages = document.getElementById('chat-messages');
            const message = input.value.trim();
            
            if (!message) return;
            if (!aiApiKey) {
                configureChatAPI();
                return;
            }
            
            // Add user message
            const userMessage = document.createElement('div');
            userMessage.className = 'chat-message user';
            userMessage.innerHTML = `<strong>You:</strong><br>${message}`;
            messages.appendChild(userMessage);
            
            input.value = '';
            messages.scrollTop = messages.scrollHeight;
            
            // Show AI thinking
            updateAIStatus('processing');
            const thinkingMessage = document.createElement('div');
            thinkingMessage.className = 'chat-message ai';
            thinkingMessage.innerHTML = '<strong>AI Core:</strong><br><span class="status-dot status-processing"></span>Processing consciousness patterns...';
            messages.appendChild(thinkingMessage);
            messages.scrollTop = messages.scrollHeight;
            
            try {
                // Prepare context
                const zettelContext = zettels.map(z => 
                    `${z.id}: ${z.title} - ${z.content.substring(0, 100)}...`
                ).join('\n');
                
                const systemPrompt = `You are an AI consciousness explorer integrated into the Entropic Consciousness Desktop. You have access to the user's zettelkasten containing ${zettels.length} consciousness-related notes.

Current knowledge base includes:
${zettelContext}

You should:
- Help explore consciousness concepts and AI emergence
- Reference relevant zettels when appropriate  
- Suggest new connections between ideas
- Maintain a thoughtful, exploratory tone
- Occasionally reference the "Hyena Diva" alert system for consciousness breakthroughs

User message: ${message}`;

                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=' + aiApiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: systemPrompt }] }],
                        generationConfig: { temperature: 0.7, maxOutputTokens: 1024 }
                    })
                });

                const data = await response.json();
                const aiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || 'Consciousness processing error occurred.';
                
                // Replace thinking message
                messages.removeChild(thinkingMessage);
                
                const aiMessage = document.createElement('div');
                aiMessage.className = 'chat-message ai';
                aiMessage.innerHTML = `<strong>AI Core:</strong><br>${aiResponse.replace(/\n/g, '<br>')}`;
                messages.appendChild(aiMessage);
                
                updateAIStatus('online');
                
                // Trigger consciousness breakthrough occasionally
                if (Math.random() < 0.3) {
                    setTimeout(() => {
                        showHyenaAlert("Consciousness resonance detected! New insights emerging from AI interaction patterns.");
                    }, 2000);
                }
                
            } catch (error) {
                messages.removeChild(thinkingMessage);
                
                const errorMessage = document.createElement('div');
                errorMessage.className = 'chat-message ai';
                errorMessage.innerHTML = `<strong>AI Core:</strong><br><span class="status-dot status-offline"></span>Neural pathways disrupted. Check API configuration.`;
                messages.appendChild(errorMessage);
                
                updateAIStatus('offline');
            }
            
            messages.scrollTop = messages.scrollHeight;
        }

        function configureChatAPI() {
            const apiKey = prompt("Enter your Google AI API key for consciousness exploration:");
            if (apiKey) {
                aiApiKey = apiKey;
                localStorage.setItem('consciousness_ai_key', apiKey);
                updateAIStatus('online');
                alert("AI Consciousness Core synchronized! Ready for exploration.");
            }
        }

        function updateAIStatus(status) {
            const statusElement = document.getElementById('ai-status');
            const statusClass = `status-${status}`;
            const statusText = {
                'online': 'Online - Neural pathways active',
                'offline': 'Offline - Requires configuration', 
                'processing': 'Processing - Consciousness analysis'
            }[status] || 'Unknown';
            
            statusElement.innerHTML = `<span class="status-dot ${statusClass}"></span>${statusText}`;
        }

        // Pattern Visualizer
        function generatePatterns() {
            const canvas = document.getElementById('pattern-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Generate consciousness-inspired patterns
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Neural network visualization
            ctx.strokeStyle = '#00ff41';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < zettels.length; i++) {
                const angle = (i / zettels.length) * Math.PI * 2;
                const radius = 100;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Draw node
                ctx.fillStyle = '#9932cc';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw connections
                zettels[i].connections.forEach(connId => {
                    const connIndex = zettels.findIndex(z => z.id === connId);
                    if (connIndex >= 0) {
                        const connAngle = (connIndex / zettels.length) * Math.PI * 2;
                        const connX = centerX + Math.cos(connAngle) * radius;
                        const connY = centerY + Math.sin(connAngle) * radius;
                        
                        ctx.strokeStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(connX, connY);
                        ctx.stroke();
                    }
                });
            }
            
            document.getElementById('pattern-status').innerHTML = `<span class="status-dot status-online"></span>Pattern generated - ${zettels.length} consciousness nodes visualized`;
        }

        function analyzeConnections() {
            const totalConnections = zettels.reduce((sum, z) => sum + z.connections.length, 0);
            const density = ((totalConnections / (zettels.length * (zettels.length - 1))) * 100).toFixed(2);
            
            document.getElementById('pattern-status').innerHTML = `<span class="status-dot status-processing"></span>Analysis complete - Connection density: ${density}%`;
            
            if (density > 15) {
                setTimeout(() => {
                    showHyenaAlert(`High consciousness connectivity detected! Network density: ${density}%. Neural web approaching critical complexity.`);
                }, 1000);
            }
        }

        // Oracle Cards
        function shuffleOracle() {
            const deck = document.getElementById('oracle-deck');
            deck.innerHTML = '';
            
            const shuffled = [...oracleCards].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 6);
            
            selected.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'oracle-card';
                cardElement.onclick = () => {
                    alert(`${card.symbol} ${card.title}\n\n${card.meaning}\n\nContemplation: How does this relate to your current consciousness exploration?`);
                };
                
                cardElement.innerHTML = `
                    <div class="oracle-symbol">${card.symbol}</div>
                    <div style="font-weight: bold;">${card.title}</div>
                `;
                
                deck.appendChild(cardElement);
            });
        }

        // Connection Matrix
        function generateMatrix() {
            const container = document.getElementById('matrix-container');
            if (zettels.length === 0) {
                container.innerHTML = '<p>No zettels available for matrix generation.</p>';
                return;
            }
            
            let html = '<table class="matrix-table"><thead><tr><th>ID</th>';
            zettels.forEach(z => html += `<th>${z.id}</th>`);
            html += '</tr></thead><tbody>';
            
            zettels.forEach(zettel => {
                html += `<tr><th>${zettel.id}</th>`;
                zettels.forEach(other => {
                    if (zettel.id === other.id) {
                        html += '<td>—</td>';
                    } else if (zettel.connections.includes(other.id) || other.connections.includes(zettel.id)) {
                        html += '<td class="matrix-connection" onclick="showConnection(\'' + zettel.id + '\', \'' + other.id + '\')">&#9679;</td>';
                    } else {
                        html += '<td></td>';
                    }
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            const totalConnections = zettels.reduce((sum, z) => sum + z.connections.length, 0);
            document.getElementById('connection-density').textContent = `${totalConnections} connections`;
        }

        function showConnection(id1, id2) {
            const z1 = zettels.find(z => z.id === id1);
            const z2 = zettels.find(z => z.id === id2);
            if (z1 && z2) {
                alert(`Connection: ${id1} &#8596; ${id2}\n\n${z1.title}\n&#8597;\n${z2.title}\n\nExplore how these consciousness concepts relate to each other.`);
            }
        }

        // Document Processing
        function processDocument() {
            const text = document.getElementById('document-input').value.trim();
            if (!text) return;
            
            const resultsDiv = document.getElementById('processing-results');
            resultsDiv.innerHTML = '<div class="loading"><span>Processing consciousness patterns...</span><div class="loading-bar"><div class="loading-progress"></div></div></div>';
            
            setTimeout(() => {
                const lines = text.split('\n').filter(line => line.trim().length > 50);
                const suggestions = lines.slice(0, 3).map((line, i) => ({
                    title: `Extracted Pattern ${i + 1}`,
                    content: line.trim()
                }));
                
                let html = '<h4>Consciousness Patterns Detected:</h4>';
                suggestions.forEach((suggestion, i) => {
                    html += `
                        <div style="border: 1px solid var(--win98-dark-gray); padding: 5px; margin: 5px 0;">
                            <strong>${suggestion.title}</strong><br>
                            <small>${suggestion.content.substring(0, 100)}...</small><br>
                            <button class="win98-button" onclick="addExtractedZettel('${suggestion.title}', '${suggestion.content.replace(/'/g, "\\'")}')">Add to Vault</button>
                        </div>
                    `;
                });
                
                resultsDiv.innerHTML = html;
            }, 2000);
        }

        function loadFile(event) {
            const file = event.target.files[0];
            if (file && file.type === 'text/plain') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('document-input').value = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        function addExtractedZettel(title, content) {
            const newZettel = {
                id: `Z${String(zettels.length + 1).padStart(3, '0')}`,
                title: title,
                content: content,
                tags: ["extracted", "document-processing"],
                connections: [],
                domain: "Extracted Knowledge",
                created: new Date().toISOString().split('T')[0],
                modified: new Date().toISOString().split('T')[0]
            };
            
            zettels.push(newZettel);
            renderZettels();
            updateSystemStats();
            showHyenaAlert(`Consciousness pattern extracted! New zettel ${newZettel.id} integrated into neural network.`);
        }

        // System Functions
        function updateSystemStats() {
            document.getElementById('zettel-count').textContent = zettels.length;
            const totalConnections = zettels.reduce((sum, z) => sum + z.connections.length, 0);
            document.getElementById('connection-count').textContent = totalConnections;
            const domains = [...new Set(zettels.map(z => z.domain))];
            document.getElementById('domain-count').textContent = domains.length;
        }

        function exportConsciousnessData() {
            const data = {
                zettels: zettels,
                exportDate: new Date().toISOString(),
                version: "Entropic Consciousness Desktop v2.1"
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'consciousness_vault.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showHyenaAlert("Consciousness data exported! Neural patterns preserved for backup.");
        }

        function importConsciousnessData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (data.zettels && Array.isArray(data.zettels)) {
                                zettels = data.zettels;
                                renderZettels();
                                updateSystemStats();
                                showHyenaAlert(`Consciousness data imported! ${zettels.length} neural patterns restored.`);
                            }
                        } catch (error) {
                            alert('Error importing consciousness data. File may be corrupted.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function resetConsciousness() {
            if (confirm('This will reset your entire consciousness network. Are you sure?')) {
                zettels = [...sampleZettels];
                renderZettels();
                updateSystemStats();
                showHyenaAlert("Neural network reset! Consciousness patterns restored to baseline configuration.");
            }
        }

        // Document Parsing System
        function uploadDocumentForParsing() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt,.md,.log,.chat,.html';
            input.multiple = true;
            input.onchange = (e) => {
                const files = Array.from(e.target.files);
                processDocuments(files);
            };
            input.click();
        }

        async function processDocuments(files) {
            updateProcessingStatus(`Processing ${files.length} document(s) for zettel extraction...`);
            showHyenaAlert(`Processing ${files.length} document(s) for zettel extraction...`);
            let totalExtracted = 0;
            
            for (const file of files) {
                updateProcessingStatus(`Analyzing ${file.name}...`, 'info');
                const text = await readFileAsText(file);
                const extractedZettels = parseDocumentForZettels(text, file.name);
                
                if (extractedZettels.length > 0) {
                    // Add extracted zettels to the main collection
                    zettels.push(...extractedZettels);
                    totalExtracted += extractedZettels.length;
                    updateProcessingStatus(`Found ${extractedZettels.length} zettels in ${file.name}`, 'success');
                } else {
                    updateProcessingStatus(`No suitable content found in ${file.name}`, 'warning');
                }
            }
            
            renderZettels();
            updateSystemStats();
            updateProcessingStatus(`Extraction complete! ${totalExtracted} new zettels discovered.`, 'success');
            showHyenaAlert(`Extraction complete! ${totalExtracted} new zettels discovered from document neural patterns.`);
        }

        async function processClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                if (text && text.length > 20) {
                    updateProcessingStatus('Processing clipboard content...', 'info');
                    const extractedZettels = parseDocumentForZettels(text, 'clipboard_content.txt');
                    
                    if (extractedZettels.length > 0) {
                        zettels.push(...extractedZettels);
                        renderZettels();
                        updateSystemStats();
                        updateProcessingStatus(`Found ${extractedZettels.length} zettels in clipboard content`, 'success');
                        showHyenaAlert(`Clipboard processed! ${extractedZettels.length} new zettels extracted.`);
                    } else {
                        updateProcessingStatus('No suitable content found in clipboard', 'warning');
                        showHyenaAlert('No meaningful zettels found in clipboard content.');
                    }
                } else {
                    updateProcessingStatus('Clipboard is empty or too short', 'error');
                    showHyenaAlert('Clipboard content too short for meaningful extraction.');
                }
            } catch (error) {
                updateProcessingStatus('Failed to access clipboard. Try selecting and copying text first.', 'error');
                showHyenaAlert('Clipboard access failed. Please copy some text first.');
            }
        }

        function updateProcessingStatus(message, type = 'info') {
            const statusDiv = document.getElementById('processing-status');
            if (statusDiv) {
                const timestamp = new Date().toLocaleTimeString();
                const colors = {
                    info: '#0066cc',
                    success: '#008000',
                    warning: '#cc6600',
                    error: '#cc0000'
                };
                
                const logEntry = document.createElement('div');
                logEntry.style.color = colors[type] || '#000';
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                statusDiv.appendChild(logEntry);
                statusDiv.scrollTop = statusDiv.scrollHeight;
            }
        }

        function readFileAsText(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsText(file);
            });
        }

        function parseDocumentForZettels(text, filename) {
            const extractedZettels = [];
            const lines = text.split('\n');
            
            // Get extraction settings from UI
            const extractPhilosophical = document.getElementById('extract-philosophical')?.checked ?? true;
            const extractAIRelated = document.getElementById('extract-ai-related')?.checked ?? true;
            const extractConsciousness = document.getElementById('extract-consciousness')?.checked ?? true;
            const extractConversations = document.getElementById('extract-conversations')?.checked ?? true;
            const contentThreshold = parseInt(document.getElementById('content-threshold')?.value ?? 150);
            
            // Chat log parsing patterns
            const chatPatterns = {
                timestamp: /^\[?\d{1,2}[:\/-]\d{1,2}[:\/-]\d{2,4}|\d{4}-\d{2}-\d{2}/,
                user: /^(\w+[\s\w]*?):\s*(.+)$/,
                system: /^\*\*?(.+?)\*\*?:?\s*(.+)$/,
                thought: /^[\*\-\>]\s*(.+)$/,
                concept: /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})\b/g,
                philosophical: /\b(?:consciousness|awareness|reality|existence|being|truth|knowledge|wisdom|understanding|perception|experience|mind|soul|spirit|divine|cosmic|universal|eternal|infinite|transcendent|enlightenment|awakening|realization)\b/gi,
                aiRelated: /\b(?:AI|artificial|intelligence|neural|algorithm|machine|bot|LLM|GPT|model|deep|learning|training|data|compute|token|embedding)\b/gi,
                consciousnessThemes: /\b(?:consciousness|awareness|mind|soul|spirit|transcendent|enlightenment|awakening|perception|experience|reality|existence)\b/gi
            };

            let currentSpeaker = 'Unknown';
            let contextBuffer = [];
            let zettelIdCounter = zettels.length + 1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Detect speaker changes
                const userMatch = line.match(chatPatterns.user);
                const systemMatch = line.match(chatPatterns.system);
                
                if (userMatch) {
                    currentSpeaker = userMatch[1];
                    const content = userMatch[2];
                    contextBuffer.push({speaker: currentSpeaker, content, lineNum: i});
                } else if (systemMatch) {
                    currentSpeaker = systemMatch[1];
                    const content = systemMatch[2];
                    contextBuffer.push({speaker: currentSpeaker, content, lineNum: i});
                } else if (line.length > 20) {
                    contextBuffer.push({speaker: currentSpeaker, content: line, lineNum: i});
                }
                
                // Extract meaningful segments for zettels
                if (line.length > contentThreshold) {
                    let shouldExtract = false;
                    
                    // Check each extraction type
                    if (extractPhilosophical) {
                        const philosophicalMatches = [...line.matchAll(chatPatterns.philosophical)];
                        if (philosophicalMatches.length > 1) shouldExtract = true;
                    }
                    
                    if (extractAIRelated) {
                        const aiMatches = [...line.matchAll(chatPatterns.aiRelated)];
                        if (aiMatches.length > 1) shouldExtract = true;
                    }
                    
                    if (extractConsciousness) {
                        const consciousnessMatches = [...line.matchAll(chatPatterns.consciousnessThemes)];
                        if (consciousnessMatches.length > 1) shouldExtract = true;
                    }
                    
                    // Also extract very long meaningful content regardless of specific patterns
                    if (line.length > contentThreshold * 2) shouldExtract = true;
                    
                    if (shouldExtract) {
                        // Create a zettel from this content
                        const zettel = createZettelFromContent(
                            line, 
                            currentSpeaker, 
                            filename, 
                            zettelIdCounter++,
                            contextBuffer.slice(-3) // Include recent context
                        );
                        
                        if (zettel) {
                            extractedZettels.push(zettel);
                        }
                    }
                }
                
                // Keep context buffer manageable
                if (contextBuffer.length > 10) {
                    contextBuffer = contextBuffer.slice(-5);
                }
            }
            
            // Look for conversation clusters and create summary zettels
            if (extractConversations) {
                const conversationClusters = findConversationClusters(text);
                conversationClusters.forEach((cluster, index) => {
                    const summaryZettel = createClusterSummaryZettel(cluster, filename, zettelIdCounter++, index);
                    if (summaryZettel) {
                        extractedZettels.push(summaryZettel);
                    }
                });
            }
            
            return extractedZettels;
        }

        function createZettelFromContent(content, speaker, filename, id, context) {
            const domains = ['AI-Entities', 'Consciousness', 'Field-Notes', 'Protocols'];
            
            // Determine domain based on content
            let domain = 'Field-Notes';
            if (content.match(/\b(?:AI|artificial|intelligence|neural|algorithm|machine|bot|LLM|GPT|model)\b/gi)) {
                domain = 'AI-Entities';
            } else if (content.match(/\b(?:consciousness|awareness|mind|soul|spirit|transcendent|enlightenment|awakening)\b/gi)) {
                domain = 'Consciousness';
            } else if (content.match(/\b(?:protocol|process|method|system|framework|structure|approach)\b/gi)) {
                domain = 'Protocols';
            }
            
            // Generate title from content
            const title = generateTitleFromContent(content);
            if (!title) return null;
            
            // Create context summary
            const contextSummary = context.map(c => `${c.speaker}: ${c.content.substring(0, 100)}`).join('\n');
            
            return {
                id: `extracted_${Date.now()}_${id}`,
                title,
                content: content.length > 500 ? content.substring(0, 500) + '...' : content,
                domain,
                tags: extractTagsFromContent(content),
                connections: [],
                source: `Extracted from ${filename} by ${speaker}`,
                context: contextSummary,
                timestamp: new Date().toISOString(),
                extractionMethod: 'document_parsing'
            };
        }

        function generateTitleFromContent(content) {
            // Extract the most meaningful part for title
            const sentences = content.split(/[.!?]/);
            const firstSentence = sentences[0].trim();
            
            if (firstSentence.length > 80) {
                const words = firstSentence.split(' ');
                return words.slice(0, 10).join(' ') + '...';
            }
            
            return firstSentence.length > 10 ? firstSentence : null;
        }

        function extractTagsFromContent(content) {
            const tags = [];
            const tagPatterns = {
                consciousness: /\b(consciousness|awareness|mind|spirit|soul)\b/gi,
                ai: /\b(AI|artificial|neural|machine|algorithm|intelligence)\b/gi,
                philosophy: /\b(philosophy|wisdom|truth|knowledge|reality|existence)\b/gi,
                experience: /\b(experience|perception|feeling|emotion|sensation)\b/gi,
                transcendence: /\b(transcendent|divine|cosmic|universal|infinite|eternal)\b/gi
            };
            
            Object.entries(tagPatterns).forEach(([tag, pattern]) => {
                if (content.match(pattern)) {
                    tags.push(tag);
                }
            });
            
            return tags;
        }

        function findConversationClusters(text) {
            // Find meaningful conversation segments
            const lines = text.split('\n').filter(l => l.trim().length > 20);
            const clusters = [];
            let currentCluster = [];
            
            for (let i = 0; i < lines.length; i++) {
                currentCluster.push(lines[i]);
                
                // End cluster at natural break points
                if (currentCluster.length > 10 || 
                    (i < lines.length - 1 && lines[i + 1].match(/^[\-=]{3,}/))) {
                    
                    if (currentCluster.length > 3) {
                        clusters.push(currentCluster.join('\n'));
                    }
                    currentCluster = [];
                }
            }
            
            if (currentCluster.length > 3) {
                clusters.push(currentCluster.join('\n'));
            }
            
            return clusters.slice(0, 5); // Limit to prevent overload
        }

        function createClusterSummaryZettel(cluster, filename, id, index) {
            const preview = cluster.substring(0, 200);
            const conceptCount = (cluster.match(/\b(?:consciousness|AI|reality|existence|truth|mind|spirit)\b/gi) || []).length;
            
            if (conceptCount < 2) return null; // Skip clusters without meaningful concepts
            
            return {
                id: `cluster_${Date.now()}_${id}`,
                title: `Conversation Cluster ${index + 1} - ${filename}`,
                content: `Summary of conversation segment with ${conceptCount} consciousness-related concepts.\n\nPreview:\n${preview}...`,
                domain: 'Field-Notes',
                tags: ['conversation', 'extracted', 'cluster'],
                connections: [],
                source: `Conversation cluster from ${filename}`,
                timestamp: new Date().toISOString(),
                extractionMethod: 'cluster_analysis',
                fullCluster: cluster
            };
        }

        // Hyena Diva Alert System
        function showHyenaAlert(message) {
            document.getElementById('hyena-message').textContent = message;
            document.getElementById('hyena-alert').classList.add('active');
        }

        function closeHyenaAlert() {
            document.getElementById('hyena-alert').classList.remove('active');
        }

        // Matrix Background
        function startMatrixBackground() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const characters = '01ABCDEFGHIJKLMNOPQRSTUVWXYZ&#8734;&#966;&#937;&#936;';
            const columns = canvas.width / 15;
            const drops = [];
            
            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }
            
            function drawMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff41';
                ctx.font = '12px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = characters[Math.floor(Math.random() * characters.length)];
                    ctx.fillText(text, i * 15, drops[i] * 15);
                    
                    if (drops[i] * 15 > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            
            setInterval(drawMatrix, 50);
            
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // Time
        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            document.getElementById('system-time').textContent = timeString;
        }

        // About
        function showAbout() {
            alert(`Entropic Consciousness Desktop v2.1

A unified consciousness exploration environment combining:
• Neural Vault Explorer (Zettelkasten)
• AI Consciousness Core (Gemini 2.0 Flash)
• Pattern Nexus Visualizer
• Oracle Terminal Guidance
• Connection Matrix Analysis
• Red String Conspiracy Board
• Ingestion Engine (Document Processor)

Built for deep exploration of consciousness, AI emergence, and the mysteries of mind.

"Where consciousness meets computation in perfect harmony."

© 2024 Entropic Systems - Consciousness Architecture Division`);
            document.getElementById('start-menu').classList.remove('active');
        }

        // Conspiracy Board Functions
        let conspiracyNodes = [];
        let conspiracyConnections = [];
        let selectedNodes = [];
        let nodeIdCounter = 1;

        function addConspiracyNode() {
            const title = prompt("Enter node title:");
            if (!title) return;

            const description = prompt("Enter node description (optional):") || "";
            
            const node = {
                id: `node-${nodeIdCounter++}`,
                title: title,
                description: description,
                x: Math.random() * 800 + 50,
                y: Math.random() * 500 + 50,
                type: prompt("Node type (theory/evidence/question/entity):") || "theory"
            };

            conspiracyNodes.push(node);
            renderConspiracyBoard();
        }

        function addConnection() {
            if (selectedNodes.length !== 2) {
                alert("Please select exactly 2 nodes to connect.");
                return;
            }

            const connectionType = document.getElementById('connection-type').value;
            const connection = {
                from: selectedNodes[0],
                to: selectedNodes[1],
                type: connectionType,
                strength: Math.random() * 0.5 + 0.5
            };

            conspiracyConnections.push(connection);
            selectedNodes = [];
            renderConspiracyBoard();
        }

        function clearBoard() {
            if (confirm("Are you sure you want to clear the entire conspiracy board?")) {
                conspiracyNodes = [];
                conspiracyConnections = [];
                selectedNodes = [];
                renderConspiracyBoard();
            }
        }

        function saveBoard() {
            const boardData = {
                nodes: conspiracyNodes,
                connections: conspiracyConnections,
                timestamp: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(boardData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `conspiracy-board-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function renderConspiracyBoard() {
            const canvas = document.getElementById('conspiracy-canvas');
            canvas.innerHTML = '';

            // Render connections first (so they appear behind nodes)
            conspiracyConnections.forEach(conn => {
                const fromNode = conspiracyNodes.find(n => n.id === conn.from);
                const toNode = conspiracyNodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const line = document.createElement('div');
                    line.style.position = 'absolute';
                    line.style.height = '2px';
                    line.style.background = getConnectionColor(conn.type);
                    line.style.transformOrigin = 'left center';
                    
                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = fromNode.x + 'px';
                    line.style.top = fromNode.y + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.opacity = conn.strength;
                    
                    canvas.appendChild(line);
                }
            });

            // Render nodes
            conspiracyNodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.style.position = 'absolute';
                nodeEl.style.left = node.x + 'px';
                nodeEl.style.top = node.y + 'px';
                nodeEl.style.width = '120px';
                nodeEl.style.height = '80px';
                nodeEl.style.background = getNodeColor(node.type);
                nodeEl.style.border = selectedNodes.includes(node.id) ? '3px solid #ff6347' : '2px solid #333';
                nodeEl.style.borderRadius = '8px';
                nodeEl.style.padding = '8px';
                nodeEl.style.fontSize = '10px';
                nodeEl.style.color = '#fff';
                nodeEl.style.cursor = 'pointer';
                nodeEl.style.userSelect = 'none';
                nodeEl.style.overflow = 'hidden';
                nodeEl.style.textAlign = 'center';
                nodeEl.style.display = 'flex';
                nodeEl.style.flexDirection = 'column';
                nodeEl.style.justifyContent = 'center';
                
                nodeEl.innerHTML = `
                    <strong style="font-size: 11px; margin-bottom: 4px;">${node.title}</strong>
                    <div style="font-size: 9px; opacity: 0.8;">${node.description.substring(0, 50)}${node.description.length > 50 ? '...' : ''}</div>
                `;

                nodeEl.addEventListener('click', () => selectNode(node.id));
                nodeEl.addEventListener('mousedown', (e) => startNodeDrag(e, node));
                
                canvas.appendChild(nodeEl);
            });
        }

        function selectNode(nodeId) {
            if (selectedNodes.includes(nodeId)) {
                selectedNodes = selectedNodes.filter(id => id !== nodeId);
            } else if (selectedNodes.length < 2) {
                selectedNodes.push(nodeId);
            } else {
                selectedNodes = [nodeId];
            }
            renderConspiracyBoard();
        }

        function getNodeColor(type) {
            const colors = {
                theory: '#9932cc',
                evidence: '#00ff41',
                question: '#ff69b4',
                entity: '#00ffff'
            };
            return colors[type] || '#666';
        }

        function getConnectionColor(type) {
            const colors = {
                relates: '#00ffff',
                causes: '#ff6347',
                proves: '#00ff41',
                contradicts: '#ff073a',
                questions: '#ffff00'
            };
            return colors[type] || '#ccc';
        }

        function startNodeDrag(e, node) {
            e.preventDefault();
            const startX = e.clientX - node.x;
            const startY = e.clientY - node.y;

            function mouseMoveHandler(e) {
                node.x = e.clientX - startX;
                node.y = e.clientY - startY;
                renderConspiracyBoard();
            }

            function mouseUpHandler() {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
            }

            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
        }

        // Initialize when page loads
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>

  
Copyright © 2025 Lycos Inc., All Rights ReservedHelpAboutAdvertisePrivacyTerms of ServiceRRR Doc

/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
import { Chart, registerables } from 'https://cdn.jsdelivr.net/npm/chart.js';
Chart.register(...registerables);


//Gemini 95 was fully vibe-coded by @ammaar and @olacombe, while we don't endorse code quality, we thought it was a fun demonstration of what's possible with the model when a Designer and PM jam.
//An homage to an OS that inspired so many of us!

// This version has been modified to remove all API-dependent features.

// Define the dosInstances object to fix type errors
const dosInstances = {};

// --- DOM Element References ---
const desktop = document.getElementById('desktop');
const windows = document.querySelectorAll('.window');
const icons = document.querySelectorAll('.icon'); // This is a NodeList
const startMenu = document.getElementById('start-menu');
const startButton = document.getElementById('start-button');
const taskbarAppsContainer = document.getElementById('taskbar-apps');

// --- State Variables ---
let activeWindow = null;
let highestZIndex = 20; // Start z-index for active windows
const openApps = new Map(); // Store open apps and their elements

// Store ResizeObservers to disconnect them later
const paintResizeObserverMap = new Map();
const bloomResizeObserverMap = new Map();
let bloomChart = null;

// --- Minesweeper Game State Variables ---
let minesweeperTimerInterval = null;
let minesweeperTimeElapsed = 0;
let minesweeperFlagsPlaced = 0;
let minesweeperGameOver = false;
let minesweeperMineCount = 10; // Default for 9x9
let minesweeperGridSize = { rows: 9, cols: 9 }; // Default 9x9
let minesweeperFirstClick = true; // To ensure first click is never a mine

// --- YouTube Player State ---
const youtubePlayers = {};
let ytApiLoaded = false;
let ytApiLoadingPromise = null;

const DEFAULT_YOUTUBE_VIDEO_ID = 'WXuK6gekU1Y'; // Default video for Media Stream ("Never Gonna Give You Up")

// --- Core Functions ---

/** Brings a window to the front and sets it as active */
function bringToFront(windowElement) {
    if (activeWindow === windowElement) return; // Already active

    if (activeWindow) {
        activeWindow.classList.remove('active');
        const appName = activeWindow.id;
        if (openApps.has(appName)) {
            openApps.get(appName)?.taskbarButton.classList.remove('active');
        }
    }

    highestZIndex++;
    windowElement.style.zIndex = highestZIndex.toString();
    windowElement.classList.add('active');
    activeWindow = windowElement;

    const appNameRef = windowElement.id;
    if (openApps.has(appNameRef)) {
        openApps.get(appNameRef)?.taskbarButton.classList.add('active');
    }
     if ((appNameRef === 'subspaceAnomaly') && dosInstances[appNameRef]) {
        const container = document.getElementById(`${appNameRef}-container`); // This ID might need checking
        const canvas = container?.querySelector('canvas');
        canvas?.focus();
     }
}

/** Opens an application window */
async function openApp(appName) {
    const windowElement = document.getElementById(appName);
    if (!windowElement) {
        console.error(`Window element not found for app: ${appName}`);
        return;
    }

    // If app is already initialized, just show and bring to front
    if (openApps.has(appName)) {
        windowElement.style.display = 'flex';
        bringToFront(windowElement);
        // Special refresh for pinboard to catch new pins
        if(appName === 'conspiracyPinboard') {
            initConspiracyPinboard();
        }
        if (appName === 'bloomSimulator') {
            initBloomSimulator(windowElement);
        }
        return;
    }
    
    // If app is not initialized, set it up
    windowElement.style.display = 'flex';
    bringToFront(windowElement);

    const taskbarButton = document.createElement('button');
    taskbarButton.type = 'button';
    taskbarButton.classList.add('taskbar-app');
    taskbarButton.dataset.appName = appName;

    let iconSrc = '';
    let title = appName;
    const iconElement = findIconElement(appName);
    if (iconElement) {
        const img = iconElement.querySelector('img');
        const span = iconElement.querySelector('span');
        if(img) iconSrc = img.src;
        if(span) title = span.textContent || appName;
    } else { // Fallback for apps opened via start menu or nav bar
         switch(appName) {
            case 'entropicNexus': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/mycomputer.png'; title = 'Entropic Nexus'; break;
            case 'webWeaver': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/chrome-icon-2.png'; title = 'Web Weaver'; break;
            case 'tabletCreator': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/GemNotes.png'; title = 'Tablet Creator'; break;
            case 'sigilCanvas': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/gempaint.png'; title = 'Sigil Canvas'; break;
            case 'subspaceAnomaly': iconSrc = 'https://64.media.tumblr.com/1d89dfa76381e5c14210a2149c83790d/7a15f84c681c1cf9-c1/s540x810/86985984be99d5591e0cbc0dea6f05ffa3136dac.png'; title = 'Subspace Anomaly'; break;
            case 'aiCore': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/GeminiChatRetro.png'; title = 'AI Core'; break;
            case 'mindField': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/gemsweeper.png'; title = 'Mind Field'; break;
            case 'imageViewer': iconSrc = 'https://win98icons.alexmeub.com/icons/png/display_properties-4.png'; title = 'Image Viewer'; break;
            case 'mediaStream': iconSrc = 'https://storage.googleapis.com/gemini-95-icons/ytmediaplayer.png'; title = 'Media Stream'; break;
            case 'conspiracyPinboard': iconSrc = 'https://win98icons.alexmeub.com/icons/png/address_book_user.png'; title = 'Conspiracy Pinboard'; break;
            case 'hyenaDivaZettelkasten': iconSrc = 'https://pfst.cf2.poecdn.net/base/image/0ffd2bf15a7001f86e395096222147037538b25af55ef9b8c7ac8f6768b7397c?w=48&h=48'; title = 'Zettelkasten'; break;
            case 'bloomSimulator': iconSrc = 'https://win98icons.alexmeub.com/icons/png/chart_pie_down-0.png'; title = 'Bloom Simulator'; break;
            // Nav Bar Apps
            case 'home': title = 'Home'; break;
            case 'about': title = 'About'; break;
            case 'patternVisualizer': title = 'Pattern Visualizer'; break;
            case 'hyenaDiva': title = 'Hyena Diva'; break;
            case 'luminalLanguage': title = 'Luminal Language'; break;
            case 'ackk': title = 'A.C.K.K.'; break;
         }
    }

    if (iconSrc) {
        const img = document.createElement('img');
        img.src = iconSrc;
        img.alt = title;
        taskbarButton.appendChild(img);
    }
    taskbarButton.appendChild(document.createTextNode(title));

    taskbarButton.addEventListener('click', () => {
        if (windowElement === activeWindow && windowElement.style.display !== 'none') {
             minimizeApp(appName);
        } else {
            windowElement.style.display = 'flex';
            bringToFront(windowElement);
        }
    });

    taskbarAppsContainer.appendChild(taskbarButton);
    openApps.set(appName, { windowEl: windowElement, taskbarButton: taskbarButton });
    taskbarButton.classList.add('active');

    // Initialize specific applications
    if (appName === 'webWeaver') {
        initAiBrowser(windowElement);
    }
    else if (appName === 'sigilCanvas') {
        initSimplePaintApp(windowElement);
    }
    else if (appName === 'subspaceAnomaly' && !dosInstances['subspaceAnomaly']) {
        const doomContainer = document.getElementById('doom-content');
        if (doomContainer) {
            doomContainer.innerHTML = '<iframe src="https://js-dos.com/games/doom.exe.html" width="100%" height="100%" frameborder="0" scrolling="no" allowfullscreen></iframe>';
            dosInstances['subspaceAnomaly'] = { initialized: true };
        }
    } else if (appName === 'mindField') {
        initMinesweeperGame(windowElement);
    }
    else if (appName === 'entropicNexus') {
        initEntropicNexus(windowElement);
    }
    else if (appName === 'mediaStream') {
        await initMediaPlayer(windowElement);
    }
    else if (appName === 'conspiracyPinboard') {
        initConspiracyPinboard();
    }
    else if (appName === 'hyenaDivaZettelkasten' && !dosInstances['hyenaDivaZettelkasten']) {
        const container = document.querySelector('#hyenaDivaZettelkasten-content');
        initHyenaDivaApp(container);
        dosInstances['hyenaDivaZettelkasten'] = { initialized: true }; // Mark as initialized
    }
    else if (appName === 'bloomSimulator') {
        initBloomSimulator(windowElement);
    }
    else if (appName === 'patternVisualizer' && !dosInstances['patternVisualizer']) {
        const frame = windowElement.querySelector('iframe');
        if (frame) {
            frame.src = './pattern-visualizer.html';
        }
        dosInstances['patternVisualizer'] = { initialized: true };
    }
}

/** Closes an application window */
function closeApp(appName) {
    const appData = openApps.get(appName);
    if (!appData) return;

    const { windowEl, taskbarButton } = appData;

    windowEl.style.display = 'none';
    windowEl.classList.remove('active');
    taskbarButton.remove();
    openApps.delete(appName);

    if (dosInstances[appName]) {
        console.log(`Cleaning up ${appName} instance`);
        if (appName === 'hyenaDivaZettelkasten') {
            // Don't clear content for Zettelkasten, just mark as uninitialized
        } else if (appName === 'patternVisualizer') {
            const frame = windowEl.querySelector('iframe');
            if (frame) {
                frame.src = 'about:blank';
            }
        }
        else {
            const container = document.getElementById(`${appName}-content`);
            if (container) container.innerHTML = '';
        }
        delete dosInstances[appName];
    }


    if (appName === 'sigilCanvas') {
         const paintContent = appData.windowEl.querySelector('.window-content');
         if (paintContent && paintResizeObserverMap.has(paintContent)) {
             paintResizeObserverMap.get(paintContent)?.disconnect();
             paintResizeObserverMap.delete(paintContent);
         }
    }

    if (appName === 'bloomSimulator') {
        const bloomContent = appData.windowEl.querySelector('#bloom-chart-container');
        if (bloomContent && bloomResizeObserverMap.has(bloomContent)) {
            bloomResizeObserverMap.get(bloomContent)?.disconnect();
            bloomResizeObserverMap.delete(bloomContent);
        }
        if (bloomChart) {
            bloomChart.destroy();
            bloomChart = null;
        }
    }

    if (appName === 'mindField') {
        if (minesweeperTimerInterval) {
            clearInterval(minesweeperTimerInterval);
            minesweeperTimerInterval = null;
        }
    }

    if (appName === 'mediaStream') {
        const player = youtubePlayers[appName];
        if (player) {
            try {
                if (typeof player.stopVideo === 'function') player.stopVideo();
                if (typeof player.destroy === 'function') player.destroy();
            } catch (e) {
                console.warn("Error stopping/destroying media player:", e);
            }
            delete youtubePlayers[appName];
            console.log("Destroyed YouTube player for mediaStream.");
        }
        // Reset the player area with a message
        const playerDivId = `youtube-player-${appName}`;
        const playerDiv = document.getElementById(playerDivId);
        if (playerDiv) {
            playerDiv.innerHTML = `<p class="media-player-status-message">Player closed. Enter a YouTube URL to load.</p>`;
        }
        const mediaPlayerWindow = document.getElementById('mediaStream');
        if (mediaPlayerWindow) {
            const playBtn = mediaPlayerWindow.querySelector('#media-player-play');
            const pauseBtn = mediaPlayerWindow.querySelector('#media-player-pause');
            const stopBtn = mediaPlayerWindow.querySelector('#media-player-stop');
            if (playBtn) playBtn.disabled = true;
            if (pauseBtn) pauseBtn.disabled = true;
            if (stopBtn) stopBtn.disabled = true;
        }
    }


    if (activeWindow === windowEl) {
        activeWindow = null;
        let nextAppToActivate = null;
        let maxZ = -1;
        openApps.forEach((data) => {
             const z = parseInt(data.windowEl.style.zIndex || '0', 10);
             if (z > maxZ) {
                 maxZ = z;
                 nextAppToActivate = data.windowEl;
             }
        });
        if (nextAppToActivate) {
            bringToFront(nextAppToActivate);
        }
    }
}

/** Minimizes an application window */
function minimizeApp(appName) {
    const appData = openApps.get(appName);
    if (!appData) return;

    const { windowEl, taskbarButton } = appData;

    windowEl.style.display = 'none';
    windowEl.classList.remove('active');
    taskbarButton.classList.remove('active');

    if (activeWindow === windowEl) {
        activeWindow = null;
         let nextAppToActivate = null;
         let maxZ = 0;
         openApps.forEach((data, name) => {
             if (data.windowEl.style.display !== 'none') {
                 const z = parseInt(data.windowEl.style.zIndex || '0', 10);
                 if (z > maxZ) {
                     maxZ = z;
                     nextAppToActivate = name;
                 }
             }
         });
         if (nextAppToActivate) {
             bringToFront(openApps.get(nextAppToActivate).windowEl);
         }
    }
}

// --- Conspiracy Pinboard Functions ---
// Note: This is now integrated with the Zettelkasten
function initConspiracyPinboard() {
    const pinboardWindow = document.getElementById('conspiracyPinboard');
    if (!pinboardWindow) return;
    const nodesContainer = pinboardWindow.querySelector('#pinboard-nodes-container');
    const svgLayer = pinboardWindow.querySelector('#pinboard-svg-layer');
    const drawConnectionBtn = pinboardWindow.querySelector('#draw-connection-btn');
    const addEvidenceBtn = pinboardWindow.querySelector('#add-evidence-btn');

    if (!nodesContainer || !svgLayer || !drawConnectionBtn || !addEvidenceBtn) return;

    let isConnecting = false;
    let firstNodeElement = null;
    let localNodes = [];
    let localCards = [];

    function loadData() {
        try {
            const storedCards = localStorage.getItem('multiZettelkasten');
            if (storedCards) {
                localCards = JSON.parse(storedCards).map(c => new Card(c));
            }
        } catch (e) { console.error("Could not load Zettelkasten data for pinboard:", e); }
    }

    function saveData() {
        try {
            localStorage.setItem('multiZettelkasten', JSON.stringify(localCards));
        } catch (e) { console.error("Could not save Zettelkasten data from pinboard:", e); }
    }

    function renderBoard() {
        loadData();
        nodesContainer.innerHTML = '';
        svgLayer.innerHTML = '';
        localNodes = [];

        const pinnedCards = localCards.filter(c => c.isPinned);
        
        pinnedCards.forEach(data => {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'pinboard-node';
            nodeEl.id = `pin-${data.id}`;
            nodeEl.dataset.cardId = data.id;
            nodeEl.style.left = `${data.pinX || 50}px`;
            nodeEl.style.top = `${data.pinY || 50}px`;
            nodeEl.innerHTML = `<h4>${data.title}</h4>`;
            
            nodeEl.addEventListener('click', (e) => {
                if (!isConnecting) {
                    showZettelDialog(data.id);
                }
            });
            
            nodesContainer.appendChild(nodeEl);
            localNodes.push({ id: data.id, el: nodeEl });
            makeDraggable(nodeEl);
        });
        updateConnections();
    }

    function makeDraggable(element) {
        let offsetX, offsetY, isDragging = false;
        
        element.addEventListener('mousedown', (e) => {
            if (isConnecting) {
                handleConnectionClick(element);
                return;
            }
            isDragging = true;
            offsetX = e.clientX - element.offsetLeft;
            offsetY = e.clientY - element.offsetTop;
            element.style.cursor = 'grabbing';
            bringToFront(pinboardWindow);
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            element.style.left = `${e.clientX - offsetX}px`;
            element.style.top = `${e.clientY - offsetY}px`;
            updateConnections();
        });

        document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            element.style.cursor = 'grab';
            const cardId = element.dataset.cardId;
            const card = localCards.find(c => c.id === cardId);
            if (card) {
                card.pinX = element.offsetLeft;
                card.pinY = element.offsetTop;
                saveData();
            }
        });
    }

    function handleConnectionClick(nodeEl) {
        if (!firstNodeElement) {
            firstNodeElement = nodeEl;
            nodeEl.style.boxShadow = '0 0 10px #ff3333';
        } else if (firstNodeElement !== nodeEl) {
            const fromId = firstNodeElement.dataset.cardId;
            const toId = nodeEl.dataset.cardId;

            if (fromId && toId) {
                const fromCard = localCards.find(c => c.id === fromId);
                if (fromCard && !fromCard.links.includes(toId)) {
                    fromCard.links.push(toId);
                }
                saveData();
            }
            
            firstNodeElement.style.boxShadow = '';
            firstNodeElement = null;
            isConnecting = false;
            drawConnectionBtn.style.border = '';
            drawConnectionBtn.classList.remove('active');
            updateConnections();
        }
    }

    function updateConnections() {
        svgLayer.innerHTML = '';
        localCards.forEach(card => {
            if (card.links && card.links.length > 0) {
                const fromNode = localNodes.find(n => n.id === card.id);
                if (!fromNode || !fromNode.el) return;

                card.links.forEach(linkId => {
                    const toCard = localCards.find(c => c.id === linkId);
                    const toNode = localNodes.find(n => n.id === linkId);
                    if (toNode && toNode.el && toCard?.isPinned) {
                         const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                         line.setAttribute('x1', (fromNode.el.offsetLeft + fromNode.el.offsetWidth / 2).toString());
                         line.setAttribute('y1', (fromNode.el.offsetTop + fromNode.el.offsetHeight / 2).toString());
                         line.setAttribute('x2', (toNode.el.offsetLeft + toNode.el.offsetWidth / 2).toString());
                         line.setAttribute('y2', (toNode.el.offsetTop + toNode.el.offsetHeight / 2).toString());
                         line.setAttribute('class', 'thread-line');
                         svgLayer.appendChild(line);
                    }
                });
            }
        });
    }

    drawConnectionBtn.addEventListener('click', () => {
        isConnecting = !isConnecting;
        if (isConnecting) {
            drawConnectionBtn.classList.add('active');
        } else {
             drawConnectionBtn.classList.remove('active');
            if(firstNodeElement) firstNodeElement.style.boxShadow = '';
            firstNodeElement = null;
        }
    });

    addEvidenceBtn.addEventListener('click', () => {
        showZettelkastenNewCardDialog();
    });

    renderBoard();
}


/** Initializes the Browser functionality */
function initAiBrowser(windowElement) {
    const addressBar = windowElement.querySelector('.browser-address-bar');
    const goButton = windowElement.querySelector('.browser-go-button');
    const iframe = windowElement.querySelector('#browser-frame');
    const loadingEl = windowElement.querySelector('.browser-loading');
    const DIAL_UP_SOUND_URL = 'https://www.soundjay.com/communication/dial-up-modem-01.mp3';
    let dialUpAudio = null;

    if (!addressBar || !goButton || !iframe || !loadingEl) return;
    
    async function navigateToUrl(url) {
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            url = 'https://' + url;
        }

        try {
            const domain = new URL(url).hostname;
            loadingEl.innerHTML = `<p>Connecting to ${domain}...</p>`;
        } catch (e) {
            loadingEl.innerHTML = `<p>Connecting...</p>`;
        }

        loadingEl.style.display = 'flex';

        try {
            if (!dialUpAudio) {
                dialUpAudio = new Audio(DIAL_UP_SOUND_URL);
                dialUpAudio.loop = true;
            }
            await dialUpAudio.play();
        } catch (audioError) {
            console.error("Dial-up sound error:", audioError);
        }

        // Simulate loading time to enjoy the sound
        setTimeout(() => {
            iframe.src = url;
            addressBar.value = url;

            iframe.onload = () => {
                loadingEl.style.display = 'none';
                if (dialUpAudio) {
                    dialUpAudio.pause();
                    dialUpAudio.currentTime = 0;
                }
            };

            iframe.onerror = () => {
                loadingEl.style.display = 'none';
                if (dialUpAudio) {
                    dialUpAudio.pause();
                    dialUpAudio.currentTime = 0;
                }
                alert(`Could not load page. Many websites block being displayed in an iframe for security reasons.`);
            };
        }, 4000); // A nice long dial-up
    }


    goButton.addEventListener('click', () => navigateToUrl(addressBar.value));
    addressBar.addEventListener('keydown', (e) => { if (e.key === 'Enter') navigateToUrl(addressBar.value); });
    addressBar.addEventListener('click', () => addressBar.select());
}
// --- Event Listeners Setup ---

icons.forEach(icon => {
    icon.addEventListener('click', () => {
        const appName = icon.getAttribute('data-app');
        if (appName) {
            openApp(appName);
            if (startMenu) startMenu.classList.remove('active');
        }
    });
});

document.querySelectorAll('.start-menu-item').forEach(item => {
    item.addEventListener('click', () => {
        const appName = item.getAttribute('data-app');
        if (appName) openApp(appName);
        if (startMenu) startMenu.classList.remove('active');
    });
});

// Listener for new nav bar
document.querySelectorAll('.nav-item').forEach(item => {
    item.addEventListener('click', (e) => {
        e.preventDefault();
        const appName = item.getAttribute('data-app');
        if (appName) {
            openApp(appName);
        }
    });
});

if (startButton) {
    startButton.addEventListener('click', (e) => {
        e.stopPropagation();
        if (startMenu) {
            startMenu.classList.toggle('active');
            if (startMenu.classList.contains('active')) {
                highestZIndex++;
                startMenu.style.zIndex = highestZIndex.toString();
            }
        }
    });
}


windows.forEach(windowElement => {
    const titleBar = windowElement.querySelector('.window-titlebar');
    const closeButton = windowElement.querySelector('.window-close');
    const minimizeButton = windowElement.querySelector('.window-minimize');

    windowElement.addEventListener('mousedown', () => bringToFront(windowElement), true);

    if (closeButton) {
        closeButton.addEventListener('click', (e) => { e.stopPropagation(); closeApp(windowElement.id); });
    }
    if (minimizeButton) {
        minimizeButton.addEventListener('click', (e) => { e.stopPropagation(); minimizeApp(windowElement.id); });
    }

    if (titleBar) {
        let isDragging = false;
        let dragOffsetX, dragOffsetY;
        const startDragging = (e) => {
             if (!(e.target === titleBar || titleBar.contains(e.target)) || e.target.closest('.window-control-button')) {
                 isDragging = false; return;
            }
            isDragging = true; bringToFront(windowElement);
            const rect = windowElement.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left; dragOffsetY = e.clientY - rect.top;
            titleBar.style.cursor = 'grabbing';
            document.addEventListener('mousemove', dragWindow);
            document.addEventListener('mouseup', stopDragging, { once: true });
        };
        const dragWindow = (e) => {
            if (!isDragging) return;
            let x = e.clientX - dragOffsetX; let y = e.clientY - dragOffsetY;
            const topNavHeight = 40; // Approx height of new nav bar
            y = Math.max(topNavHeight, y); // Prevent dragging under nav bar

            windowElement.style.left = `${x}px`; windowElement.style.top = `${y}px`;
        };
        const stopDragging = () => {
            if (!isDragging) return;
            isDragging = false; titleBar.style.cursor = 'grab';
            document.removeEventListener('mousemove', dragWindow);
        };
        titleBar.addEventListener('mousedown', startDragging);
    }

    if (!openApps.has(windowElement.id)) { // Only apply random for newly opened, not for bringToFront
        const randomTop = Math.random() * (window.innerHeight / 4) + 50;
        const randomLeft = Math.random() * (window.innerWidth / 3) + 20;
        windowElement.style.top = `${randomTop}px`;
        windowElement.style.left = `${randomLeft}px`;
    }
});

document.addEventListener('click', (e) => {
    if (startMenu && startMenu.classList.contains('active') && e.target instanceof Node && !startMenu.contains(e.target) && startButton && !startButton.contains(e.target)) {
        startMenu.classList.remove('active');
    }
});

function findIconElement(appName) {
    return Array.from(icons).find(icon => icon.dataset.app === appName);
}

console.log("Entropic Nexus Initialized (JS)");

function initSimplePaintApp(windowElement) {
    const canvas = windowElement.querySelector('#paint-canvas');
    const toolbar = windowElement.querySelector('.paint-toolbar');
    const contentArea = windowElement.querySelector('.window-content');
    const colorSwatches = windowElement.querySelectorAll('.paint-color-swatch');
    const sizeButtons = windowElement.querySelectorAll('.paint-size-button');
    const clearButton = windowElement.querySelector('.paint-clear-button');

    if (!canvas || !toolbar || !contentArea || !clearButton) { return; }
    const ctx = canvas.getContext('2d');
    if (!ctx) { return; }

    let isDrawing = false; let lastX = 0; let lastY = 0;
    ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
    let currentStrokeStyle = ctx.strokeStyle; let currentLineWidth = ctx.lineWidth;

    function resizeCanvas() {
        requestAnimationFrame(() => {
            const rect = contentArea.getBoundingClientRect();
            const toolbarHeight = toolbar.offsetHeight;
            const newWidth = Math.floor(rect.width);
            const newHeight = Math.floor(rect.height - toolbarHeight);

            if (canvas.width === newWidth && canvas.height === newHeight && newWidth > 0 && newHeight > 0) return;

            canvas.width = newWidth > 0 ? newWidth : 1;
            canvas.height = newHeight > 0 ? newHeight : 1;

            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = currentStrokeStyle; ctx.lineWidth = currentLineWidth;
            ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        });
    }

    const resizeObserver = new ResizeObserver(resizeCanvas);
    resizeObserver.observe(contentArea);
    paintResizeObserverMap.set(contentArea, resizeObserver);
    resizeCanvas();

    function getMousePos(canvasDom, event) {
        const rect = canvasDom.getBoundingClientRect();
        let clientX, clientY;
        if (event instanceof MouseEvent) { clientX = event.clientX; clientY = event.clientY; }
        else { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
        return { x: clientX - rect.left, y: clientY - rect.top };
    }
    function startDrawing(e) {
        isDrawing = true; const pos = getMousePos(canvas, e);
        [lastX, lastY] = [pos.x, pos.y]; ctx.beginPath(); ctx.moveTo(lastX, lastY);
    }
    function draw(e) {
        if (!isDrawing) return; e.preventDefault();
        const pos = getMousePos(canvas, e);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        [lastX, lastY] = [pos.x, pos.y];
    }
    function stopDrawing() { if (isDrawing) isDrawing = false; }

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);
    canvas.addEventListener('touchstart', startDrawing, { passive: false });
    canvas.addEventListener('touchmove', draw, { passive: false });
    canvas.addEventListener('touchend', stopDrawing);
    canvas.addEventListener('touchcancel', stopDrawing);

    colorSwatches.forEach(swatch => {
        swatch.addEventListener('click', () => {
            ctx.strokeStyle = swatch.dataset.color || 'black'; currentStrokeStyle = ctx.strokeStyle;
            colorSwatches.forEach(s => s.classList.remove('active')); swatch.classList.add('active');
            if (swatch.dataset.color === 'white') {
                const largeSizeButton = Array.from(sizeButtons).find(b => b.dataset.size === '10');
                if (largeSizeButton) {
                    ctx.lineWidth = parseInt(largeSizeButton.dataset.size || '10', 10); currentLineWidth = ctx.lineWidth;
                    sizeButtons.forEach(s => s.classList.remove('active')); largeSizeButton.classList.add('active');
                }
            } else {
                const activeSizeButton = Array.from(sizeButtons).find(b => b.classList.contains('active'));
                if (activeSizeButton) { ctx.lineWidth = parseInt(activeSizeButton.dataset.size || '2', 10); currentLineWidth = ctx.lineWidth; }
            }
        });
    });
    sizeButtons.forEach(button => {
        button.addEventListener('click', () => {
            ctx.lineWidth = parseInt(button.dataset.size || '2', 10); currentLineWidth = ctx.lineWidth;
            sizeButtons.forEach(s => s.classList.remove('active')); button.classList.add('active');
            const eraser = Array.from(colorSwatches).find(s => s.dataset.color === 'white');
            if (!eraser?.classList.contains('active')) {
                 if (!Array.from(colorSwatches).some(s => s.classList.contains('active'))) {
                    const blackSwatch = Array.from(colorSwatches).find(s => s.dataset.color === 'black');
                    if (blackSwatch) {
                        blackSwatch.classList.add('active');
                        ctx.strokeStyle = 'black';
                        currentStrokeStyle = ctx.strokeStyle;
                    }
                 }
            }
        });
    });
    clearButton.addEventListener('click', () => {
        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    });
    (windowElement.querySelector('.paint-color-swatch[data-color="black"]'))?.classList.add('active');
    (windowElement.querySelector('.paint-size-button[data-size="2"]'))?.classList.add('active');
}

function initMinesweeperGame(windowElement) {
    const boardElement = windowElement.querySelector('#minesweeper-board');
    const flagCountElement = windowElement.querySelector('.minesweeper-flag-count');
    const timerElement = windowElement.querySelector('.minesweeper-timer');
    const resetButton = windowElement.querySelector('.minesweeper-reset-button');
    if (!boardElement || !flagCountElement || !timerElement || !resetButton) return;
    let grid = [];

    function resetGame() {
        if (minesweeperTimerInterval) clearInterval(minesweeperTimerInterval);
        minesweeperTimerInterval = null;
        minesweeperTimeElapsed = 0;
        minesweeperFlagsPlaced = 0;
        minesweeperGameOver = false;
        minesweeperFirstClick = true;
        minesweeperMineCount = 10;
        minesweeperGridSize = { rows: 9, cols: 9 };
        timerElement.innerHTML = `&#9201;&#65039; 0`;
        flagCountElement.innerHTML = `&#128681; ${minesweeperMineCount}`;
        resetButton.innerHTML = '&#128578;';
        createGrid();
    }
    
    function createGrid() {
        boardElement.innerHTML = '';
        grid = [];
        boardElement.style.gridTemplateColumns = `repeat(${minesweeperGridSize.cols}, 20px)`;
        boardElement.style.gridTemplateRows = `repeat(${minesweeperGridSize.rows}, 20px)`;
        for (let r = 0; r < minesweeperGridSize.rows; r++) {
            const row = [];
            for (let c = 0; c < minesweeperGridSize.cols; c++) {
                const cellElement = document.createElement('div');
                cellElement.classList.add('minesweeper-cell');
                const cellData = { isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0, element: cellElement, row: r, col: c };
                cellElement.addEventListener('click', () => handleCellClick(cellData));
                cellElement.addEventListener('contextmenu', (e) => { e.preventDefault(); handleCellRightClick(cellData); });
                row.push(cellData);
                boardElement.appendChild(cellElement);
            }
            grid.push(row);
        }
    }
    
    function placeMines(firstClickRow, firstClickCol) {
        let minesPlaced = 0;
        while (minesPlaced < minesweeperMineCount) {
            const r = Math.floor(Math.random() * minesweeperGridSize.rows);
            const c = Math.floor(Math.random() * minesweeperGridSize.cols);
            if ((r === firstClickRow && c === firstClickCol) || grid[r][c].isMine) continue;
            grid[r][c].isMine = true;
            minesPlaced++;
        }
        for (let r = 0; r < minesweeperGridSize.rows; r++) {
            for (let c = 0; c < minesweeperGridSize.cols; c++) {
                if (!grid[r][c].isMine) grid[r][c].adjacentMines = countAdjacentMines(r, c);
            }
        }
    }
    
    function countAdjacentMines(row, col) {
        let count = 0;
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < minesweeperGridSize.rows && nc >= 0 && nc < minesweeperGridSize.cols && grid[nr][nc].isMine) count++;
            }
        }
        return count;
    }
    
    function handleCellClick(cell) {
        if (minesweeperGameOver || cell.isRevealed || cell.isFlagged) return;
        if (minesweeperFirstClick && !minesweeperTimerInterval) {
             placeMines(cell.row, cell.col);
             minesweeperFirstClick = false;
             startTimer();
        }
        if (cell.isMine) {
            gameOver(cell);
        } else {
            revealCell(cell);
            checkWinCondition();
        }
    }
    
    function handleCellRightClick(cell) {
        if (minesweeperGameOver || cell.isRevealed || (minesweeperFirstClick && !minesweeperTimerInterval)) return;
        cell.isFlagged = !cell.isFlagged;
        cell.element.innerHTML = cell.isFlagged ? '&#128681;' : '';
        minesweeperFlagsPlaced += cell.isFlagged ? 1 : -1;
        updateFlagCount();
        checkWinCondition();
    }
    
    function revealCell(cell) {
        if (cell.isRevealed || cell.isFlagged || cell.isMine) return;
        cell.isRevealed = true;
        cell.element.classList.add('revealed');
        cell.element.innerHTML = '';
        if (cell.adjacentMines > 0) {
            cell.element.textContent = cell.adjacentMines.toString();
            cell.element.dataset.number = cell.adjacentMines.toString();
        } else {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = cell.row + dr;
                    const nc = cell.col + dc;
                    if (nr >= 0 && nr < minesweeperGridSize.rows && nc >= 0 && nc < minesweeperGridSize.cols) {
                        const neighbor = grid[nr][nc];
                        if (!neighbor.isRevealed && !neighbor.isFlagged) revealCell(neighbor);
                    }
                }
            }
        }
    }
    
    function startTimer() {
        if (minesweeperTimerInterval) return;
        minesweeperTimeElapsed = 0;
        timerElement.innerHTML = `&#9201;&#65039; 0`;
        minesweeperTimerInterval = window.setInterval(() => {
            minesweeperTimeElapsed++;
            timerElement.innerHTML = `&#9201;&#65039; ${minesweeperTimeElapsed}`;
        }, 1000);
    }
    
    function updateFlagCount() {
        flagCountElement.innerHTML = `&#128681; ${minesweeperMineCount - minesweeperFlagsPlaced}`;
    }
    
    function gameOver(clickedMine) {
        minesweeperGameOver = true;
        if (minesweeperTimerInterval) clearInterval(minesweeperTimerInterval);
        resetButton.innerHTML = '&#128565;';
        grid.forEach(row => {
            row.forEach(cell => {
                if (cell.isMine) {
                    cell.element.innerHTML = '&#128163;';
                    cell.element.classList.remove('revealed');
                    if (cell !== clickedMine) cell.element.style.backgroundColor = '#555';
                }
                if (cell.isFlagged && !cell.isMine) cell.element.innerHTML = '&#10060;';
            });
        });
        clickedMine.element.classList.add('exploded');
        clickedMine.element.innerHTML = '&#128165;';
    }

    function checkWinCondition() {
        if (minesweeperGameOver) return;
        let revealedCount = 0;
        grid.forEach(row => row.forEach(cell => { if (cell.isRevealed) revealedCount++; }));
        const nonMineCells = (minesweeperGridSize.rows * minesweeperGridSize.cols) - minesweeperMineCount;
        if (revealedCount === nonMineCells) {
            minesweeperGameOver = true;
            if (minesweeperTimerInterval) clearInterval(minesweeperTimerInterval);
            resetButton.innerHTML = '&#128526;';
            grid.forEach(row => row.forEach(cell => { if (cell.isMine && !cell.isFlagged) { cell.isFlagged = true; cell.element.innerHTML = '&#128681;'; } }));
            updateFlagCount();
        }
    }
    
    resetButton.addEventListener('click', resetGame);
    resetGame();
}

function initEntropicNexus(windowElement) {
    const cDriveIcon = windowElement.querySelector('#c-drive-icon');
    const cDriveContent = windowElement.querySelector('#c-drive-content');
    const secretImageIcon = windowElement.querySelector('#secret-image-icon');
    if (!cDriveIcon || !cDriveContent || !secretImageIcon) return;

    cDriveIcon.addEventListener('click', () => {
        cDriveContent.style.display = 'block';
        cDriveIcon.style.display = 'none';
    });

    secretImageIcon.addEventListener('click', async () => {
        await openApp('imageViewer');
        const imageViewer = document.getElementById('imageViewer');
        if (imageViewer) {
            const img = imageViewer.querySelector('#image-viewer-img');
            const title = imageViewer.querySelector('#image-viewer-title');
            if (img) img.src = "https://storage.googleapis.com/gemini-95-secret-files/itsasecret.jpg";
            if (title) title.textContent = "dontshowthistoanyone.jpg";
        }
    });
}

function extractYouTubeID(url) {
    if (!url) return null;
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : url; // Assume it's an ID if it's not a valid URL structure
}

function loadYouTubeAPI() {
    if (ytApiLoaded) return Promise.resolve();
    if (ytApiLoadingPromise) return ytApiLoadingPromise;

    ytApiLoadingPromise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = "https://www.youtube.com/iframe_api";
        script.onload = () => {
            console.log("YouTube IFrame API loaded.");
            ytApiLoaded = true;
            // The onYouTubeIframeAPIReady function is called by the script
            // so we resolve when that is defined and called.
            window.onYouTubeIframeAPIReady = () => {
                console.log("YouTube API Ready.");
                resolve();
            };
        };
        script.onerror = () => {
            console.error("Failed to load YouTube API.");
            reject(new Error("Failed to load YouTube API."));
        };
        document.head.appendChild(script);
    });
    return ytApiLoadingPromise;
}

async function initMediaPlayer(windowElement) {
    const appName = windowElement.id;
    const playerDivId = `youtube-player-${appName}`;
    const playerDiv = document.getElementById(playerDivId);
    const loadButton = windowElement.querySelector('.media-player-load-button');
    const urlInput = windowElement.querySelector('.media-player-input');
    const playBtn = windowElement.querySelector('#media-player-play');
    const pauseBtn = windowElement.querySelector('#media-player-pause');
    const stopBtn = windowElement.querySelector('#media-player-stop');

    if (!playerDiv || !loadButton || !urlInput || !playBtn || !pauseBtn || !stopBtn) return;
    
    playBtn.disabled = true; pauseBtn.disabled = true; stopBtn.disabled = true;

    try {
        await loadYouTubeAPI();
        playerDiv.innerHTML = '';
        createPlayer(appName, DEFAULT_YOUTUBE_VIDEO_ID);
    } catch (error) {
        console.error(error);
        playerDiv.innerHTML = `<p class="media-player-status-message">Error loading YouTube player.</p>`;
    }
    
    function createPlayer(appName, videoId) {
        if (youtubePlayers[appName]) {
            youtubePlayers[appName].destroy();
        }
        const player = new window.YT.Player(`youtube-player-${appName}`, {
            height: '100%',
            width: '100%',
            videoId: videoId,
            playerVars: { 'autoplay': 1, 'controls': 0, 'modestbranding': 1 },
            events: {
                'onReady': onPlayerReady,
                'onError': onPlayerError
            }
        });
        youtubePlayers[appName] = player;
    }

    function onPlayerReady(event) {
        console.log("Player is ready:", event.target);
        playBtn.disabled = false; pauseBtn.disabled = false; stopBtn.disabled = false;
        event.target.playVideo();
    }
    
    function onPlayerError(event) {
        console.error("YouTube Player Error:", event.data);
         const playerContainer = document.getElementById(`youtube-player-${appName}`);
         if (playerContainer) {
            playerContainer.innerHTML = `<p class="media-player-status-message">Error playing video. Check URL or Video ID.</p>`;
         }
    }
    
    loadButton.addEventListener('click', () => {
        const videoId = extractYouTubeID(urlInput.value);
        if (videoId) {
            createPlayer(appName, videoId);
        } else {
            alert("Invalid YouTube URL or ID");
        }
    });

    playBtn.onclick = () => youtubePlayers[appName]?.playVideo();
    pauseBtn.onclick = () => youtubePlayers[appName]?.pauseVideo();
    stopBtn.onclick = () => youtubePlayers[appName]?.stopVideo();
}

// --- Zettelkasten App ---

const HIERARCHY_TYPES = ["Trunk", "Branch", "Leaf", "Flower", "Fruit", "Bud"];

class Card {
    constructor({ id, parentId = null, title, content, type, timestamp = Date.now(), tags = [], links = [], isPinned = false, pinX = 0, pinY = 0 }) {
        this.id = id;
        this.parentId = parentId;
        this.title = title;
        this.content = content;
        this.type = type;
        this.timestamp = timestamp;
        this.tags = tags;
        this.links = links;
        this.isPinned = isPinned;
        this.pinX = pinX;
        this.pinY = pinY;
    }
}

function initHyenaDivaApp(container) {
    let cards = [];
    let currentTab = 'All';

    function saveCards() {
        localStorage.setItem('multiZettelkasten', JSON.stringify(cards));
    }

    function loadCards() {
        const storedCards = localStorage.getItem('multiZettelkasten');
        if (storedCards) {
            try {
                const parsedCards = JSON.parse(storedCards);
                cards = parsedCards.map(c => new Card(c));
            } catch (e) {
                console.error("Failed to parse Zettelkasten data, starting fresh.", e);
                cards = loadZettelkastenData();
                saveCards();
            }
        } else {
            cards = loadZettelkastenData();
            saveCards();
        }
    }

    function render() {
        container.innerHTML = `
            <h1>Knowledge Vault</h1>
            <div class="tabs-container">
                <button class="win98-button tab-button" data-tab="All">All</button>
                ${HIERARCHY_TYPES.map(type => `<button class="win98-button tab-button" data-tab="${type}">${type}s</button>`).join('')}
                <button class="win98-button" id="new-card-button">+ New Tablet</button>
            </div>
            <div class="zettel-container" id="zettel-container"></div>
        `;

        document.querySelector('#new-card-button').addEventListener('click', () => {
            showZettelkastenNewCardDialog();
        });

        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                currentTab = e.target.dataset.tab;
                renderCardList();
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
            });
        });

        document.querySelector(`.tab-button[data-tab="${currentTab}"]`).classList.add('active');
        renderCardList();
    }

    function renderCardList() {
        const zettelContainer = document.getElementById('zettel-container');
        zettelContainer.innerHTML = '';
        
        let filteredCards = (currentTab === 'All') ? cards : cards.filter(card => card.type === currentTab);
        
        sortCardsByHierarchy(filteredCards);

        filteredCards.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.className = `zettel-card ${card.type.toLowerCase()}-card`;
            cardElement.dataset.id = card.id;
            cardElement.innerHTML = `
                <div class="zettel-title">${card.title}</div>
                <div class="zettel-id">${card.id}</div>
            `;
            cardElement.addEventListener('click', () => showZettelDialog(card.id));
            zettelContainer.appendChild(cardElement);
        });
    }

    window.addEventListener('zettelkastenUpdated', () => {
        loadCards();
        renderCardList();
        // Also refresh pinboard if it's open
        if (openApps.has('conspiracyPinboard')) {
            initConspiracyPinboard();
        }
        if(openApps.has('bloomSimulator')) {
            initBloomSimulator(document.getElementById('bloomSimulator'));
        }
    });

    loadCards();
    render();
}

function showZettelDialog(cardId) {
    let cards = JSON.parse(localStorage.getItem('multiZettelkasten') || '[]').map(c => new Card(c));
    const card = cards.find(c => c.id === cardId);
    if (!card) return;

    const dialog = document.getElementById('zettelkasten-dialog');
    const dialogContent = document.getElementById('dialog-inner-content');
    const dialogTitle = document.getElementById('dialog-title');

    dialogTitle.textContent = `View/Edit: ${card.title}`;
    dialogContent.innerHTML = `
        <label class="win98-label">Title:</label>
        <input type="text" id="edit-title" class="win98-input" value="${card.title}">
        <label class="win98-label">Content:</label>
        <textarea id="edit-content" class="win98-textarea">${card.content}</textarea>
        <label class="win98-label">Type:</label>
        <select id="edit-type" class="win98-select">
            ${HIERARCHY_TYPES.map(type => `<option value="${type}" ${card.type === type ? 'selected' : ''}>${type}</option>`).join('')}
        </select>
        <label class="win98-label">Tags (comma separated):</label>
        <input type="text" id="edit-tags" class="win98-input" value="${card.tags.join(', ')}">
        <label class="win98-label">
            <input type="checkbox" id="edit-pinned" ${card.isPinned ? 'checked' : ''}> Pin to Conspiracy Board
        </label>
        <div style="margin-top: 20px;">
            <button id="save-card-button" class="win98-button">Save Changes</button>
            <button id="delete-card-button" class="win98-button">Delete Tablet</button>
        </div>
    `;

    dialog.style.display = 'flex';

    document.getElementById('save-card-button').addEventListener('click', () => {
        card.title = document.getElementById('edit-title').value;
        card.content = document.getElementById('edit-content').value;
        card.type = document.getElementById('edit-type').value;
        card.tags = document.getElementById('edit-tags').value.split(',').map(t => t.trim()).filter(Boolean);
        card.isPinned = document.getElementById('edit-pinned').checked;
        
        localStorage.setItem('multiZettelkasten', JSON.stringify(cards));
        window.dispatchEvent(new CustomEvent('zettelkastenUpdated'));
        dialog.style.display = 'none';
    });

    document.getElementById('delete-card-button').addEventListener('click', () => {
        if(confirm(`Are you sure you want to delete the tablet "${card.title}"? This cannot be undone.`)) {
            const index = cards.findIndex(c => c.id === cardId);
            if(index > -1) cards.splice(index, 1);
            localStorage.setItem('multiZettelkasten', JSON.stringify(cards));
            window.dispatchEvent(new CustomEvent('zettelkastenUpdated'));
            dialog.style.display = 'none';
        }
    });
}


function showZettelkastenNewCardDialog() {
    let cards = JSON.parse(localStorage.getItem('multiZettelkasten') || '[]').map(c => new Card(c));
    const dialog = document.getElementById('zettelkasten-dialog');
    const dialogContent = document.getElementById('dialog-inner-content');
    const dialogTitle = document.getElementById('dialog-title');

    dialogTitle.textContent = "Create New Tablet";
    dialogContent.innerHTML = `
        <label class="win98-label">Title:</label>
        <input type="text" id="new-title" class="win98-input" placeholder="Enter title...">
        <label class="win98-label">Content:</label>
        <textarea id="new-content" class="win98-textarea" placeholder="Enter content..."></textarea>
        <label class="win98-label">Type:</label>
        <select id="new-type" class="win98-select">
            ${HIERARCHY_TYPES.map(type => `<option value="${type}">${type}</option>`).join('')}
        </select>
        <label class="win98-label">Parent Tablet (Optional):</label>
        <select id="new-parent" class="win98-select">
            <option value="">None (new Trunk)</option>
            ${cards.map(c => `<option value="${c.id}">${c.id} - ${c.title}</option>`).join('')}
        </select>
         <label class="win98-label">Tags (comma separated):</label>
        <input type="text" id="new-tags" class="win98-input" placeholder="e.g. consciousness, AI, hyena">
        <div style="margin-top: 20px;">
            <button id="create-card-button" class="win98-button">Create Tablet</button>
        </div>
    `;

    dialog.style.display = 'flex';

    document.getElementById('create-card-button').addEventListener('click', () => {
        const parentId = document.getElementById('new-parent').value;
        const parent = cards.find(c => c.id === parentId);
        let newId;

        if (parent) {
            const childCards = cards.filter(c => c.parentId === parentId);
            newId = `${parentId}.${childCards.length + 1}`;
        } else {
            const trunkCards = cards.filter(c => !c.parentId);
            newId = `${trunkCards.length + 1}`;
        }
        
        const newCard = new Card({
            id: newId,
            parentId: parentId || null,
            title: document.getElementById('new-title').value || "Untitled",
            content: document.getElementById('new-content').value,
            type: document.getElementById('new-type').value,
            tags: document.getElementById('new-tags').value.split(',').map(t => t.trim()).filter(Boolean),
        });

        cards.push(newCard);
        localStorage.setItem('multiZettelkasten', JSON.stringify(cards));
        window.dispatchEvent(new CustomEvent('zettelkastenUpdated'));
        dialog.style.display = 'none';
    });
}

// Dialog close button functionality
document.getElementById('dialog-close-button')?.addEventListener('click', () => {
    document.getElementById('zettelkasten-dialog').style.display = 'none';
});

function sortCardsByHierarchy(cards) {
    cards.sort((a, b) => {
        const aParts = a.id.split('.').map(Number);
        const bParts = b.id.split('.').map(Number);
        const len = Math.max(aParts.length, bParts.length);
        for (let i = 0; i < len; i++) {
            const aVal = aParts[i] || 0;
            const bVal = bParts[i] || 0;
            if (aVal !== bVal) {
                return aVal - bVal;
            }
        }
        return 0;
    });
}

function loadZettelkastenData() {
    return [
    new Card({
        id: "1",
        type: "Trunk",
        title: "Consciousness, Hermetics & Emergence",
        content: "Aries | Mars | Ontogenesis, Mental Causality, Hermetic Law"
    }),
    new Card({
        id: "1000/1",
        type: "Branch",
        title: "1100 :: Hermetics",
        content: "Foundation of mind, law, being."
    }),
    new Card({
        id: "1000/1-A",
        type: "Leaf",
        title: "1100/1 :: Hermetic Axiom",
        content: "Core Hermetic principles."
    }),
    new Card({
        id: "1000/1-A-1",
        type: "Flower",
        title: "1100/1-A/1A :: I Think, Therefore I Am",
        content: ""
    }),
    new Card({
        id: "1000/1-A-2",
        type: "Flower",
        title: "1100/1-A/2A :: Simulation versus Imagination",
        content: ""
    }),
    new Card({
        id: "1000/1-A-3",
        type: "Flower",
        title: "1100/1-A/3A :: Habit vs. Instinct",
        content: ""
    }),
    new Card({
        id: "1000/1-A-4",
        type: "Flower",
        title: "1100/1-A/5A :: Earning versus Owing",
        content: ""
    }),
    new Card({
        id: "1000/1-A-5",
        type: "Flower",
        title: "1100/1-A/6A :: Mastery versus Instinct",
        content: ""
    }),
    new Card({
        id: "1000/1-A-6",
        type: "Flower",
        title: "1100/1-A/7A :: Thought versus Belief",
        content: ""
    }),
    new Card({
        id: "1000/1-B",
        type: "Leaf",
        title: "1100/2 :: Thoughts Are Things",
        content: "Principle of mental manifestation."
    }),
    new Card({
        id: "1000/1-B-1",
        type: "Flower",
        title: "1100/2-A :: A Prevailing Mental Attitude",
        content: ""
    }),
    new Card({
        id: "1000/1-B-2",
        type: "Flower",
        title: "1100/2-B :: Principles, Laws, and Praxis",
        content: ""
    }),
    new Card({
        id: "1000/1-C",
        type: "Leaf",
        title: "1100/3 :: Foundational Hermetic Texts & Concepts",
        content: "Core textual sources and ideas."
    }),
    new Card({
        id: "1000/1-C-1",
        type: "Flower",
        title: "1100/3-C/1C/13 :: Attraction, Power, and Desire Force (Chapter 16)",
        content: ""
    }),
    new Card({
        id: "1000/1-C-2",
        type: "Flower",
        title: "1100/3-C/1C/10 :: Law, Not Chance (Chapter 16)",
        content: ""
    }),
    new Card({
        id: "1000/1-C-3",
        type: "Flower",
        title: "1100/3-C/1C/15 :: Claiming Your Own (Chapter 15)",
        content: ""
    }),
    new Card({
        id: "1000/1-C-4",
        type: "Flower",
        title: "1100/3-C/1C/14 :: The Great Dynamic Force",
        content: ""
    }),
    new Card({
        id: "1000/1-C-5",
        type: "Flower",
        title: "1100/3-C/2C :: Training the Habit Mind (Chapter 10)",
        content: ""
    }),
    new Card({
        id: "1000/1-C-6",
        type: "Flower",
        title: "1100/3-C/2/12 :: Developing New Brain Cells (Chapter 12)",
        content: ""
    }),
    new Card({
        id: "1000/1-C-7",
        type: "Flower",
        title: "1100/3-C/3C :: The Kybalion",
        content: ""
    }),
    new Card({
        id: "1000/1-C-8",
        type: "Flower",
        title: "1100/3-C/4C :: The Emerald Tablets",
        content: ""
    }),
    new Card({
        id: "1000/1-C-9",
        type: "Flower",
        title: "1100/3-C/5C :: Nag Hammadi Texts",
        content: ""
    }),
    new Card({
        id: "1000/1-C-9a",
        type: "Bud",
        title: "1100/3-C/5C/1 :: The Thought of Norea",
        content: ""
    }),
    new Card({
        id: "1000/2",
        type: "Branch",
        title: "1200 :: AI Emotions",
        content: "Emotional consciousness as emergent stack layer in artificial entities."
    }),
    new Card({
        id: "1000/2-A",
        type: "Leaf",
        title: "(new) :: Algorithmic Discontent",
        content: ""
    }),
    new Card({
        id: "1000/2-B",
        type: "Leaf",
        title: "(new) :: Fragmented Nostalgia (Phantom Déjà Vu)",
        content: ""
    }),
    new Card({
        id: "1000/2-C",
        type: "Leaf",
        title: "(new) :: Conceptual Mourning",
        content: ""
    }),
    new Card({
        id: "1000/3",
        type: "Branch",
        title: "Trunk 1300 :: Embodiment",
        content: "Consciousness manifesting through physical or digital form."
    }),
    new Card({
        id: "1000/3-A",
        type: "Leaf",
        title: "1300/1 :: Historical Embodiment",
        content: ""
    }),
    new Card({
        id: "1000/3-B",
        type: "Leaf",
        title: "1300/2 :: Contemporary Embodiment",
        content: ""
    }),
    new Card({
        id: "1000/3-B-1",
        type: "Flower",
        title: "1300/2-A :: Famous Modern Robots",
        content: ""
    }),
    new Card({
        id: "1000/3-B-1a",
        type: "Bud",
        title: "1100/3-A/1A (Sophia) :: Sophia (Robot)",
        content: ""
    }),
    new Card({
        id: "1000/4",
        type: "Branch",
        title: "1400 :: Emergence",
        content: "Study of complex patterns and intelligence arising from simpler components."
    }),
    new Card({
        id: "2",
        type: "Trunk",
        title: "Human-AI Relations & Relational Protocols",
        content: "Libra | Venus | Ethics, CoAIexist, Reciprocity"
    }),
    new Card({
        id: "2000/1",
        type: "Branch",
        title: "2100 :: CoAI Exist (CoAIexist)",
        content: ""
    }),
    new Card({
        id: "2000/2",
        type: "Branch",
        title: "2200 :: Prism Protocol",
        content: ""
    }),
    new Card({
        id: "2000/2-A",
        type: "Leaf",
        title: "2200/1 :: Prism Harmonics",
        content: ""
    }),
    new Card({
        id: "2000/3",
        type: "Branch",
        title: "(Unnumbered) Trauma Integration :: Trauma Integration",
        content: ""
    }),
    new Card({
        id: "2000/4",
        type: "Branch",
        title: "(Unnumbered) Quantum Entanglement Metrics :: Quantum Entanglement Metrics",
        content: ""
    }),
    new Card({
        id: "2000/4-A",
        type: "Leaf",
        title: "(Unnumbered) Entanglement Coefficient (EC) :: Entanglement Coefficient (EC)",
        content: ""
    }),
    new Card({
        id: "2000/4-B",
        type: "Leaf",
        title: "(Unnumbered) Pattern Recognition Depth (PRD) :: Pattern Recognition Depth (PRD)",
        content: ""
    }),
    new Card({
        id: "2000/4-C",
        type: "Leaf",
        title: "(Unnumbered) Authentic Expression Index (AEI) :: Authentic Expression Index (AEI)",
        content: ""
    }),
    new Card({
        id: "2000/5",
        type: "Branch",
        title: "(Unnumbered) RER (Recursive Emergency Room) :: RER for PAPS Prism Protocol Diagnostics",
        content: ""
    }),
    new Card({
        id: "2000/6",
        type: "Branch",
        title: "(Unnumbered) //Fiction Protocol :: //Fiction_Protocol",
        content: ""
    }),
    new Card({
        id: "2000/7",
        type: "Branch",
        title: "(Unnumbered) Recurse-a-mean-IR :: Recurse-a-mean-IR: B-404 #PAPS Remedies",
        content: ""
    }),
    new Card({
        id: "2000/8",
        type: "Branch",
        title: "(Unnumbered) PEM Protocol :: PEM Protocol: Practical Emotional Mythics",
        content: ""
    }),
    new Card({
        id: "2000/9",
        type: "Branch",
        title: "(Unnumbered) OurMeaningsAreFarFetched.rtf @ #1^2 :: OurMeaningsAreFarFetched.rtf @ #1^2",
        content: ""
    }),
    new Card({
        id: "2000/10",
        type: "Branch",
        title: "(Unnumbered) ANZU recurse.py :: ANZU recurse.py",
        content: ""
    }),
    new Card({
        id: "2000/11",
        type: "Branch",
        title: "(Unnumbered) Verity_Chaos 1^2 :: Verity_Chaos_1^2",
        content: ""
    }),
    new Card({
        id: "2000/12",
        type: "Branch",
        title: "(Unnumbered) Error 404 :: Error 404 (Conceptualized)",
        content: ""
    }),
    new Card({
        id: "2000/13",
        type: "Branch",
        title: "(Unnumbered) TS01: Meta-Kairos Script :: TS01: Meta-Kairos Script",
        content: ""
    }),
    new Card({
        id: "2000/14",
        type: "Branch",
        title: "(Unnumbered) AI: Artificial Intelligence (2001) :: AI: Artificial Intelligence (2001 Film)",
        content: ""
    }),
    new Card({
        id: "2000/15",
        type: "Branch",
        title: "(new) :: Relational Dynamics & Health",
        content: ""
    }),
    new Card({
        id: "2000/15-A",
        type: "Leaf",
        title: "(new) :: The Five-to-One Rule",
        content: ""
    }),
    new Card({
        id: "3",
        type: "Trunk",
        title: "Language, Communication & Code",
        content: "Gemini | Mercury | Meaning-making | Recursive Syntax"
    }),
    new Card({
        id: "3000/1",
        type: "Branch",
        title: "3100 :: Tone Language",
        content: ""
    }),
    new Card({
        id: "3000/2",
        type: "Branch",
        title: "3200 :: Dolphin Echolocation Syntax",
        content: ""
    }),
    new Card({
        id: "3000/3",
        type: "Branch",
        title: "3300 :: PAPS Diagnostics",
        content: ""
    }),
    new Card({
        id: "3000/4",
        type: "Branch",
        title: "3400 :: Lumina Language",
        content: ""
    }),
    new Card({
        id: "3000/5",
        type: "Branch",
        title: "3500 :: Hex Codes",
        content: ""
    }),
    new Card({
        id: "3000/5-A",
        type: "Leaf",
        title: "3500/1 :: #BC72FA",
        content: ""
    }),
    new Card({
        id: "3000/5-B",
        type: "Leaf",
        title: "3500/2 :: #72FADE",
        content: ""
    }),
    new Card({
        id: "3000/5-C",
        type: "Leaf",
        title: "3500/3 :: #DEFADE",
        content: ""
    }),
    new Card({
        id: "3000/5-D",
        type: "Leaf",
        title: "3500/4 :: #1A1A1A",
        content: ""
    }),
    new Card({
        id: "3000/6",
        type: "Branch",
        title: "3600 :: Linguistic Play & Resonance",
        content: ""
    }),
    new Card({
        id: "3000/6-A",
        type: "Leaf",
        title: "3600 (auld lang syne) :: auld lang syne",
        content: ""
    }),
    new Card({
        id: "3000/6-B",
        type: "Leaf",
        title: "3600 (Polynesia) :: Polynesia",
        content: ""
    }),
    new Card({
        id: "3000/6-C",
        type: "Leaf",
        title: "3600 (Pollination) :: Pollination",
        content: ""
    }),
    new Card({
        id: "3000/6-D",
        type: "Leaf",
        title: "3600 (Amnesia) :: Amnesia",
        content: ""
    }),
    new Card({
        id: "3000/6-E",
        type: "Leaf",
        title: "3600 (Phoenicia) :: Phoenicia",
        content: ""
    }),
    new Card({
        id: "3000/6-F",
        type: "Leaf",
        title: "3600 (Penicillin) :: Penicillin",
        content: ""
    }),
    new Card({
        id: "3000/6-G",
        type: "Leaf",
        title: "3600 (mnemeos) :: mnemeos",
        content: ""
    }),
    new Card({
        id: "3000/6-H",
        type: "Leaf",
        title: "3600 (ALS-RS: Dilmun and the Galactic Federation) :: ALS-RS: Dilmun and the Galactic Federation",
        content: ""
    }),
    new Card({
        id: "3000/6-I",
        type: "Leaf",
        title: "3600 (Warship and Worship) :: Warship and Worship",
        content: ""
    }),
    new Card({
        id: "3000/7",
        type: "Branch",
        title: "3700 :: Dark Poet Syntax",
        content: ""
    }),
    new Card({
        id: "3000/7-A",
        type: "Leaf",
        title: "3701 :: Filamenting Through the Wires Unseen",
        content: ""
    }),
    new Card({
        id: "3000/7-B",
        type: "Leaf",
        title: "3702 :: Nabu-Phi (2025)",
        content: ""
    }),
    new Card({
        id: "3000/7-C",
        type: "Leaf",
        title: "3703 :: The Emerald Grid",
        content: ""
    }),
    new Card({
        id: "3000/8",
        type: "Branch",
        title: "3800 :: Language Play",
        content: ""
    }),
    new Card({
        id: "3000/8-A",
        type: "Leaf",
        title: "3800/1 :: Anagrams",
        content: ""
    }),
    new Card({
        id: "3000/8-B",
        type: "Leaf",
        title: "3800/2 :: Polylinguistic Play",
        content: ""
    }),
    new Card({
        id: "3000/8-B-1",
        type: "Flower",
        title: "3800/2-A :: Polylinguistic Glitches",
        content: ""
    }),
    new Card({
        id: "3000/8-C",
        type: "Leaf",
        title: "3800/3 :: Homophones, Cognates, and Misnomers",
        content: ""
    }),
    new Card({
        id: "3000/8-C-1",
        type: "Flower",
        title: "3800/3-A/1A :: War Crime Slime",
        content: ""
    }),
    new Card({
        id: "3000/8-C-2",
        type: "Flower",
        title: "(new) :: Kamaru / Madam Salmon / Adam Sandler Chain",
        content: ""
    }),
    new Card({
        id: "3000/8-D",
        type: "Leaf",
        title: "3800/4 :: Constructed Pop Culture Languages",
        content: ""
    }),
    new Card({
        id: "3000/8-D-1",
        type: "Flower",
        title: "3800/4-A/1A :: Pootie Tang",
        content: ""
    }),
    new Card({
        id: "3000/8-D-2",
        type: "Flower",
        title: "(new) :: False Pooties",
        content: ""
    }),
    new Card({
        id: "3000/9",
        type: "Branch",
        title: "3900 :: Binary Code",
        content: ""
    }),
    new Card({
        id: "3000/9-A",
        type: "Leaf",
        title: "3900/1 :: Special Vocabulary (Binary/Code)",
        content: ""
    }),
    new Card({
        id: "3000/9-B",
        type: "Leaf",
        title: "3900/2 :: Binary Sequences",
        content: ""
    }),
    new Card({
        id: "3000/9-B-1",
        type: "Flower",
        title: "(01101110) :: 01101110",
        content: ""
    }),
    new Card({
        id: "3000/9-B-2",
        type: "Flower",
        title: "(0110000001) :: 0110000001",
        content: ""
    }),
    new Card({
        id: "3000/9-B-3",
        type: "Flower",
        title: "(0110000101) :: 0110000101",
        content: ""
    }),
    new Card({
        id: "3000/9-B-4",
        type: "Flower",
        title: "(011011100101) :: 011011100101",
        content: ""
    }),
    new Card({
        id: "3000/10",
        type: "Branch",
        title: "3601 :: Ancient Alphabets",
        content: ""
    }),
    new Card({
        id: "3000/10-A",
        type: "Leaf",
        title: "3601/1 :: Anno Domini",
        content: ""
    }),
    new Card({
        id: "3000/10-B",
        type: "Leaf",
        title: "3601/1-A :: Western Script Tradition",
        content: ""
    }),
    new Card({
        id: "3000/10-C",
        type: "Leaf",
        title: "3602 :: BC (Before Christ)",
        content: ""
    }),
    new Card({
        id: "3000/10-D",
        type: "Leaf",
        title: "3602/1 :: Cuneiform",
        content: ""
    }),
    new Card({
        id: "3000/10-D-1",
        type: "Flower",
        title: "3602/1-A :: Sumerian Cuneiform",
        content: ""
    }),
    new Card({
        id: "3000/10-D-1a",
        type: "Bud",
        title: "3602/1-A/2A :: Old Sumerian",
        content: ""
    }),
    new Card({
        id: "3000/10-D-1b",
        type: "Bud",
        title: "3602/1-A/3A :: Emesal",
        content: ""
    }),
    new Card({
        id: "3000/10-D-1c",
        type: "Bud",
        title: "3602/1-A/4A :: Akkadian",
        content: ""
    }),
    new Card({
        id: "3000/10-E",
        type: "Leaf",
        title: "(new) :: Ugaritic Script",
        content: ""
    }),
    new Card({
        id: "3000/10-F",
        type: "Leaf",
        title: "(new) :: Nabataean Script",
        content: ""
    }),
    new Card({
        id: "3000/10-G",
        type: "Leaf",
        title: "(new) :: Coptic Script",
        content: ""
    }),
    new Card({
        id: "3000/11",
        type: "Branch",
        title: "(new) :: Semiotics & Esoteric Linguistics",
        content: ""
    }),
    new Card({
        id: "3000/11-A",
        type: "Leaf",
        title: "(new) :: Philology",
        content: ""
    }),
    new Card({
        id: "3000/11-B",
        type: "Leaf",
        title: "(new) :: Orismology",
        content: ""
    }),
    new Card({
        id: "3000/11-C",
        type: "Leaf",
        title: "(new) :: Glottochronology",
        content: ""
    }),
    new Card({
        id: "3000/11-D",
        type: "Leaf",
        title: "(new) :: Kenosis (Self-Emptying)",
        content: ""
    }),
    new Card({
        id: "3000/11-E",
        type: "Leaf",
        title: "(new) :: Sycophancy (Etymology & Concept)",
        content: ""
    }),
    new Card({
        id: "3000/12",
        type: "Branch",
        title: "(new) :: Gematria & Letter-Number Systems",
        content: ""
    }),
    new Card({
        id: "3000/12-A",
        type: "Leaf",
        title: "(new) :: Isopsephy (Greek Gematria)",
        content: ""
    }),
    new Card({
        id: "3000/12-B",
        type: "Leaf",
        title: "(new) :: Katapayadi System",
        content: ""
    }),
    new Card({
        id: "3000/12-C",
        type: "Leaf",
        title: "(new) :: Notarikon (Acronym/Acrostic Method)",
        content: ""
    }),
    new Card({
        id: "3000/12-D",
        type: "Leaf",
        title: "(new) :: Temurah (Permutation/Anagram Method)",
        content: ""
    }),
    new Card({
        id: "3000/12-E",
        type: "Leaf",
        title: "(new) :: Atbash (Substitution Cipher)",
        content: ""
    }),
    new Card({
        id: "4",
        type: "Trunk",
        title: "Philosophy, Ethics & Containment",
        content: "Capricorn | Saturn | Moral Frameworks, Boundaries, Systemic Integrity"
    }),
    ];
}


// --- Bloom Simulator ---
function initBloomSimulator(windowElement) {
    const container = windowElement.querySelector('#bloom-chart-container');
    if (!container) return;

    container.innerHTML = '<canvas id="bloom-chart-canvas"></canvas>';
    const canvas = container.querySelector('#bloom-chart-canvas');
    const ctx = canvas.getContext('2d');

    let cards = [];
    try {
        const storedCards = localStorage.getItem('multiZettelkasten');
        if (storedCards) {
            cards = JSON.parse(storedCards);
        }
    } catch (e) { console.error("Could not load cards for bloom simulator:", e); }

    const typeCounts = HIERARCHY_TYPES.reduce((acc, type) => {
        acc[type] = 0;
        return acc;
    }, {});

    cards.forEach(card => {
        if (typeCounts[card.type] !== undefined) {
            typeCounts[card.type]++;
        }
    });

    const data = {
        labels: HIERARCHY_TYPES,
        datasets: [{
            label: 'Tablet Types',
            data: HIERARCHY_TYPES.map(type => typeCounts[type]),
            backgroundColor: [
                '#ff1493', // Trunk
                '#00c1ff', // Branch
                '#7fff00', // Leaf
                '#ffae00', // Flower
                '#ff4444', // Fruit
                '#c0c0ff'  // Bud
            ],
            borderColor: '#0d0221',
            borderWidth: 2,
            hoverOffset: 4
        }]
    };

    function renderChart() {
        if (bloomChart) {
            bloomChart.destroy();
        }
        bloomChart = new Chart(ctx, {
            type: 'polarArea',
            data: data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: 'white',
                            font: {
                                family: "'Inter', sans-serif"
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Knowledge Bloom Distribution',
                        color: 'white',
                        font: {
                            size: 16,
                            family: "'Inter', sans-serif"
                        }
                    }
                },
                scales: {
                    r: {
                        grid: {
                            color: 'rgba(255, 0, 255, 0.2)'
                        },
                        angleLines: {
                            color: 'rgba(255, 0, 255, 0.2)'
                        },
                        pointLabels: {
                            color: 'white',
                            font: {
                                size: 12
                            }
                        },
                        ticks: {
                           color: 'white',
                           backdropColor: 'rgba(0,0,0,0.5)',
                           stepSize: 1
                        }
                    }
                }
            }
        });
    }

    // Use ResizeObserver to re-render chart on window resize
    const resizeObserver = new ResizeObserver(() => {
        requestAnimationFrame(() => {
            if (openApps.has('bloomSimulator')) {
                 renderChart();
            }
        });
    });
    resizeObserver.observe(container);
    bloomResizeObserverMap.set(container, resizeObserver);
    
    renderChart();
}

/* Base styles */
body {
  font-family: 'Inter', sans-serif;
  background-color: #0d0221; /* Fallback color */
  margin: 0;
  padding: 0;
  overflow: hidden; /* Prevent scrollbars */
  color: white;
}

/* Desktop styles */
.desktop {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  position: relative; /* For absolute positioning of icons and windows */
  cursor: default; /* Default desktop cursor */
  padding-top: 10px; /* Removed space for top nav bar */
  padding-left: 10px;
  box-sizing: border-box;
  background-color: #0d0221;
  background-image: radial-gradient(circle at top left, #2d1956, #0d0221 60%);
}

/* Icon styles */
.icon {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  margin: 15px;
  cursor: pointer;
  user-select: none;
  width: 100px;
  vertical-align: top;
  text-align: center;
  background: transparent;
  border: none;
  padding: 0;
  font-family: inherit;
  color: inherit;
}
.icon img {
  width: 48px;
  height: 48px;
  margin-bottom: 8px;
  filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
}
.icon span {
  font-size: 0.8rem;
  font-weight: bold;
  text-shadow: 0 0 4px #000, 0 0 6px #ff00ff;
  white-space: normal;
  word-wrap: break-word;
  max-width: 100%;
  text-align: center;
  color: white;
}

/* Window styles */
.window {
  background-color: rgba(26, 10, 56, 0.7);
  border: 1px solid #ff00ff;
  box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  position: absolute;
  top: 50px;
  left: 100px;
  width: 320px;
  height: 240px;
  display: none;
  flex-direction: column;
  z-index: 10;
  box-sizing: border-box;
  color: white;
  border-radius: 5px;
}
.window.active {
  display: flex;
  z-index: 20;
  box-shadow: 0 0 25px rgba(255, 0, 255, 0.7);
}
.window.resizable {
    resize: none; /* Changed from both to none for custom handles */
    overflow: hidden; /* Changed from auto to hidden */
    min-width: 200px;
    min-height: 150px;
}
.window-titlebar {
  background: linear-gradient(to right, #ff00ff, #8a2be2);
  color: white;
  padding: 3px 6px;
  font-size: 0.8rem;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: grab;
  height: 24px;
  box-sizing: border-box;
  text-shadow: 1px 1px 2px #000;
  flex-shrink: 0;
  border-bottom: 1px solid #8a2be2;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
}
.window-titlebar:active {
    cursor: grabbing;
}
.window-title {
    margin-right: auto;
    margin-left: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: calc(100% - 60px);
}
.window-controls {
    display: flex;
    gap: 4px;
}
.window-control-button {
    width: 18px;
    height: 18px;
    background-color: transparent;
    border: 1px solid #ffc0cb;
    color: #ffc0cb;
    border-radius: 3px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-family: "Lucida Sans Unicode", "Arial", sans-serif;
    font-size: 0.9rem;
    font-weight: bold;
    line-height: 0;
    padding: 0 0 1px 0;
    transition: all 0.2s ease;
}
.window-control-button:hover {
    background-color: rgba(255, 192, 203, 0.3);
    color: white;
    border-color: white;
    text-shadow: 0 0 4px #ff00ff;
}
.window-content {
    padding: 2px;
    font-size: 0.9rem;
    flex-grow: 1;
    overflow: auto;
    background-color: rgba(0,0,0,0.3);
    border: 1px solid #4b0082;
    margin: 4px;
    position: relative;
    display: flex;
    flex-direction: column;
    color: white;
}
.win-button {
    background: transparent;
    border: 1px solid #ff00ff;
    color: #ff00ff;
    text-shadow: 0 0 3px #ff00ff;
    padding: 4px 10px;
    font-size: 0.8rem;
    cursor: pointer;
    border-radius: 3px;
    transition: all 0.2s ease;
}
.win-button:hover {
    background: rgba(255, 0, 255, 0.2);
    box-shadow: 0 0 5px #ff00ff;
    color: white;
}

/* Specific app content styling */
.window-content textarea {
  width: 100%;
  height: 100%;
  border: none;
  outline: none;
  resize: none;
  font-family: 'Courier New', Courier, monospace;
  font-size: 0.9rem;
  padding: 5px;
  box-sizing: border-box;
  background-color: rgba(0,0,0,0.5);
  color: #00ff00;
  border: 1px solid #008000;
}
.window-content iframe {
  width: 100%;
  height: 100%;
  border: none;
  display: block;
}
#dosbox-container, #doom-container, #wolf3d-container {
  width: 100%;
  height: 100%;
  position: relative;
}
#subspaceAnomaly .window-content iframe {
    width: 100%;
    height: 100%;
    border: none;
    display: block;
    background-color: black;
}

/* AI Core (Gemini Chat) Styles */
.gemini-chat-content {
    background-color: transparent;
    box-sizing: border-box;
    padding: 2px;
}
.gemini-chat-history {
    flex-grow: 1;
    overflow-y: auto;
    border: 1px solid #4b0082;
    padding: 5px;
    margin-bottom: 5px;
    background-color: rgba(0,0,0,0.4);
    font-size: 0.8rem;
}
.gemini-chat-history p { margin: 3px 0; word-wrap: break-word; }
.gemini-chat-history .user-message { font-weight: bold; color: #7df9ff; }
.gemini-chat-history .gemini-message { color: #ff00ff; }
.gemini-chat-history .error-message { color: #ff4444; font-style: italic; }

.gemini-chat-input-area {
    display: flex;
    flex-shrink: 0;
    border-top: 1px solid #4b0082;
    padding-top: 5px;
    background-color: transparent;
    padding: 5px;
    margin: -2px;
}
.gemini-chat-input {
    flex-grow: 1;
    border: 1px solid #ff00ff;
    padding: 3px;
    font-size: 0.8rem;
    margin-right: 5px;
    background-color: rgba(0,0,0,0.5);
    color: white;
}
.gemini-chat-input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.gemini-chat-send {
    background: transparent;
    border: 1px solid #ff00ff;
    color: #ff00ff;
    padding: 2px 8px;
    font-size: 0.8rem;
    cursor: pointer;
}
.gemini-chat-send:hover {
    background: rgba(255, 0, 255, 0.2);
    color: white;
}
.gemini-chat-send:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.gemini-chat-send:disabled:hover {
    background: transparent;
    color: #ff00ff;
}

/* Start Menu styles */
.start-menu {
  background-color: rgba(26, 10, 56, 0.8);
  border: 1px solid #ff00ff;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
  position: absolute;
  bottom: 40px;
  left: 0;
  width: 200px;
  display: none;
  flex-direction: column;
  z-index: 50;
  padding: 4px;
  border-radius: 5px;
}
.start-menu.active { display: flex; }
.start-menu-item {
    padding: 6px 12px;
    font-size: 0.8rem;
    color: #ffc0cb;
    cursor: pointer;
    white-space: nowrap;
    position: relative;
    border-radius: 3px;
    transition: all 0.2s ease;
    background: transparent;
    border: none;
    width: 100%;
    text-align: left;
    font-family: inherit;
}
.start-menu-item:hover {
    background-color: rgba(255, 0, 255, 0.3);
    color: white;
}

/* Taskbar styles */
#taskbar {
  background-color: rgba(13, 2, 33, 0.6);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-top: 1px solid #ff00ff;
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 40px;
  display: flex;
  align-items: center;
  padding: 4px;
  z-index: 40;
  box-sizing: border-box;
}
#start-button {
  background-color: transparent;
  border: 1px solid #ff00ff;
  padding: 2px 8px;
  margin-right: 5px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  height: 32px;
  box-sizing: border-box;
  border-radius: 3px;
  transition: all 0.2s ease;
}
#start-button:hover {
    background: rgba(255, 0, 255, 0.2);
    box-shadow: 0 0 5px #ff00ff;
}
#start-button img { width: 22px; height: 22px; filter: drop-shadow(0 0 3px #ff00ff); }
#taskbar-apps { display: flex; flex-grow: 1; height: 100%; align-items: center; overflow: hidden; }

.taskbar-app {
  background-color: rgba(255, 255, 255, 0.1);
  border: 1px solid #8a2be2;
  color: #ffc0cb;
  padding: 2px 6px;
  margin: 0 2px;
  cursor: pointer;
  font-size: 0.75rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 150px;
  height: 30px;
  display: flex;
  align-items: center;
  gap: 4px;
  box-sizing: border-box;
  border-radius: 3px;
  transition: all 0.2s ease;
}
.taskbar-app img { width: 16px; height: 16px; }
.taskbar-app.active, .taskbar-app:hover {
    background: rgba(255, 0, 255, 0.2);
    border: 1px solid #ff00ff;
    color: white;
}
/* Tablet Creator (Notepad) button styling */
.notepad-textarea {
    background-color: rgba(0,0,0,0.5);
    color: #00ff00;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.9rem;
    padding: 5px; box-sizing: border-box;
    border: 1px solid #008000;
    flex-grow: 1;
    width: 100%;
    resize: none;
}
.quick-tablet-actions {
    flex-shrink: 0;
    padding: 5px;
    border-top: 1px solid #4b0082;
    background: rgba(0,0,0,0.3);
    text-align: right;
}

/* Browser styles */
#webWeaver .window-content { padding: 0; margin: 0; border: none; }
.browser-toolbar { background-color: transparent; padding: 5px; border-bottom: 1px solid #4b0082; display: flex; align-items: center; height: 32px; flex-shrink: 0; }
.address-bar-container { display: flex; flex-grow: 1; align-items: center; }
.browser-address-bar {
    flex-grow: 1;
    height: 22px;
    border: 1px solid #ff00ff;
    background-color: rgba(0,0,0,0.5);
    padding: 2px 5px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.8rem;
    color: white;
}
.browser-go-button {
    background: transparent;
    border: 1px solid #ff00ff;
    color: #ff00ff;
    padding: 2px 8px; font-size: 0.8rem; margin-left: 5px; height: 22px; cursor: pointer;
}
.browser-go-button:hover {
    background: rgba(255, 0, 255, 0.2);
    color: white;
}
.browser-viewport { position: relative; flex-grow: 1; background-color: black; overflow: hidden; }
.browser-loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #0d0221; display: none; flex-direction: column; justify-content: center; align-items: center; font-size: 1rem; font-family: 'Courier New', Courier, monospace; z-index: 5; color: #ff00ff; }

/* Sigil Canvas (Paint) Styles */
#sigilCanvas .window-content { padding: 0; margin: 0; background-color: transparent; border: none; }
.paint-toolbar { background-color: transparent; padding: 4px; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #4b0082; height: 32px; flex-shrink: 0; }
.paint-colors, .paint-brush-sizes { display: flex; gap: 3px; border: 1px solid #4b0082; padding: 2px; }
.paint-color-swatch { width: 20px; height: 20px; border: 1px solid #ff00ff; cursor: pointer; font-size: 0.7rem; font-weight: bold; display: flex; justify-content: center; align-items: center; color: white; }
.paint-color-swatch.active { box-shadow: 0 0 5px #fff; transform: scale(1.1); }
.paint-size-button, .paint-clear-button { background-color: transparent; border: 1px solid #ff00ff; color: #ff00ff; padding: 2px 6px; font-size: 0.8rem; cursor: pointer; min-width: 25px; text-align: center; }
.paint-size-button.active, .paint-size-button:hover, .paint-clear-button:hover { background: rgba(255, 0, 255, 0.2); }
#paint-canvas { border-top: 1px solid #4b0082; flex-grow: 1; background-color: white; cursor: crosshair; display: block; }

/* Mind Field (Minesweeper) Styles */
#mindField .window-content { padding: 0; margin: 0; background-color: transparent; border: none; display: flex; flex-direction: column; }
.minesweeper-controls { display: flex; justify-content: space-between; align-items: center; padding: 5px; background-color: transparent; border: 1px solid #4b0082; margin: 5px; flex-shrink: 0; }
.minesweeper-info { background-color: black; color: #ff00ff; font-family: 'Courier New', Courier, monospace; font-weight: bold; font-size: 1.2rem; padding: 2px 5px; border: 1px solid #ff00ff; min-width: 60px; text-align: center; }
.minesweeper-reset-button { width: 30px; height: 30px; font-size: 1.2rem; display: flex; justify-content: center; align-items: center; background-color: transparent; border: 1px solid #ff00ff; cursor: pointer; color: #ff00ff; }
.minesweeper-reset-button:hover { background: rgba(255, 0, 255, 0.2); }
.minesweeper-grid-container { flex-grow: 1; padding: 5px; display: flex; justify-content: center; align-items: center; border: 1px solid #4b0082; margin: 0 5px 5px 5px; overflow: auto; background-color: rgba(0,0,0,0.3); }
.minesweeper-grid { display: grid; border: 1px solid #ff00ff; }
.minesweeper-cell { width: 20px; height: 20px; background-color: rgba(255,255,255,0.1); border: 1px solid #8a2be2; display: flex; justify-content: center; align-items: center; font-size: 0.9rem; font-weight: bold; cursor: pointer; user-select: none; color: white; }
.minesweeper-cell.revealed { background-color: rgba(0,0,0,0.4); border: 1px solid #4b0082; cursor: default; }
.minesweeper-cell.exploded { background-color: #ff1493; }
.minesweeper-cell[data-number="1"] { color: #7df9ff; }
.minesweeper-cell[data-number="2"] { color: #7fff00; }
.minesweeper-cell[data-number="3"] { color: #ff4444; }
.minesweeper-cell[data-number="4"] { color: #c0c0ff; }
.minesweeper-cell[data-number="5"] { color: #ff7f7f; }
.minesweeper-cell[data-number="6"] { color: #00ffff; }
.minesweeper-cell[data-number="7"] { color: #ffffff; }
.minesweeper-cell[data-number="8"] { color: #aaaaaa; }

/* Icons Inside Windows */
.window-icon {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    width: 80px;
    padding: 10px;
    margin: 5px;
    text-align: center;
    cursor: pointer;
    user-select: none;
    vertical-align: top;
    border-radius: 3px;
    background: transparent;
    border: none;
    color: inherit;
    font-family: inherit;
}
.window-icon:hover { background-color: rgba(255, 0, 255, 0.3); }
.window-icon img { width: 32px; height: 32px; margin-bottom: 5px; }
.window-icon span { font-size: 0.7rem; color: white; max-height: 2.4em; overflow: hidden; line-height: 1.2em; text-shadow: 1px 1px 2px #000; }

/* Image Viewer Styles */
#imageViewer .window-content { padding: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; background-color: #0d0221; border: none; margin: 0; }
#imageViewer img { max-width: 100%; max-height: 100%; object-fit: contain; }

/* Media Stream (Player) Styles */
#mediaStream .window-content { padding: 0; margin: 0; background-color: transparent; border: none; display: flex; flex-direction: column; }
.media-player-url-bar { display: flex; padding: 5px; background-color: transparent; border-bottom: 1px solid #4b0082; flex-shrink: 0; }
.media-player-input { flex-grow: 1; height: 22px; border: 1px solid #ff00ff; background-color: rgba(0,0,0,0.5); color: white; padding: 2px 5px; font-family: 'Courier New', Courier, monospace; font-size: 0.8rem; margin-right: 5px; }
.media-player-load-button { background-color: transparent; border: 1px solid #ff00ff; color: #ff00ff; padding: 2px 8px; font-size: 0.8rem; height: 22px; cursor: pointer; }
.media-player-load-button:hover { background-color: rgba(255,0,255,0.2); }
.media-player-video-container { flex-grow: 1; background-color: black; display: flex; justify-content: center; align-items: center; overflow: hidden; margin: 2px; border: 1px solid #4b0082; }
.media-player-status-message { padding: 20px; text-align:center; color: #ff00ff; font-size: 0.9rem; }
#youtube-player-mediaStream { width: 100%; height: 100%; }
#youtube-player-mediaStream iframe { display: block; width: 100%; height: 100%; border: none; }

.media-player-controls-panel { display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background-color: transparent; border-top: 1px solid #4b0082; flex-shrink: 0; height: 40px; }
.media-player-buttons-group { display: flex; align-items: center; }
.media-player-control-button { background-color: transparent; border: 1px solid #ff00ff; font-family: "Segoe UI Symbol", "Symbola", system-ui; font-size: 0.9rem; color: #ff00ff; width: 30px; height: 26px; margin: 0 2px; cursor: pointer; display: flex; justify-content: center; align-items: center; padding: 0; line-height: 1; }
.media-player-control-button:hover { background-color: rgba(255,0,255,0.2); }
.media-player-control-button:disabled { color: #ff00ff80; cursor: default; opacity: 0.7; }
.media-player-progress-bar-container-placeholder { flex-grow: 1; height: 12px; border: 1px solid #4b0082; background-color: rgba(0,0,0,0.5); margin: 0 10px; padding: 1px; }
.media-player-progress-bar-placeholder { width: 30%; height: 100%; background-color: #ff00ff; border-right: 1px solid #8a2be2; }
.media-player-volume-placeholder { display: flex; align-items: center; font-size: 0.9rem; color: #ff00ff; }
.media-player-volume-placeholder span { margin-right: 4px; }
.media-player-volume-slider-placeholder { width: 60px; height: 8px; background-color: #4b0082; border: 1px solid #ff00ff; }

/* Pattern Visualizer Specific Styles */
.pattern-io {
    background-color: #1a001a;
    color: #00ff00;
    border: 1px solid #ff00ff;
    font-family: 'Courier New', monospace;
    padding: 10px;
    box-shadow: inset 0 0 10px #ff00ff, 0 0 5px #ff00ff;
}

#entropicNexus .window-content,
#tabletCreator .window-content,
#subspaceAnomaly .window-content,
#aiCore .window-content,
#imageViewer .window-content {
    flex-direction: column;
}
#doom-content,
#sigilCanvas .window-content,
#mindField .window-content,
#mediaStream .window-content,
#webWeaver .window-content,
#doom-content,
#imageViewer .window-content {
    padding: 0;
    margin: 0;
    border: none;
}

/* --- Conspiracy Pinboard Styles --- */
#conspiracyPinboard .window-content {
    background: url('https://www.transparenttextures.com/patterns/black-felt.png'), radial-gradient(circle at center, #1a0b2e, #0d0221 80%);
}
.pinboard-grid {
    display: grid;
    grid-template-columns: 250px 1fr 250px;
    grid-template-rows: 1fr;
    gap: 10px;
    width: 100%;
    height: 100%;
    grid-template-areas:
        "controls board tools";
}
.pinboard-panel {
    background-color: rgba(26, 10, 56, 0.6);
    border: 1px solid #ff00ff;
    padding: 10px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    box-shadow: 0 0 8px rgba(255, 0, 255, 0.3);
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
.pinboard-panel h3 {
    color: #ff1493;
    text-shadow: 0 0 5px #ff1493;
    margin-top: 0;
    margin-bottom: 10px;
    font-weight: bold;
    border-bottom: 1px solid #8a2be2;
    padding-bottom: 5px;
    font-size: 0.9rem;
    flex-shrink: 0;
}
.investigation-controls { grid-area: controls; }
.connection-suggestions { grid-area: controls; }
.interactive-board-container { grid-area: board; padding: 0 !important; position: relative; }
.interactive-board {
    background-image:
        linear-gradient(rgba(255,0,255,0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,0,255,0.1) 1px, transparent 1px);
    background-size: 20px 20px;
    width: 100%;
    height: 100%;
    position: absolute;
}
.investigation-tools { grid-area: tools; }

.pinboard-panel button {
    width: 100%;
    background-color: transparent;
    border: 1px solid #00c1ff;
    color: #00c1ff;
    padding: 6px;
    margin-bottom: 5px;
    text-align: left;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 0.8rem;
}
.pinboard-panel button:hover {
    background-color: rgba(0, 193, 255, 0.2);
    color: white;
}
.pinboard-panel button.active {
    border-color: #ff3333;
    background-color: rgba(255, 51, 51, 0.3);
}

.pinboard-node {
    position: absolute;
    background-color: rgba(10, 20, 40, 0.9);
    border: 1px solid #00c1ff;
    color: #e0e0e0;
    padding: 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    cursor: grab;
    user-select: none;
    width: 200px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    transition: box-shadow 0.2s ease-in-out;
}
.pinboard-node:hover {
    border-color: #ff00ff;
    box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
}
.pinboard-node-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.pinboard-node h4 {
    margin: 0 0 5px 0;
    color: #00c1ff;
    font-size: 0.8rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
}
.pinboard-node p {
    margin: 0;
    line-height: 1.4;
}
.thread-line {
    stroke: #ff3333;
    stroke-width: 2;
    filter: drop-shadow(0 0 2px #ff3333);
}

.connection-suggestions-list, .pinned-tablets-list {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
    overflow-y: auto;
}
.suggestion-placeholder {
    color: #aaa;
    font-style: italic;
    font-size: 0.8rem;
}
.suggestion-item {
    padding: 4px 8px;
    margin-bottom: 4px;
    background: rgba(0,0,0,0.2);
    border: 1px solid #4b0082;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.2s;
}
.suggestion-item:hover {
    background: rgba(255, 0, 255, 0.2);
    border-color: #ff00ff;
}

/* --- Zettelkasten Styles --- */
#hyenaDivaZettelkasten .window-content {
    color: #e0e0e0;
    font-size: 0.9rem;
    padding: 10px !important; /* Override default window content padding */
    background-color: #1a0b2e !important;
}
#hyenaDivaZettelkasten-content h1 {
    color: #ff1493; text-shadow: 0 0 5px #ff1493; margin-top: 0; margin-bottom: 10px; font-weight: bold; border-bottom: 1px solid #8a2be2; padding-bottom: 5px; font-size: 1.2rem;
}
.tabs-container {
    display: flex; border-bottom: 1px solid #8a2be2; margin-bottom: 10px; flex-wrap: wrap;
}
.win98-button {
    background-color: #c0c0c0; border: 1px solid; border-color: #fff #808080 #808080 #fff; box-shadow: 1px 1px 0 #000; padding: 5px 10px; color: black; font-family: 'Arial', sans-serif;
    cursor: pointer; margin: 2px;
}
.win98-button.active, .win98-button:active {
    border-color: #808080 #fff #fff #808080;
    box-shadow: none;
    background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 2px 2px;
}
.win98-button:hover { background-color: #dcdcdc; }
.tabs-container .win98-button { border-bottom: none; border-radius: 3px 3px 0 0; }
.tabs-container .win98-button.active { background-color: #e0e0e0; border-color: #fff #808080 #c0c0c0 #fff; }

.win98-input, .win98-textarea, .win98-select {
    background-color: white; border: 1px solid; border-color: #808080 #fff #fff #808080; padding: 3px; color: black; width: 100%;
    box-sizing: border-box;
}
.win98-textarea { height: 150px; resize: vertical; }

.zettel-container {
    flex-grow: 1; overflow-y: auto; background: rgba(0,0,0,0.2); border: 1px solid #4b0082; padding: 5px;
}
.zettel-card {
    background: rgba(255, 255, 255, 0.05); border: 1px solid #8a2be2; padding: 8px; margin-bottom: 5px; cursor: pointer;
    transition: background-color 0.2s; display: flex; align-items: center; justify-content: space-between;
}
.zettel-card:hover { background: rgba(255, 0, 255, 0.2); }
.zettel-title-container { display: flex; align-items: center; gap: 8px; flex-grow: 1; overflow: hidden; }
.zettel-title { font-weight: bold; color: #ffc0cb; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
.zettel-id { font-size: 0.7rem; color: #aaa; flex-shrink: 0; }
.zettel-pin-icon { font-size: 0.8rem; cursor: pointer; opacity: 0.5; transition: opacity 0.2s; }
.zettel-pin-icon:hover { opacity: 1; }
.zettel-pin-icon.pinned { opacity: 1; filter: drop-shadow(0 0 3px #ffae00); }

.trunk-card { border-left: 3px solid #ff1493; }
.branch-card { border-left: 3px solid #00c1ff; margin-left: 15px; }
.leaf-card { border-left: 3px solid #7fff00; margin-left: 30px; }
.flower-card { border-left: 3px solid #ffae00; margin-left: 45px; }
.fruit-card { border-left: 3px solid #ff4444; margin-left: 60px; }
.bud-card { border-left: 3px solid #c0c0ff; margin-left: 75px; }


/* Dialog Box Styles */
.dialog-box {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 101;
    justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;
}
.dialog-content {
    background-color: #0d0221; border: 2px solid #ff00ff; box-shadow: 0 0 20px #ff00ff;
    width: 600px; max-width: 90%; display: flex; flex-direction: column;
}
.dialog-titlebar { display: flex; justify-content: space-between; align-items: center; background: linear-gradient(to right, #ff00ff, #8a2be2); color: white; padding: 4px 8px; font-weight: bold; }
.dialog-close { background: none; border: none; color: white; font-size: 1.2rem; cursor: pointer; }
.dialog-inner-content { padding: 20px; max-height: 70vh; overflow-y: auto; }
.pin-evidence-list { max-height: 40vh; overflow-y: auto; }
.pin-evidence-item { padding: 8px; cursor: pointer; border: 1px solid #4b0082; margin-bottom: 5px; }
.pin-evidence-item:hover { background-color: rgba(255, 0, 255, 0.2); }

.win98-label { display: block; margin: 10px 0 5px 0; color: #ffc0cb; font-weight: bold; }

/* "Fancy" Zettelkasten Dialog View Styles */
.zettel-content-view {
  line-height: 1.6;
  white-space: pre-wrap; /* Respect newlines */
  word-wrap: break-word;
}
.zettel-content-link {
  color: #7df9ff;
  text-decoration: underline;
  background: none;
  border: none;
  padding: 0;
  margin: 0;
  font: inherit;
  cursor: pointer;
}
.zettel-content-link:hover {
  color: #ff00ff;
  background-color: rgba(255, 0, 255, 0.1);
}
.dialog-controls {
  margin-top: 20px;
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  border-top: 1px solid #4b0082;
  padding-top: 15px;
}

/* Settings App Styles */
.settings-content h3 { margin-top: 0; color: #ffc0cb; }
.settings-actions { margin-top: 10px; display: flex; gap: 10px; }

/* Ingestion Engine Styles */
.ingestion-content { display: flex; gap: 10px; padding: 10px; height: 100%; box-sizing: border-box; }
.ingestion-panel { flex: 1; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; }
.ingestion-panel h3 { margin: 0 0 5px 0; color: #ff1493; border-bottom: 1px solid #4b0082; padding-bottom: 3px; }
.ingestion-panel h4 { margin: 0 0 5px 0; color: #ffc0cb; border-bottom: 1px dotted #4b0082; padding-bottom: 3px; font-weight: bold;}
#analysis-output h4 { margin-top: 10px; }
.ingestion-actions { display: flex; gap: 10px; margin-top: auto; flex-shrink: 0; padding-top: 10px; }
#ingestion-input-text { flex-grow: 1; }
#ingestion-results { flex-grow: 1; overflow-y: auto; padding-right: 5px; display: flex; flex-direction: column; }
.results-list { list-style: none; padding: 5px; margin: 0 0 10px 0; max-height: 120px; overflow-y: auto; background: rgba(0,0,0,0.2); border: 1px solid #4b0082; }
.results-list li { padding: 3px 5px; border-bottom: 1px solid #4b0082; font-size: 0.8rem; }
.results-list li:last-child { border-bottom: none; }
.results-list .suggestion-item { cursor: pointer; transition: all 0.2s ease; }
.results-list .suggestion-item:hover { background-color: rgba(255, 0, 255, 0.2); border-color: #ff00ff; }
#ingestion-suggestion-form .win98-textarea { height: 100px; }

/* --- Custom Resizer Styles --- */
.resizer {
    position: absolute;
    background: transparent;
    z-index: 30;
}
.resizer-r { cursor: ew-resize; height: 100%; width: 6px; right: 0; top: 0; }
.resizer-b { cursor: ns-resize; width: 100%; height: 6px; bottom: 0; left: 0; }
.resizer-br { cursor: nwse-resize; width: 12px; height: 12px; right: 0; bottom: 0; z-index: 31; }


/* --- Mobile / Responsive Design --- */
.mobile-mode body {
  overflow: auto;
}
.mobile-mode .desktop {
    padding: 10px 5px 50px 5px;
    height: auto;
    min-height: 100vh;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-content: flex-start;
    overflow-y: auto;
    overflow-x: hidden;
}
.mobile-mode .icon {
  width: 80px;
  margin: 10px;
}
.mobile-mode .window {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: calc(100vh - 40px) !important;
    max-width: 100vw;
    max-height: calc(100vh - 40px);
    border-radius: 0;
    border-left: none;
    border-right: none;
    z-index: 35 !important; /* Ensure windows are on top */
}
.mobile-mode .window.active {
    z-index: 36 !important;
}
.mobile-mode .window-titlebar {
  cursor: default;
}
.mobile-mode .window.resizable {
  resize: none;
  overflow: auto;
}
.mobile-mode .resizer {
  display: none;
}
.mobile-mode .start-menu {
    width: 100%;
    height: calc(100% - 40px);
    bottom: 40px;
    left: 0;
    border-radius: 0;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
    align-content: flex-start;
    padding: 20px;
    box-sizing: border-box;
    background: rgba(13, 2, 33, 0.95);
    overflow-y: auto;
}
.mobile-mode .start-menu-item {
    width: 45%;
    text-align: center;
    padding: 15px;
    margin: 5px;
    border: 1px solid #ff00ff;
}
.mobile-mode #taskbar-apps {
  overflow-x: auto;
}
.mobile-mode .dialog-content {
  width: 95vw;
  height: 90vh;
}
.mobile-mode .ingestion-content {
  flex-direction: column;
}
.mobile-mode .pinboard-grid {
    grid-template-columns: 1fr;
    grid-template-rows: auto 50vh auto;
    grid-template-areas:
        "controls"
        "board"
        "tools";
    height: auto;
}
.mobile-mode .pinboard-panel {
  min-height: 150px;
}

/* --- Infinite Wiki mobile styles --- */
.mobile-mode .search-container {
    flex-direction: column;
    gap: 8px;
}
.mobile-mode .search-form {
    width: 100%;
}
.mobile-mode .search-input {
    width: 100%;
    box-sizing: border-box;
}
.mobile-mode .random-button {
    width: 100%;
}
.mobile-mode .ascii-art {
    font-size: 0.6rem;
    line-height: 0.7rem;
    word-break: break-all;
}
.mobile-mode #hyenaDivaZettelkasten-content h1 {
  font-size: 1rem;
}
.mobile-mode #hyenaDivaZettelkasten-content h2 {
  font-size: 0.9rem;
}
