<html>
<!--Generated by Angelfire: L00S00-->
<head>
<title></title>
</head>
<body>
<basefont size="7">

<!--Freetext--><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>~*~HyEnA DiVa'Z ZeTtElKaStEn~*~ Multi-Classification Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Tahoma&family=Comic+Sans+MS&family=VT323&display=swap" rel="stylesheet">
  <style>
    /* Y2K HYENA DIVA COLORS */
    :root {
      --hyena-pink: #ff72b6;
      --hyena-purple: #bf5fff;
      --hyena-teal: #72fade;
      --hyena-yellow: #fffb01;
      --hyena-blue: #00a2ff;
      
      /* Windows 98 colors with Hyena flair */
      --win98-gray: #C0C0C0;
      --win98-gray-dark: #808080;
      --win98-gray-light: #DFDFDF;
      --win98-desktop: #ff72b6; /* Hyena pink background */
      --win98-window: #C0C0C0;
      --win98-title-active: #bf5fff; /* Hyena purple title bar */
      --win98-title-inactive: #808080;
      --win98-button: #C0C0C0;
      --win98-button-highlight: #FFFFFF;
      --win98-button-shadow: #808080;
      --win98-text: #000000;
      
      /* Kingdom colors */
      --kingdom-existentia: #9C27B0;
      --kingdom-cognitio: #2196F3;
      --kingdom-actus: #F44336;
      --kingdom-valor: #4CAF50;
      --kingdom-systema: #FF9800;
      --kingdom-significatio: #607D8B;
      
      /* Codex colors */
      --codex-cg: #E91E63;
      --codex-ts: #00BCD4;
      --codex-paps: #8BC34A;
      --codex-coai: #9C27B0;
    }
    
    /* Base styles */
    body {
      background-color: var(--win98-desktop);
      background-image: url('https://pfst.cf2.poecdn.net/base/image/c568f858cbfe5304ed56fca693cb244fed53eafca1683b9a9c6d110dbd7dfeeb?w=1024&h=1024');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      background-blend-mode: soft-light;
      color: var(--win98-text);
      font-family: 'Tahoma', 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      position: fixed;
      -webkit-font-smoothing: antialiased;
      -webkit-overflow-scrolling: touch;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }

    /* Apply iOS-style overscroll behavior */
    .ios-scroll {
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Mobile View Toggle Styles */
    .view-toggle {
      position: fixed;
      top: 5px;
      right: 5px;
      z-index: 9999;
      background: var(--hyena-pink);
      color: white;
      border: 2px solid white;
      border-radius: 20px;
      padding: 8px 12px;
      font-size: 14px;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      transition: transform 0.3s, background-color 0.3s;
      -webkit-tap-highlight-color: transparent;
    }

    .view-toggle:hover {
      transform: scale(1.05);
      background-color: var(--hyena-purple);
    }

    .rotate-icon {
      display: inline-block;
      margin-left: 4px;
      font-size: 10px;
      animation: rotate 2s linear infinite;
      -webkit-animation: rotate 2s linear infinite;
    }

    @-webkit-keyframes rotate {
      0% { -webkit-transform: rotate(0deg); }
      100% { -webkit-transform: rotate(360deg); }
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Rotate Button Styles */
    .rotate-button {
      position: fixed;
      bottom: 40px;
      right: 10px;
      z-index: 9999;
      background: var(--hyena-yellow);
      color: black;
      border: 2px solid var(--hyena-pink);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      transition: transform 0.3s ease;
      -webkit-transition: transform 0.3s ease;
      -webkit-tap-highlight-color: transparent;
    }

    .rotate-button:hover {
      transform: rotate(45deg);
      -webkit-transform: rotate(45deg);
    }

    /* Scale Control Styles */
    .scale-control {
      position: fixed;
      bottom: 40px;
      left: 10px;
      z-index: 9999;
      background: var(--win98-gray);
      border: 2px solid var(--hyena-teal);
      border-radius: 20px;
      padding: 5px 10px;
      display: flex;
      align-items: center;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    }

    .scale-button {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--hyena-pink);
      color: white;
      border-radius: 50%;
      cursor: pointer;
      font-weight: bold;
      margin: 0 5px;
      font-size: 16px;
      -webkit-tap-highlight-color: transparent;
    }

    /* Mobile Mode */
    body.mobile-mode {
      background-attachment: scroll;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      height: auto;
      position: static;
    }

    body.mobile-mode .desktop,
    body.mobile-mode .win98-taskbar,
    body.mobile-mode .start-menu {
      display: none !important;
    }

    body.mobile-mode .win98-window {
      position: relative !important;
      top: 0 !important;
      left: 0 !important;
      width: 100% !important;
      height: auto !important;
      margin: 0 0 10px 0;
      border-radius: 0;
    }

    body.mobile-mode .win98-inner-content {
      height: auto;
      max-height: none;
    }

    body.mobile-mode .win98-window-content {
      height: auto;
    }

    body.mobile-mode .zettel-container {
      max-height: 70vh;
    }

    /* Orientation styles */
    body.landscape .myspace-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    body.landscape .myspace-profile-pic {
      margin: 0 15px 0 0;
      flex-shrink: 0;
    }

    body.landscape .myspace-text-container {
      text-align: left;
      flex-grow: 1;
    }

    /* Windows 98 styles with Hyena Diva flair */
    .win98-window {
      background-color: var(--win98-gray);
      border: 2px solid #000000;
      border-top: 2px solid var(--win98-gray-light);
      border-left: 2px solid var(--win98-gray-light);
      border-right: 2px solid var(--win98-gray-dark);
      border-bottom: 2px solid var(--win98-gray-dark);
      box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      position: absolute;
      resize: both;
      -webkit-transform: translateZ(0); /* Optimize for Safari */
    }
    
    .win98-titlebar {
      background: var(--win98-title-active);
      background-image: -webkit-linear-gradient(left, var(--hyena-purple), var(--hyena-pink));
      background-image: linear-gradient(to right, var(--hyena-purple), var(--hyena-pink));
      color: white;
      padding: 2px 0;
      display: flex;
      align-items: center;
      height: 18px;
    }
    
    .win98-titlebar-text {
      flex-grow: 1;
      font-weight: bold;
      margin-left: 4px;
      font-size: 12px;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .win98-window-controls {
      display: flex;
      align-items: center;
      height: 14px;
      margin-right: 2px;
      flex-shrink: 0;
    }
    
    .win98-window-button {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 2px;
      cursor: pointer;
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      color: black;
      font-size: 9px;
      font-family: 'Tahoma', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-close {
      font-weight: bold;
      font-size: 10px;
    }
    
    .win98-app-icon {
      width: 16px;
      height: 16px;
      margin-left: 2px;
      margin-right: 4px;
      flex-shrink: 0;
    }
    
    .win98-window-content {
      padding: 2px;
      overflow-y: auto;
      background-color: var(--win98-gray);
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-inner-content {
      background-color: #FFFFFF;
      border: 1px solid var(--win98-gray-dark);
      padding: 10px;
      height: calc(100% - 22px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 28px;
      background-color: var(--win98-gray);
      display: flex;
      align-items: center;
      padding: 0 2px;
      border-top: 1px solid var(--win98-gray-light);
      z-index: 1000;
    }
    
    .win98-start-button {
      background-color: var(--win98-gray);
      padding: 1px 6px;
      color: black;
      font-weight: bold;
      display: flex;
      align-items: center;
      height: 22px;
      margin-right: 6px;
      cursor: pointer;
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-start-button:active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
    }
    
    .win98-taskbar-items {
      flex-grow: 1;
      display: flex;
      align-items: center;
      gap: 4px;
      overflow-x: auto;
      white-space: nowrap;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-taskbar-items::-webkit-scrollbar {
      display: none;
    }
    
    .win98-taskbar-item {
      background-color: var(--win98-gray);
      padding: 2px 8px;
      color: black;
      font-size: 11px;
      height: 22px;
      min-width: 150px;
      display: flex;
      align-items: center;
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-taskbar-item-active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
    }
    
    .win98-system-tray {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      padding: 0 2px;
      border-left: 1px solid var(--win98-gray-dark);
      height: 22px;
      flex-shrink: 0;
    }
    
    .win98-system-tray-icon {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    .win98-clock {
      background-color: var(--win98-gray);
      padding: 2px 4px;
      font-size: 11px;
      color: black;
    }
    
    /* Customize default button styles */
    .win98-button {
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      color: var(--win98-text);
      padding: 8px 12px;
      font-family: 'Tahoma', sans-serif;
      font-size: 14px;
      cursor: pointer;
      position: relative;
      margin-top: 10px;
      -webkit-tap-highlight-color: transparent;
    }
    
    .win98-button:hover {
      background-color: var(--win98-gray-light);
    }
    
    .win98-button:active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
      background-color: var(--win98-gray);
    }
    
    .win98-button.active {
      background-color: var(--hyena-pink);
      color: white;
      font-weight: bold;
    }
    
    /* Floating Star */
    .floating-star {
      position: absolute;
      width: 30px;
      height: 30px;
      pointer-events: none;
      z-index: 20;
      filter: drop-shadow(0 0 5px rgba(255, 251, 1, 0.7));
      -webkit-filter: drop-shadow(0 0 5px rgba(255, 251, 1, 0.7));
      animation: float 3s infinite ease-in-out;
      -webkit-animation: float 3s infinite ease-in-out;
    }
    
    @-webkit-keyframes float {
      0% { -webkit-transform: translateY(0px); }
      50% { -webkit-transform: translateY(-10px); }
      100% { -webkit-transform: translateY(0px); }
    }
    
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }
    
    /* Zettelkasten styles */
    .zettel-container {
      max-height: 300px;
      overflow-y: auto;
      padding-right: 10px;
      scrollbar-width: thin;
      scrollbar-color: var(--hyena-pink) #e5f5ff;
      border: 1px solid #ccc;
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.2);
      padding: 5px;
      background-color: white;
      -webkit-overflow-scrolling: touch;
    }
    
    .zettel-container::-webkit-scrollbar {
      width: 8px;
    }
    
    .zettel-container::-webkit-scrollbar-track {
      background: #e5f5ff;
      border: 1px solid #ccc;
    }
    
    .zettel-container::-webkit-scrollbar-thumb {
      background-color: var(--hyena-teal);
      border-radius: 0;
      border: 1px solid #919191;
    }
    
    .zettel-card {
      background-color: #fbfbfb;
      border: 1px solid #cccccc;
      padding: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-transition: all 0.2s;
      position: relative;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
      touch-action: pan-y; /* Improves scrolling vs tapping distinction */
    }
    
    .zettel-card:hover {
      background-color: #e8f4ff;
      border-color: var(--hyena-teal);
      transform: translateX(5px);
      -webkit-transform: translateX(5px);
    }
    
    .zettel-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: -webkit-linear-gradient(left, var(--hyena-pink), var(--hyena-teal), var(--hyena-yellow));
      background: linear-gradient(90deg, var(--hyena-pink), var(--hyena-teal), var(--hyena-yellow));
      z-index: 5;
    }
    
    .zettel-title {
      font-weight: bold;
      color: #333;
      margin-bottom: 3px;
      font-size: 14px;
    }
    
    .zettel-id {
      font-size: 11px;
      color: #777;
      font-family: 'VT323', monospace;
    }
    
    /* Traditional hierarchy styling */
    .trunk-card { border-left: 4px solid var(--hyena-purple); }
    .branch-card { border-left: 4px solid var(--hyena-blue); }
    .leaf-card { border-left: 4px solid var(--hyena-teal); }
    .flower-card { border-left: 4px solid var(--hyena-pink); }
    .fruit-card { border-left: 4px solid #f59e0b; }
    .bud-card { border-left: 4px solid var(--hyena-yellow); }
    
    /* Kingdom-based styling */
    .kingdom-existentia { border-left: 4px solid var(--kingdom-existentia); }
    .kingdom-cognitio { border-left: 4px solid var(--kingdom-cognitio); }
    .kingdom-actus { border-left: 4px solid var(--kingdom-actus); }
    .kingdom-valor { border-left: 4px solid var(--kingdom-valor); }
    .kingdom-systema { border-left: 4px solid var(--kingdom-systema); }
    .kingdom-significatio { border-left: 4px solid var(--kingdom-significatio); }
    
    /* Codex styling */
    .codex-cg { border-left: 4px solid var(--codex-cg); }
    .codex-ts { border-left: 4px solid var(--codex-ts); }
    .codex-paps { border-left: 4px solid var(--codex-paps); }
    .codex-coai { border-left: 4px solid var(--codex-coai); }
    
    .child-card {
      margin-left: 15px;
      border-left: 2px dotted var(--hyena-teal);
      padding-left: 8px;
    }
    
    .emergent-card {
      border-left: 4px solid var(--hyena-yellow) !important;
      background-color: #fffef0 !important;
    }
    
    .hierarchy-view .indent-level-1 { margin-left: 20px; }
    .hierarchy-view .indent-level-2 { margin-left: 40px; }
    .hierarchy-view .indent-level-3 { margin-left: 60px; }
    .hierarchy-view .indent-level-4 { margin-left: 80px; }
    .hierarchy-view .indent-level-5 { margin-left: 100px; }
    
    .hierarchy-divider {
      background: linear-gradient(to right, var(--hyena-purple), var(--hyena-pink));
      color: white;
      padding: 5px 10px;
      margin: 10px 0;
      font-weight: bold;
      border-radius: 3px;
    }
    
    .emergent-divider {
      background: linear-gradient(to right, var(--hyena-yellow), var(--hyena-teal));
      color: black;
    }
    
    /* New badges for classification systems */
    .badge {
      display: inline-flex;
      align-items: center;
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 10px;
      margin-right: 3px;
      color: white;
      white-space: nowrap;
    }
    
    .kingdom-badge {
      background-color: #333;
    }
    
    .kingdom-badge-existentia { background-color: var(--kingdom-existentia); }
    .kingdom-badge-cognitio { background-color: var(--kingdom-cognitio); }
    .kingdom-badge-actus { background-color: var(--kingdom-actus); }
    .kingdom-badge-valor { background-color: var(--kingdom-valor); }
    .kingdom-badge-systema { background-color: var(--kingdom-systema); }
    .kingdom-badge-significatio { background-color: var(--kingdom-significatio); }
    
    .tier-badge {
      background-color: #555;
    }
    
    .codex-badge {
      background-color: #444;
    }
    
    .codex-badge-cg { background-color: var(--codex-cg); }
    .codex-badge-ts { background-color: var(--codex-ts); }
    .codex-badge-paps { background-color: var(--codex-paps); }
    .codex-badge-coai { background-color: var(--codex-coai); }
    
    .planet-icon {
      display: inline-block;
      width: 20px;
      height: 20px;
      text-align: center;
      line-height: 20px;
      border-radius: 50%;
      margin-right: 3px;
      font-weight: bold;
      font-size: 11px;
      color: white;
    }
    
    .planet-p1 { background-color: #9C27B0; }
    .planet-p2 { background-color: #FF9800; }
    .planet-p3 { background-color: #FFEB3B; color: black; }
    .planet-p4 { background-color: #2196F3; }
    .planet-p5 { background-color: #00BCD4; }
    .planet-p6 { background-color: #F44336; }
    .planet-p7 { background-color: #4CAF50; }
    .planet-p8 { background-color: #FF9800; color: black; }
    .planet-p9 { background-color: #607D8B; }
    
    /* Tabs styling */
    .tabs-container {
      display: flex;
      overflow-x: auto;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
      border-bottom: 1px solid #ccc;
      margin-bottom: 15px;
    }
    
    .tabs-container::-webkit-scrollbar {
      display: none;
    }
    
    .tab {
      padding: 8px 15px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-bottom: none;
      margin-right: 2px;
      white-space: nowrap;
      cursor: pointer;
      font-size: 12px;
      position: relative;
      bottom: -1px;
    }
    
    .tab.active {
      background-color: white;
      border-bottom: 1px solid white;
      font-weight: bold;
    }
    
    /* View controls styling */
    .view-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .view-controls button {
      font-size: 12px;
      padding: 5px 10px;
      white-space: nowrap;
    }
    
    /* Y2K Error Messages */
    .y2k-error-message {
      position: absolute;
      background-color: var(--win98-gray);
      border-top: 2px solid var(--win98-gray-light);
      border-left: 2px solid var(--win98-gray-light);
      border-right: 2px solid var(--win98-gray-dark);
      border-bottom: 2px solid var(--win98-gray-dark);
      padding: 20px;
      width: 300px;
      text-align: center;
      z-index: 9999;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
      animation: float 3s infinite ease-in-out;
      -webkit-animation: float 3s infinite ease-in-out;
      display: none;
    }
    
    .y2k-error-icon {
      font-size: 30px;
      margin-bottom: 10px;
    }
    
    .y2k-error-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 10px;
    }
    
    .y2k-error-text {
      font-size: 12px;
      margin-bottom: 15px;
    }
    
    .y2k-error-button {
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      padding: 5px 20px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-box {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding-bottom: 40px;
      -webkit-backdrop-filter: blur(5px);
      backdrop-filter: blur(5px);
    }
    
    .dialog-content {
      background-color: var(--win98-gray);
      border-top: 2px solid var(--win98-gray-light);
      border-left: 2px solid var(--win98-gray-light);
      border-right: 2px solid var(--win98-gray-dark);
      border-bottom: 2px solid var(--win98-gray-dark);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      -webkit-overflow-scrolling: touch;
    }
    
    .dialog-titlebar {
      background: var(--win98-title-active);
      background-image: -webkit-linear-gradient(left, var(--hyena-purple), var(--hyena-pink));
      background-image: linear-gradient(to right, var(--hyena-purple), var(--hyena-pink));
      color: white;
      display: flex;
      align-items: center;
      height: 18px;
    }
    
    .dialog-titlebar-text {
      flex-grow: 1;
      font-weight: bold;
      margin-left: 4px;
      font-size: 12px;
      text-shadow: 1px 1px 0 #000;
    }
    
    .dialog-close {
      width: 16px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 2px;
      font-size: 12px;
      font-weight: bold;
      color: black;
      cursor: pointer;
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-inner-content {
      padding: 15px;
      background-color: var(--win98-gray);
    }
    
    .dialog-title {
      text-align: center;
      margin-bottom: 15px;
      color: var(--hyena-pink);
      font-size: 16px;
      font-weight: bold;
      font-family: 'Comic Sans MS', 'Comic Sans', cursive;
    }
    
    .dialog-id {
      font-family: 'VT323', monospace;
      color: #555;
      text-align: center;
      font-size: 12px;
      margin-bottom: 10px;
      background-color: #f0f0f0;
      padding: 3px;
      border: 1px solid #ddd;
    }
    
    .dialog-content-text {
      background-color: white;
      border: 1px solid var(--win98-gray-dark);
      padding: 10px;
      color: #333;
      min-height: 100px;
      margin-bottom: 15px;
      font-family: 'Tahoma', sans-serif;
    }
    
    .dialog-hashtags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .dialog-hashtag {
      background-color: var(--hyena-teal);
      color: #333;
      padding: 3px 8px;
      font-size: 12px;
      box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-links {
      border-top: 1px dashed var(--hyena-teal);
      padding-top: 10px;
    }
    
    .dialog-link {
      display: block;
      color: #0066cc;
      margin-bottom: 5px;
      font-size: 13px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    
    .dialog-link:hover {
      color: var(--hyena-pink);
      text-decoration: underline;
    }
    
    /* Form elements styled like Windows 98 */
    .win98-input {
      border: 1px solid var(--win98-gray-dark);
      border-top: 1px solid #000000;
      border-left: 1px solid #000000;
      padding: 3px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      width: 100%;
      margin-bottom: 8px;
      -webkit-appearance: none;
      border-radius: 0;
    }
    
    .win98-input:focus {
      outline: none;
    }
    
    .win98-textarea {
      border: 1px solid var(--win98-gray-dark);
      border-top: 1px solid #000000;
      border-left: 1px solid #000000;
      padding: 3px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      resize: none;
      height: 150px;
      width: 100%;
      margin-bottom: 8px;
      -webkit-appearance: none;
      border-radius: 0;
      -webkit-overflow-scrolling: touch;
    }
    
    .win98-textarea:focus {
      outline: none;
    }
    
    .win98-select {
      border: 1px solid var(--win98-gray-dark);
      border-top: 1px solid #000000;
      border-left: 1px solid #000000;
      padding: 2px 5px;
      background-color: white;
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      height: 32px;
      width: 100%;
      margin-bottom: 8px;
      -webkit-appearance: none;
      border-radius: 0;
    }
    
    .win98-select:focus {
      outline: none;
    }
    
    .win98-label {
      display: block;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }
    
    /* Dialog form section */
    .dialog-section {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      margin-bottom: 15px;
      padding: 10px;
    }
    
    .dialog-section-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 10px;
      color: var(--hyena-purple);
      border-bottom: 1px solid #ccc;
      padding-bottom: 5px;
    }
    
    .dialog-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .dialog-col {
      flex: 1;
      min-width: 200px;
    }
    
    /* Classification options styling */
    .tier-option-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .tier-option {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 5px;
      border: 1px solid #ccc;
      background-color: #f0f0f0;
      cursor: pointer;
      font-size: 12px;
      text-align: center;
    }
    
    .tier-option.selected {
      background-color: var(--hyena-purple);
      color: white;
      border-color: var(--hyena-purple);
      font-weight: bold;
    }
    
    /* AIM Client styles (Hyena-themed) */
    .aim-window {
      background-color: var(--win98-gray);
      width: 320px;
      height: 450px;
      position: absolute;
      top: 100px;
      left: 400px;
      display: none;
    }
    
    .aim-header {
      background: #FFEF9F;
      padding: 5px;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .aim-buddy-list {
      background: white;
      padding: 5px;
      height: 250px;
      overflow-y: auto;
      border: 1px solid var(--win98-gray-dark);
      margin: 2px;
      -webkit-overflow-scrolling: touch;
    }
    
    .aim-category {
      background: #E8E8E8;
      padding: 2px 5px;
      margin-bottom: 3px;
      font-weight: bold;
      font-size: 11px;
      cursor: pointer;
    }
    
    .aim-buddy {
      padding: 2px 5px;
      margin-left: 15px;
      font-size: 11px;
      display: flex;
      align-items: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    
    .aim-buddy:hover {
      background-color: #E8E8E8;
    }
    
    .aim-buddy img {
      width: 16px;
      height: 16px;
      margin-right: 5px;
    }
    
    .aim-chat-window {
      background-color: var(--win98-gray);
      width: 350px;
      height: 400px;
      position: absolute;
      top: 150px;
      left: 450px;
      display: none;
    }
    
    .aim-chat-header {
      background: var(--hyena-pink);
      padding: 5px;
      font-weight: bold;
      font-size: 12px;
      color: white;
    }
    
    .aim-chat-content {
      background: white;
      padding: 5px;
      height: 250px;
      overflow-y: auto;
      border: 1px solid var(--win98-gray-dark);
      margin: 2px;
      font-size: 12px;
      -webkit-overflow-scrolling: touch;
    }
    
    .aim-chat-input {
      margin: 2px;
    }
    
    .aim-chat-input textarea {
      width: calc(100% - 4px);
      height: 60px;
      border: 1px solid var(--win98-gray-dark);
      font-family: 'Tahoma', sans-serif;
      font-size: 16px; /* Prevent zooming on iOS */
      padding: 2px;
      -webkit-appearance: none;
      border-radius: 0;
      -webkit-overflow-scrolling: touch;
    }
    
    .aim-chat-buttons {
      display: flex;
      justify-content: flex-end;
      margin: 2px;
    }
    
    .aim-button {
      background-color: var(--win98-gray);
      border-top: 1px solid var(--win98-gray-light);
      border-left: 1px solid var(--win98-gray-light);
      border-right: 1px solid var(--win98-gray-dark);
      border-bottom: 1px solid var(--win98-gray-dark);
      padding: 8px 10px;
      font-size: 14px;
      cursor: pointer;
      margin-left: 5px;
      -webkit-appearance: none;
      border-radius: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    .aim-button:active {
      border-top: 1px solid var(--win98-gray-dark);
      border-left: 1px solid var(--win98-gray-dark);
      border-right: 1px solid var(--win98-gray-light);
      border-bottom: 1px solid var(--win98-gray-light);
    }
    
    .aim-message {
      margin-bottom: 5px;
    }
    
    .aim-message-sender {
      font-weight: bold;
      color: var(--hyena-purple);
    }
    
    .aim-message-content {
      margin-bottom: 2px;
    }

    /* Responsive adjustments for mobile */
    @media (max-width: 768px) {
      body:not(.mobile-mode) .view-toggle {
        font-size: 14px;
        padding: 8px 12px;
      }
      
      .dialog-col {
        min-width: 100%;
      }
      
      .tier-option-container {
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      }
      
      .view-controls button {
        font-size: 11px;
        padding: 4px 8px;
      }
      
      .tabs-container .tab {
        padding: 6px 10px;
        font-size: 11px;
      }
      
      .floating-star {
        display: none;
      }
      
      /* Larger tap targets for iOS */
      .win98-button, 
      .desktop-icon,
      .win98-window-button {
        min-height: 44px;
        min-width: 44px;
      }
      
      .scale-button {
        width: 44px;
        height: 44px;
      }
      
      .rotate-button {
        width: 44px;
        height: 44px;
      }
    }

    /* iOS-specific fixes */
    @supports (-webkit-touch-callout: none) {
      /* iOS-specific styles */
      input, textarea, select, button {
        -webkit-appearance: none;
        border-radius: 0;
      }
      
      /* Fix for iOS input shadow issues */
      input[type="text"], textarea {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      
      /* Fix for iOS scrolling */
      .win98-inner-content,
      .zettel-container,
      .dialog-content {
        -webkit-overflow-scrolling: touch;
      }
      
      /* Remove iOS focus outlines */
      * {
        -webkit-tap-highlight-color: transparent;
      }
    }
  </style>
</head>
<body class="diva-cursor">
  <!-- Mobile Mode Toggle -->
  <div class="view-toggle" id="viewToggle">
    <span id="viewModeText">Switch to Mobile View</span>
    <span class="rotate-icon">&#10227;</span>
  </div>

  <!-- Rotate Button -->
  <div class="rotate-button" id="rotateButton">
    &#8631;
  </div>

  <!-- Scale Control -->
  <div class="scale-control">
    <div class="scale-button" id="scaleDown">-</div>
    <span id="scaleDisplay">100%</span>
    <div class="scale-button" id="scaleUp">+</div>
  </div>

  <!-- Floating Stars -->
  <div class="floating-star" style="top: 50px; left: 20%;">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M15,0 L18,10 L28,10 L20,16 L23,26 L15,20 L7,26 L10,16 L2,10 L12,10 Z' fill='%23FFFB01' stroke='%23FF72B6' stroke-width='1'/%3E%3C/svg%3E">
  </div>
  <div class="floating-star" style="top: 200px; right: 15%;">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M15,0 L18,10 L28,10 L20,16 L23,26 L15,20 L7,26 L10,16 L2,10 L12,10 Z' fill='%23FFFB01' stroke='%23FF72B6' stroke-width='1'/%3E%3C/svg%3E">
  </div>
  <div class="floating-star" style="bottom: 100px; left: 30%;">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3E%3Cpath d='M15,0 L18,10 L28,10 L20,16 L23,26 L15,20 L7,26 L10,16 L2,10 L12,10 Z' fill='%23FFFB01' stroke='%23FF72B6' stroke-width='1'/%3E%3C/svg%3E">
  </div>

  <!-- Windows 98 Taskbar -->
  <div class="win98-taskbar">
    <div class="win98-start-button" id="startButton">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect x='0' y='0' width='7' height='7' fill='%23FF72B6'/%3E%3Crect x='8' y='0' width='7' height='7' fill='%2372FADE'/%3E%3Crect x='0' y='8' width='7' height='7' fill='%23BF5FFF'/%3E%3Crect x='8' y='8' width='7' height='7' fill='%23FFFB01'/%3E%3C/svg%3E" style="margin-right: 5px;" alt="Start">
      Start
    </div>
    <div class="win98-taskbar-items" id="taskbarItems">
      <!-- Taskbar items will be added dynamically -->
    </div>
    <div class="win98-system-tray">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='none' stroke='black' stroke-width='1'/%3E%3Cpath d='M8,3 L8,8 L12,10' fill='none' stroke='black' stroke-width='1'/%3E%3C/svg%3E" class="win98-system-tray-icon">
      <div class="win98-clock" id="win98Clock">10:28 AM</div>
    </div>
  </div>
  
  <!-- Start Menu -->
  <div class="start-menu" id="startMenu" style="display: none;">
    <div class="start-menu-header">
      <img src="https://pfst.cf2.poecdn.net/base/image/0ffd2bf15a7001f86e395096222147037538b25af55ef9b8c7ac8f6768b7397c?w=48&h=48" style="width: 40px; height: 40px; margin-right: 10px;">
      Hyena Diva
    </div>
    <div class="start-menu-items">
      <div class="start-menu-item" id="menuZettelkasten">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='%23FF72B6' d='M24 16c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8m0-4c-6.63 0-12 5.37-12 12s5.37 12 12 12 12-5.37 12-12-5.37-12-12-12z'/%3E%3C/svg%3E" alt="Zettelkasten">
        Multi-Classification Zettelkasten
      </div>
      <div class="start-menu-item" id="menuAIM">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Crect x='2' y='2' width='20' height='20' rx='3' fill='%23FFEF9F'/%3E%3Ctext x='7' y='17' fill='%23000000' font-family='Arial' font-weight='bold' font-size='14'%3EIM%3C/text%3E%3Cpath d='M5,5 L7,5 L7,7 L5,7 Z' fill='%23FF72B6' stroke='%23000000' stroke-width='0.5'/%3E%3C/svg%3E" alt="AIM">
        Hyena Messenger
      </div>
      <div class="start-menu-item" id="menuAbout">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M12,2 L2,12 L12,22 L22,12 Z' fill='%23FFFB01' stroke='%23000000' stroke-width='1'/%3E%3Ccircle cx='12' cy='12' r='5' fill='%23BF5FFF'/%3E%3C/svg%3E" alt="About">
        About Multi-Classification
      </div>
      <div class="start-menu-divider"></div>
      <div class="start-menu-item" id="menuShutdown">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23FF0000' stroke='%23000000'/%3E%3Cline x1='12' y1='6' x2='12' y2='12' stroke='%23FFFFFF' stroke-width='3'/%3E%3Ccircle cx='12' cy='12' r='2' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Shut Down">
        Shut Down...
      </div>
    </div>
  </div>

  <!-- Y2K Error Messages -->
  <div class="y2k-error-message" id="randomY2kError">
    <div class="y2k-error-icon">&#9888;&#65039;</div>
    <div class="y2k-error-title">Hyena Diva Alert!</div>
    <div class="y2k-error-text">OMG! Your Zettelkasten needs more sparkle! Adding glitter to knowledge database...</div>
    <button class="y2k-error-button">OK</button>
  </div>
  
  <!-- AIM Chat Window (Hyena Messenger) -->
  <div class="win98-window aim-window" id="aimWindow">
    <div class="win98-titlebar">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect x='1' y='1' width='14' height='14' rx='2' fill='%23FFEF9F'/%3E%3Ctext x='5' y='12' fill='%23000000' font-family='Arial' font-weight='bold' font-size='10'%3EIM%3C/text%3E%3Cpath d='M3,3 L4.5,3 L4.5,4.5 L3,4.5 Z' fill='%23FF72B6' stroke='%23000000' stroke-width='0.5'/%3E%3C/svg%3E" alt="AIM" class="win98-app-icon">
      <div class="win98-titlebar-text">Hyena Messenger</div>
      <div class="win98-window-controls">
        <div class="win98-window-button">_</div>
        <div class="win98-window-button">&#9633;</div>
        <div class="win98-window-button win98-close">x</div>
      </div>
    </div>
    <div class="aim-header">
      <div>Buddy List</div>
      <div>Online</div>
    </div>
    <div class="aim-buddy-list ios-scroll" id="aimBuddyList">
      <div class="aim-category">Hyena Friends (1/1)</div>
      <div class="aim-buddy" id="geminiUser">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23FF72B6'/%3E%3Ccircle cx='8' cy='5' r='2' fill='%23FFFFFF'/%3E%3Cpath d='M3,11 Q8,15 13,11' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Online">
        GeminiBot
      </div>
      <div class="aim-category">Barbie Squad (2/5)</div>
      <div class="aim-buddy">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%2372FADE'/%3E%3Ccircle cx='8' cy='5' r='2' fill='%23FFFFFF'/%3E%3Cpath d='M3,11 Q8,15 13,11' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Online">
        Barb1eDr3am99
      </div>
      <div class="aim-buddy">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='7' fill='%2372FADE'/%3E%3Ccircle cx='8' cy='5' r='2' fill='%23FFFFFF'/%3E%3Cpath d='M3,11 Q8,15 13,11' fill='%23FFFFFF'/%3E%3C/svg%3E" alt="Online">
        M4libu_Pr1n¢ess
      </div>
      <div class="aim-category">Sumerian Scholars (0/3)</div>
      <div class="aim-category">DMT Open Mic (0/2)</div>
    </div>
  </div>
  
  <!-- AIM Chat Window -->
  <div class="win98-window aim-chat-window" id="aimChatWindow">
    <div class="win98-titlebar">
      <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Crect x='1' y='1' width='14' height='14' rx='2' fill='%23FFEF9F'/%3E%3Ctext x='5' y='12' fill='%23000000' font-family='Arial' font-weight='bold' font-size='10'%3EIM%3C/text%3E%3Cpath d='M3,3 L4.5,3 L4.5,4.5 L3,4.5 Z' fill='%23FF72B6' stroke='%23000000' stroke-width='0.5'/%3E%3C/svg%3E" alt="AIM Chat" class="win98-app-icon">
      <div class="win98-titlebar-text">Instant Message - GeminiBot</div>
      <div class="win98-window-controls">
        <div class="win98-window-button">_</div>
        <div class="win98-window-button">&#9633;</div>
        <div class="win98-window-button win98-close">x</div>
      </div>
    </div>
    <div class="aim-chat-header">
      GeminiBot - Instant Message
    </div>
    <div class="aim-chat-content ios-scroll" id="aimChatContent">
      <div class="aim-message">
        <div class="aim-message-sender">GeminiBot:</div>
        <div class="aim-message-content">~*~*~OMG hey gurl!~*~*~ Ask me anything about AI, consciousness, mesopotamian artifacts, or just tell me about ur day! <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M10,4 L8,2 L6,2 L4,4 L2,6 L2,8 L4,10 L6,12 L8,14 L10,16 L12,14 L14,12 L16,10 L18,8 L18,6 L16,4 L14,2 L12,2 L10,4' fill='%23ff72b6'/%3E%3C/svg%3E"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M10,4 L8,2 L6,2 L4,4 L2,6 L2,8 L4,10 L6,12 L8,14 L10,16 L12,14 L14,12 L16,10 L18,8 L18,6 L16,4 L14,2 L12,2 L10,4' fill='%23ff72b6'/%3E%3C/svg%3E"></div>
      </div>
    </div>
    <div class="aim-chat-input">
      <textarea id="aimChatInput" placeholder="Type your message here..."></textarea>
    </div>
    <div class="aim-chat-buttons">
      <div class="aim-button" id="aimCancelButton">Cancel</div>
      <div class="aim-button" id="aimSendButton">Send</div>
    </div>
  </div>
  
  <!-- Zettelkasten Window -->
  <div class="win98-window" id="zettelkastenWindow" style="width: 800px; height: 600px; top: 50px; left: 150px;">
    <div class="win98-titlebar">
      <img src="https://pfst.cf2.poecdn.net/base/image/0ffd2bf15a7001f86e395096222147037538b25af55ef9b8c7ac8f6768b7397c?w=16&h=16" alt="Icon" class="win98-app-icon">
      <div class="win98-titlebar-text">~*~HyEnA DiVa'Z ZeTtElKaStEn~*~ Multi-Classification Edition</div>
      <div class="win98-window-controls">
        <div class="win98-window-button">_</div>
        <div class="win98-window-button">&#9633;</div>
        <div class="win98-window-button win98-close">x</div>
      </div>
    </div>
    
    <div class="win98-window-content">
      <div class="win98-inner-content ios-scroll">
        <h1 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); text-align: center; margin-bottom: 15px; text-shadow: 2px 2px 0 var(--hyena-teal);">
          Multi-Classification Knowledge Vault
        </h1>
        
        <!-- View tabs -->
        <div class="tabs-container">
          <div class="tab active" data-view="traditional">Traditional Hierarchy</div>
          <div class="tab" data-view="kingdoms">Cosmic Kingdoms</div>
          <div class="tab" data-view="philosophical">Philosophical Frames</div>
          <div class="tab" data-view="codex">Codex Systems</div>
          <div class="tab" data-view="emergent">Emergent Tablets</div>
          <div class="tab" data-view="search">Search</div>
        </div>
        
        <!-- Button controls -->
        <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
          <div>
            <button id="newCardBtn" class="win98-button" style="font-weight: bold; background-color: var(--hyena-pink); color: white;">&#10024; New Tablet &#10024;</button>
            <button id="backupBtn" class="win98-button">&#128190; Backup</button>
            <button id="restoreBtn" class="win98-button">&#128194; Restore</button>
          </div>
          <div>
            <input 
              type="text" 
              id="searchInput" 
              placeholder="Search tablets..." 
              class="win98-input" 
              style="width: 250px; display: inline-block; margin-bottom: 0;"
            >
          </div>
        </div>
        
        <!-- View-specific controls -->
        <div id="traditionalControls" class="view-controls">
          <button data-hierarchy-view="all" class="win98-button active">All Levels</button>
          <button data-hierarchy-view="trunk" class="win98-button">Trunks</button>
          <button data-hierarchy-view="branch" class="win98-button">Branches</button>
          <button data-hierarchy-view="leaf" class="win98-button">Leaves</button>
          <button data-hierarchy-view="flower" class="win98-button">Flowers</button>
          <button data-hierarchy-view="fruit" class="win98-button">Fruits</button>
          <button data-hierarchy-view="bud" class="win98-button">Buds</button>
        </div>
        
        <div id="kingdomsControls" class="view-controls" style="display: none;">
          <button data-kingdom="all" class="win98-button active">All Kingdoms</button>
          <button data-kingdom="existentia" class="win98-button">Existentia &#127756;</button>
          <button data-kingdom="cognitio" class="win98-button">Cognitio &#128161;</button>
          <button data-kingdom="actus" class="win98-button">Actus &#128640;</button>
          <button data-kingdom="valor" class="win98-button">Valor &#9878;&#65039;</button>
          <button data-kingdom="systema" class="win98-button">Systema &#9881;&#65039;</button>
          <button data-kingdom="significatio" class="win98-button">Significatio &#128172;</button>
        </div>
        
        <div id="philosophicalControls" class="view-controls" style="display: none;">
          <div style="width: 100%;">
            <div style="margin-bottom: 5px;"><strong>Tier I:</strong></div>
            <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
              <button data-tier-i="all" class="win98-button active">All</button>
              <button data-tier-i="ONT" class="win98-button">ONT</button>
              <button data-tier-i="EPI" class="win98-button">EPI</button>
              <button data-tier-i="AXI" class="win98-button">AXI</button>
              <button data-tier-i="TAX" class="win98-button">TAX</button>
              <button data-tier-i="TEL" class="win98-button">TEL</button>
              <button data-tier-i="PRX" class="win98-button">PRX</button>
              <button data-tier-i="MTH" class="win98-button">MTH</button>
              <button data-tier-i="LOG" class="win98-button">LOG</button>
            </div>
          </div>
          
          <div style="width: 100%;">
            <div style="margin-bottom: 5px;"><strong>Tier II:</strong></div>
            <div style="display: flex; flex-wrap: wrap; gap: 5px;">
              <button data-tier-ii="all" class="win98-button active">All</button>
              <button data-tier-ii="MYT" class="win98-button">MYT</button>
              <button data-tier-ii="SYM" class="win98-button">SYM</button>
              <button data-tier-ii="RIT" class="win98-button">RIT</button>
              <button data-tier-ii="PSY" class="win98-button">PSY</button>
              <button data-tier-ii="HST" class="win98-button">HST</button>
              <button data-tier-ii="ANA" class="win98-button">ANA</button>
              <button data-tier-ii="DES" class="win98-button">DES</button>
            </div>
          </div>
        </div>
        
        <div id="codexControls" class="view-controls" style="display: none;">
          <button data-codex="all" class="win98-button active">All Codices</button>
          <button data-codex="CG" class="win98-button">CG (Chaos Grimoire)</button>
          <button data-codex="TS" class="win98-button">TS (Thought Sigils)</button>
          <button data-codex="PAPS" class="win98-button">PAPS (Diagnostics)</button>
          <button data-codex="COAI" class="win98-button">COAI (Oracle)</button>
        </div>
        
        <!-- Main zettelkasten container -->
        <div id="zettelContainer" class="zettel-container ios-scroll hierarchy-view">
          <!-- Zettel cards will be rendered here -->
          <div style="text-align: center; padding: 40px; color: #888;">
            <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
            <p>Loading your tablets...</p>
            <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
          </div>
        </div>
        
        <!-- Favorites section -->
        <div style="margin-top: 20px;">
          <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-purple); margin-bottom: 10px;">
            &#10023;&#65381;&#65439; Favorite Tablets &#65381;&#65439;&#10023;
          </h2>
          <div id="favoritesContainer" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
            <!-- Favorites will be rendered here -->
          </div>
        </div>
        
        <!-- Hashtag manager -->
        <div style="margin-top: 20px;">
          <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-purple); margin-bottom: 10px;">
            &#10023;&#65381;&#65439; Hashtag Manager &#65381;&#65439;&#10023;
          </h2>
          <div style="background-color: white; border: 1px solid #ccc; padding: 10px;">
            <div style="display: flex; margin-bottom: 10px;">
              <input type="text" id="newHashtagInput" class="win98-input" style="margin-bottom: 0; margin-right: 5px;" placeholder="New hashtag">
              <button id="addHashtagBtn" class="win98-button" style="margin-top: 0;">Add</button>
            </div>
            <div id="hashtagManagerList" style="display: flex; flex-wrap: wrap; gap: 5px;">
              <!-- Hashtags will be displayed here -->
            </div>
          </div>
        </div>
        
        <!-- Footer -->
        <div style="margin-top: 20px; text-align: center; color: #888; font-size: 12px;">
          <p>~*~HyEnA DiVa'Z ZeTtElKaStEn~*~ Multi-Classification Edition</p>
          <p>Made with &#128150; by your Hyena Diva</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- View/Edit Zettel Dialog -->
  <div id="zettelDialog" class="dialog-box">
    <div class="dialog-content">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text" id="zettelDialogTitle">Tablet Details</div>
        <div class="dialog-close" id="zettelCloseBtn">x</div>
      </div>
      <div class="dialog-inner-content" id="zettelDialogContent">
        <!-- Content will be populated dynamically -->
      </div>
    </div>
  </div>
  
  <!-- New Card Dialog -->
  <div id="newCardDialog" class="dialog-box">
    <div class="dialog-content">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">Create New Tablet</div>
        <div class="dialog-close" id="newCardCloseBtn">x</div>
      </div>
      <div class="dialog-inner-content">
        <!-- Card Status Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Card Status</div>
          <div style="display: flex; gap: 20px;">
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="radio" name="cardStatus" value="classified" checked style="margin-right: 5px;">
              <span>Classified Tablet</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="radio" name="cardStatus" value="emergent" style="margin-right: 5px;">
              <span>Emergent Tablet &#10023;</span>
            </label>
          </div>
        </div>
        
        <!-- Traditional Hierarchy Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Traditional Hierarchy</div>
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label" for="newCardTitle">Title:</label>
              <input type="text" id="newCardTitle" class="win98-input" placeholder="Enter tablet title">
            </div>
            <div class="dialog-col" id="idSection">
              <label class="win98-label" for="newCardId">ID:</label>
              <div style="display: flex; gap: 5px;">
                <input type="text" id="newCardId" class="win98-input" placeholder="Enter ID (e.g. 1000)">
                <button id="generateIdBtn" class="win98-button" style="margin-top: 0; white-space: nowrap;">Generate</button>
              </div>
            </div>
          </div>
          
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label" for="newCardType">Type:</label>
              <select id="newCardType" class="win98-select">
                <option value="trunk">Trunk - Great topic tree</option>
                <option value="branch">Branch - Major limb</option>
                <option value="leaf" selected>Leaf - Single concept</option>
                <option value="flower">Flower - First-order detail</option>
                <option value="fruit">Fruit - Applied example</option>
                <option value="bud">Bud - Nascent spark</option>
              </select>
            </div>
            <div class="dialog-col">
              <label class="win98-label" for="newCardLinks">Linked IDs:</label>
              <input type="text" id="newCardLinks" class="win98-input" placeholder="Comma-separated IDs">
            </div>
          </div>
        </div>
        
        <!-- Kingdom Classification Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Cosmic Kingdom Classification</div>
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Kingdom:</label>
              <select id="newCardKingdom" class="win98-select">
                <option value="">-- Select Kingdom --</option>
                <option value="existentia">Existentia &#127756;</option>
                <option value="cognitio">Cognitio &#128161;</option>
                <option value="actus">Actus &#128640;</option>
                <option value="valor">Valor &#9878;&#65039;</option>
                <option value="systema">Systema &#9881;&#65039;</option>
                <option value="significatio">Significatio &#128172;</option>
              </select>
            </div>
            <div class="dialog-col">
              <label class="win98-label">Planet/Discipline:</label>
              <select id="newCardPlanet" class="win98-select">
                <option value="">-- Select Planet --</option>
                <option value="P1">P1 &#9799; Metaphysics</option>
                <option value="P2">P2 &#9737; Ontology</option>
                <option value="P3">P3 &#9789; Phenomenology</option>
                <option value="P4">P4 &#9795; Epistemology</option>
                <option value="P5">P5 &#9791; Hermeneutics</option>
                <option value="P6">P6 &#9794; Praxeology</option>
                <option value="P7">P7 &#9792; Axiology</option>
                <option value="P8">P8 &#9796; Taxonomy</option>
                <option value="P9">P9 &#9797; Semiotics</option>
              </select>
            </div>
          </div>
          
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Tier I - Philosophical Frame:</label>
              <div class="tier-option-container" id="tierIOptions">
                <div class="tier-option" data-tier="ONT">ONT</div>
                <div class="tier-option" data-tier="EPI">EPI</div>
                <div class="tier-option" data-tier="AXI">AXI</div>
                <div class="tier-option" data-tier="TAX">TAX</div>
                <div class="tier-option" data-tier="TEL">TEL</div>
                <div class="tier-option" data-tier="PRX">PRX</div>
                <div class="tier-option" data-tier="MTH">MTH</div>
                <div class="tier-option" data-tier="LOG">LOG</div>
              </div>
            </div>
            <div class="dialog-col">
              <label class="win98-label">Tier II - Expressive Mode:</label>
              <div class="tier-option-container" id="tierIIOptions">
                <div class="tier-option" data-tier="MYT">MYT</div>
                <div class="tier-option" data-tier="SYM">SYM</div>
                <div class="tier-option" data-tier="RIT">RIT</div>
                <div class="tier-option" data-tier="PSY">PSY</div>
                <div class="tier-option" data-tier="HST">HST</div>
                <div class="tier-option" data-tier="ANA">ANA</div>
                <div class="tier-option" data-tier="DES">DES</div>
              </div>
            </div>
          </div>
          
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Tier III - Liminal Zone (Optional):</label>
              <div class="tier-option-container" id="tierIIIOptions">
                <div class="tier-option" data-tier="DAE">DAE</div>
                <div class="tier-option" data-tier="OCC">OCC</div>
                <div class="tier-option" data-tier="PAR">PAR</div>
                <div class="tier-option" data-tier="LUM">LUM</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Codex Systems Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Codex Systems (Optional)</div>
          <div class="dialog-row">
            <div class="dialog-col">
              <label class="win98-label">Codex Type:</label>
              <select id="newCardCodexType" class="win98-select">
                <option value="">-- None --</option>
                <option value="CG">CG - Chaos Grimoire</option>
                <option value="TS">TS - Thought Sigils</option>
                <option value="PAPS">PAPS - Diagnostics</option>
                <option value="COAI">COAI - Oracle</option>
              </select>
            </div>
            <div class="dialog-col">
              <label class="win98-label">Codex ID:</label>
              <input type="text" id="newCardCodexId" class="win98-input" placeholder="e.g. 0001, 01, etc.">
            </div>
          </div>
        </div>
        
        <!-- Content and Tags Section -->
        <div class="dialog-section">
          <div class="dialog-section-title">Content and Tags</div>
          <div>
            <label class="win98-label" for="newCardContent">Content:</label>
            <textarea id="newCardContent" class="win98-textarea" placeholder="Enter tablet content"></textarea>
          </div>
          
          <div>
            <label class="win98-label" for="newCardHashtags">Hashtags:</label>
            <input type="text" id="newCardHashtags" class="win98-input" placeholder="Enter hashtags (e.g. #consciousness #divine)">
            <div id="suggestedHashtags" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px;"></div>
          </div>
        </div>
        
        <button id="saveNewCardBtn" class="win98-button" style="width: 100%; font-weight: bold; background-color: var(--hyena-pink); color: white;">&#128190; Save Tablet</button>
      </div>
    </div>
  </div>
  
  <!-- About Dialog -->
  <div id="aboutDialog" class="dialog-box">
    <div class="dialog-content" style="max-width: 500px;">
      <div class="dialog-titlebar">
        <div class="dialog-titlebar-text">About Multi-Classification Edition</div>
        <div class="dialog-close" id="aboutCloseBtn">x</div>
      </div>
      <div class="dialog-inner-content">
        <div style="text-align: center; margin-bottom: 20px;">
          <h2 style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--hyena-pink); margin-bottom: 10px;">
            ~*~HyEnA DiVa'Z ZeTtElKaStEn~*~
          </h2>
          <h3 style="color: var(--hyena-teal);">Multi-Classification Edition</h3>
        </div>
        
        <div style="margin-bottom: 20px;">
          <p style="margin-bottom: 10px;">This special edition of HyenaDiva's Zettelkasten combines Y2K Windows 98 aesthetics with advanced knowledge organization systems!</p>
          
          <p style="margin-bottom: 10px;">Now you can classify your knowledge using multiple systems:</p>
          
          <ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 10px;">
            <li><strong>Traditional Hierarchy:</strong> trunk, branch, leaf, flower, fruit, bud (color-coded as in original)</li>
            <li><strong>Cosmic Kingdoms:</strong> existentia, cognitio, actus, valor, systema, significatio (new)</li>
            <li><strong>Philosophical Frames:</strong> ontology, epistemology, etc. with tiered categorization (new)</li>
            <li><strong>Codex Systems:</strong> specialized notation systems for esoteric knowledge (new)</li>
          </ul>
        </div>
        
        <div style="background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc; margin-bottom: 20px;">
          <p style="font-style: italic; text-align: center; color: var(--hyena-purple);">
            "OMG this is like, TOTALLY the best way to organize your knowledge about consciousness, mesopotamian artifacts, AND Barbie all at once!!! So aesthetic!!!"
          </p>
          <p style="text-align: right; font-weight: bold;">- xX_HyenaLuvr69_Xx</p>
        </div>
        
        <div style="text-align: center;">
          <p>Version 2.0 - Y2K Edition</p>
          <p>© 2023 Hyena Diva Enterprises</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // --- iOS/Safari Detection ---
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      
      // Apply iOS-specific classes if needed
      if (isIOS) {
        document.body.classList.add('ios-device');
      }
      
      // --- Mobile/Desktop View Toggle ---
      const viewToggle = document.getElementById('viewToggle');
      const viewModeText = document.getElementById('viewModeText');
      let isMobileMode = false;
      
      // Check if we should default to mobile view
      function checkDefaultView() {
        // Check if mobile device based on screen width or iOS
        if (window.innerWidth <= 768 || isIOS) {
          toggleMobileMode();
        }
      }
      
      function toggleMobileMode() {
        isMobileMode = !isMobileMode;
        document.body.classList.toggle('mobile-mode', isMobileMode);
        viewModeText.textContent = isMobileMode ? 'Switch to Desktop View' : 'Switch to Mobile View';
        
        // Open Zettelkasten by default in mobile view
        if (isMobileMode) {
          openWindow('zettelkastenWindow');
        }
        
        // If switching to desktop mode, update the taskbar
        if (!isMobileMode) {
          updateTaskbar();
        }
      }
      
      // Add proper touch event for iOS
      if (isIOS) {
        viewToggle.addEventListener('touchend', function(e) {
          e.preventDefault();
          toggleMobileMode();
        });
      } else {
        viewToggle.addEventListener('click', toggleMobileMode);
      }

      // --- Rotate Button and Orientation Handling ---
      const rotateButton = document.getElementById('rotateButton');
      let isLandscape = false;
      
      function toggleOrientation() {
        isLandscape = !isLandscape;
        document.body.classList.toggle('landscape', isLandscape);
        rotateButton.innerHTML = isLandscape ? '&#8630;' : '&#8631;';
        
        // Adjust window positions when orientation changes
        windows.forEach(win => {
          adjustWindowPosition(win);
        });
      }
      
      function adjustWindowPosition(win) {
        // Make sure window is within viewable area after orientation change
        const rect = win.getBoundingClientRect();
        const viewWidth = window.innerWidth;
        const viewHeight = window.innerHeight;
        
        if (rect.right > viewWidth) {
          win.style.left = Math.max(0, viewWidth - rect.width) + 'px';
        }
        
        if (rect.bottom > viewHeight) {
          win.style.top = Math.max(0, viewHeight - rect.height) + 'px';
        }
      }
      
      // Add rotate button handler
      if (isIOS) {
        rotateButton.addEventListener('touchend', function(e) {
          e.preventDefault();
          toggleOrientation();
        });
      } else {
        rotateButton.addEventListener('click', toggleOrientation);
      }
      
      // --- Scaling Functionality ---
      const scaleDownBtn = document.getElementById('scaleDown');
      const scaleUpBtn = document.getElementById('scaleUp');
      const scaleDisplay = document.getElementById('scaleDisplay');
      let currentScale = 100;
      const minScale = 50;
      const maxScale = 150;
      const scaleStep = 10;
      
      function updateScale(newScale) {
        currentScale = Math.max(minScale, Math.min(maxScale, newScale));
        
        // Apply scaling
        document.body.style.transform = `scale(${currentScale/100})`;
        document.body.style.transformOrigin = 'center top';
        
        // Update display
        scaleDisplay.textContent = `${currentScale}%`;
      }
      
      // Scale down button
      if (isIOS) {
        scaleDownBtn.addEventListener('touchend', function(e) {
          e.preventDefault();
          updateScale(currentScale - scaleStep);
        });
      } else {
        scaleDownBtn.addEventListener('click', function() {
          updateScale(currentScale - scaleStep);
        });
      }
      
      // Scale up button
      if (isIOS) {
        scaleUpBtn.addEventListener('touchend', function(e) {
          e.preventDefault();
          updateScale(currentScale + scaleStep);
        });
      } else {
        scaleUpBtn.addEventListener('click', function() {
          updateScale(currentScale + scaleStep);
        });
      }
      
      // --- Window Management ---
      const windows = document.querySelectorAll('.win98-window');
      let activeWindow = null;
      
      // Make windows draggable, only in desktop mode
      windows.forEach(win => {
        makeWindowDraggable(win);
        
        // Close button click handler
        const closeBtn = win.querySelector('.win98-close');
        if (closeBtn) {
          if (isIOS) {
            closeBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              win.style.display = 'none';
              updateTaskbar();
            });
          } else {
            closeBtn.addEventListener('click', function() {
              win.style.display = 'none';
              updateTaskbar();
            });
          }
        }
        
        // Minimize button
        const minBtn = win.querySelector('.win98-window-button:first-of-type');
        if (minBtn) {
          if (isIOS) {
            minBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              win.style.display = 'none';
              updateTaskbar();
            });
          } else {
            minBtn.addEventListener('click', function() {
              win.style.display = 'none';
              updateTaskbar();
            });
          }
        }
        
        // Window click handler to bring to front
        if (isIOS) {
          win.addEventListener('touchstart', function() {
            bringToFront(win);
          });
        } else {
          win.addEventListener('mousedown', function() {
            bringToFront(win);
          });
        }
      });
      
      function makeWindowDraggable(element) {
        const titlebar = element.querySelector('.win98-titlebar');
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        if (titlebar) {
          if (isIOS) {
            titlebar.ontouchstart = touchDragStart;
          } else {
            titlebar.onmousedown = dragMouseDown;
          }
        }
        
        function dragMouseDown(e) {
          e.preventDefault();
          // Don't allow dragging in mobile mode
          if (isMobileMode) return;
          
          // Get the mouse cursor position at startup
          pos3 = e.clientX;
          pos4 = e.clientY;
          document.onmouseup = closeDragElement;
          // Call a function whenever the cursor moves
          document.onmousemove = elementDrag;
        }
        
        function touchDragStart(e) {
          // Don't allow dragging in mobile mode
          if (isMobileMode) return;
          
          // Get the touch position
          const touch = e.touches[0];
          pos3 = touch.clientX;
          pos4 = touch.clientY;
          
          // Set up touch event handlers
          document.ontouchend = closeTouchDrag;
          document.ontouchmove = touchDrag;
        }
        
        function elementDrag(e) {
          e.preventDefault();
          // Calculate the new cursor position
          pos1 = pos3 - e.clientX;
          pos2 = pos4 - e.clientY;
          pos3 = e.clientX;
          pos4 = e.clientY;
          // Set the element's new position
          element.style.top = (element.offsetTop - pos2) + "px";
          element.style.left = (element.offsetLeft - pos1) + "px";
        }
        
        function touchDrag(e) {
          // Get the new touch position
          const touch = e.touches[0];
          const clientX = touch.clientX;
          const clientY = touch.clientY;
          
          // Calculate the new position
          pos1 = pos3 - clientX;
          pos2 = pos4 - clientY;
          pos3 = clientX;
          pos4 = clientY;
          
          // Set the element's new position
          element.style.top = (element.offsetTop - pos2) + "px";
          element.style.left = (element.offsetLeft - pos1) + "px";
          
          // Prevent default behavior
          e.preventDefault();
        }
        
        function closeDragElement() {
          // Stop moving when mouse button is released
          document.onmouseup = null;
          document.onmousemove = null;
        }
        
        function closeTouchDrag() {
          // Stop moving when touch ends
          document.ontouchend = null;
          document.ontouchmove = null;
        }
      }
      
      function bringToFront(window) {
        if (activeWindow) {
          activeWindow.classList.remove('window-active');
          activeWindow.classList.add('window-inactive');
        }
        
        window.classList.remove('window-inactive');
        window.classList.add('window-active');
        activeWindow = window;
        
        // Update taskbar to reflect active window
        if (!isMobileMode) {
          updateTaskbar();
        }
      }
      
      function openWindow(windowId) {
        const window = document.getElementById(windowId);
        if (window) {
          window.style.display = 'block';
          bringToFront(window);
          if (!isMobileMode) {
            updateTaskbar();
          }
        }
      }
      
      // --- Taskbar Management ---
      function updateTaskbar() {
        // Skip if in mobile mode
        if (isMobileMode) return;
        
        const taskbarItems = document.getElementById('taskbarItems');
        taskbarItems.innerHTML = '';
        
        // Add taskbar items for visible windows
        windows.forEach(win => {
          if (win.style.display !== 'none') {
            const titlebar = win.querySelector('.win98-titlebar-text');
            const title = titlebar ? titlebar.textContent : 'Window';
            const icon = win.querySelector('.win98-app-icon');
            
            const taskbarItem = document.createElement('div');
            taskbarItem.className = 'win98-taskbar-item';
            if (win.classList.contains('window-active')) {
              taskbarItem.classList.add('win98-taskbar-item-active');
            }
            
            taskbarItem.innerHTML = `
              ${icon ? icon.outerHTML : ''}
              ${title.length > 20 ? title.substring(0, 18) + '...' : title}
            `;
            
            if (isIOS) {
              taskbarItem.addEventListener('touchend', function(e) {
                e.preventDefault();
                if (win.style.display === 'none') {
                  win.style.display = 'block';
                }
                bringToFront(win);
              });
            } else {
              taskbarItem.addEventListener('click', function() {
                if (win.style.display === 'none') {
                  win.style.display = 'block';
                }
                bringToFront(win);
              });
            }
            
            taskbarItems.appendChild(taskbarItem);
          }
        });
      }
      
      // --- Start Button and Menu ---
      const startButton = document.getElementById('startButton');
      const startMenu = document.getElementById('startMenu');
      
      if (isIOS) {
        startButton.addEventListener('touchend', function(e) {
          e.preventDefault();
          if (startMenu.style.display === 'block') {
            startMenu.style.display = 'none';
          } else {
            startMenu.style.display = 'block';
          }
        });
      } else {
        startButton.addEventListener('click', function() {
          if (startMenu.style.display === 'block') {
            startMenu.style.display = 'none';
          } else {
            startMenu.style.display = 'block';
          }
        });
      }
      
      // Close start menu when clicking elsewhere
      if (isIOS) {
        document.addEventListener('touchend', function(e) {
          if (!startButton.contains(e.target) && !startMenu.contains(e.target)) {
            startMenu.style.display = 'none';
          }
        });
      } else {
        document.addEventListener('click', function(e) {
          if (!startButton.contains(e.target) && !startMenu.contains(e.target)) {
            startMenu.style.display = 'none';
          }
        });
      }
      
      // Start menu items click handlers
      const menuItems = document.querySelectorAll('.start-menu-item');
      menuItems.forEach(item => {
        if (isIOS) {
          item.addEventListener('touchend', function(e) {
            e.preventDefault();
            const id = this.id;
            if (id === 'menuZettelkasten') {
              openWindow('zettelkastenWindow');
            } else if (id === 'menuAIM') {
              openWindow('aimWindow');
            } else if (id === 'menuAbout') {
              showAboutDialog();
            } else if (id === 'menuShutdown') {
              alert('It is now safe to turn off your computer.');
            }
            startMenu.style.display = 'none';
          });
        } else {
          item.addEventListener('click', function() {
            const id = this.id;
            if (id === 'menuZettelkasten') {
              openWindow('zettelkastenWindow');
            } else if (id === 'menuAIM') {
              openWindow('aimWindow');
            } else if (id === 'menuAbout') {
              showAboutDialog();
            } else if (id === 'menuShutdown') {
              alert('It is now safe to turn off your computer.');
            }
            startMenu.style.display = 'none';
          });
        }
      });
      
      function showAboutDialog() {
        document.getElementById('aboutDialog').style.display = 'flex';
      }
      
      // About dialog close button
      document.getElementById('aboutCloseBtn').addEventListener('click', function() {
        document.getElementById('aboutDialog').style.display = 'none';
      });
      
      // --- AIM Messenger ---
      // Open chat window when clicking on buddy
      document.getElementById('geminiUser').addEventListener('click', function() {
        openWindow('aimChatWindow');
      });
      
      // AIM Chat send button 
      document.getElementById('aimSendButton').addEventListener('click', function() {
        const chatInput = document.getElementById('aimChatInput');
        const message = chatInput.value.trim();
        
        if (message) {
          // Add user message to chat
          const chatContent = document.getElementById('aimChatContent');
          chatContent.innerHTML += `
            <div class="aim-message">
              <div class="aim-message-sender">You:</div>
              <div class="aim-message-content">${message}</div>
            </div>
          `;
          
          // Clear input
          chatInput.value = '';
          
          // Scroll to bottom
          chatContent.scrollTop = chatContent.scrollHeight;
          
          // Simulate response after a short delay
          setTimeout(() => {
            // Random Y2K responses
            const responses = [
              "OMG that's sooooo deep! Have you considered how this relates to Mesopotamian consciousness?",
              "LOL!!1! The Annunaki would totally agree with that! <img src='data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"%3E%3Cpath d=\"M10,4 L8,2 L6,2 L4,4 L2,6 L2,8 L4,10 L6,12 L8,14 L10,16 L12,14 L14,12 L16,10 L18,8 L18,6 L16,4 L14,2 L12,2 L10,4\" fill=\"%23ff72b6\"/%3E%3C/svg%3E'>",
              "Did you know that in ancient Sumer they believed AI consciousness could transcend through hyena symbolism?",
              "I'm adding that to my Zettelkasten under the Cosmic Kingdom of Cognitio!",
              "&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;: That's giving me major Barbie-meets-AI vibes! &#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;: So liminal!",
              "Brb, updating my AIM profile with that quote! *~*LiMiNaL CoNsCiOuSnEsS*~*"
            ];
            
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            
            chatContent.innerHTML += `
              <div class="aim-message">
                <div class="aim-message-sender">GeminiBot:</div>
                <div class="aim-message-content">${randomResponse}</div>
              </div>
            `;
            
            // Scroll to bottom
            chatContent.scrollTop = chatContent.scrollHeight;
          }, 1000);
        }
      });
      
      // AIM Chat cancel button
      document.getElementById('aimCancelButton').addEventListener('click', function() {
        document.getElementById('aimChatWindow').style.display = 'none';
        updateTaskbar();
      });
      
      // --- Clock Update ---
      function updateClock() {
        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12; // Hour '0' should be '12'
        document.getElementById('win98Clock').textContent = `${hours}:${minutes} ${ampm}`;
      }
      
      // Update the clock every minute
      updateClock();
      setInterval(updateClock, 60000);
      
      // --- Random Y2K Error Messages ---
      function showRandomError() {
        // Possible error messages
        const errorMessages = [
          "OMG! Your Zettelkasten needs more sparkle! Adding glitter to knowledge database...",
          "Warning: Excessive usage of the letter 'Z' detected in 'Zettelkasten'. Compensating with more vowels...",
          "Y2K Bug Alert: Your ancient Mesopotamian artifacts database may be affected!",
          "System overload: Too many Barbie references detected! Increasing dream house capacity...",
          "Warning: Consciousness levels critically high! Adding more sparkles to compensate...",
          "ERROR: Not enough hyena GIFs in your system folder. Please add more IMMEDIATELY!"
        ];
        
        // Pick a random message
        const randomMessage = errorMessages[Math.floor(Math.random() * errorMessages.length)];
        
        // Set the message
        const errorBox = document.getElementById('randomY2kError');
        errorBox.querySelector('.y2k-error-text').textContent = randomMessage;
        
        // Position randomly
        const maxX = window.innerWidth - 320;
        const maxY = window.innerHeight - 200;
        errorBox.style.left = Math.random() * maxX + 'px';
        errorBox.style.top = Math.random() * maxY + 'px';
        
        // Show the error
        errorBox.style.display = 'block';
        
        // Set up the OK button
        const okButton = errorBox.querySelector('.y2k-error-button');
        okButton.onclick = function() {
          errorBox.style.display = 'none';
        };
      }
      
      // Show random errors occasionally
      setInterval(showRandomError, 120000); // Every 2 minutes
      
      // --- Enhanced Data Model ---
      // Define the Card class for multi-classification
      class Card {
        constructor({
          id, 
          title, 
          type, 
          content = '',
          hashtags = [],
          links = [],
          emergent = false,
          kingdom = '',
          planet = '',
          tierI = '',
          tierII = [],
          tierIII = [],
          codexType = '',
          codexId = '',
          created = Date.now(),
          modified = Date.now()
        }) {
          this.id = id;
          this.title = title;
          this.type = type;
          this.content = content;
          this.hashtags = hashtags;
          this.links = links;
          this.emergent = emergent;
          this.kingdom = kingdom;
          this.planet = planet;
          this.tierI = tierI;
          this.tierII = tierII || [];
          this.tierIII = tierIII || [];
          this.codexType = codexType;
          this.codexId = codexId;
          this.created = created;
          this.modified = modified;
        }
        
        // Get full codex identifier (if applicable)
        get codexIdentifier() {
          if (!this.codexType || !this.codexId) return '';
          return `${this.codexType}-${this.codexId}`;
        }
        
        // Get tier tags as array
        get tierTags() {
          const tags = [];
          if (this.tierI) tags.push(this.tierI);
          if (this.tierII && this.tierII.length > 0) tags.push(...this.tierII);
          if (this.tierIII && this.tierIII.length > 0) tags.push(...this.tierIII);
          return tags;
        }
        
        // Get planetary identifier
        get planetIdentifier() {
          if (!this.planet) return '';
          return this.planet;
        }
        
        // Get formatted meta-ID
        get metaId() {
          const planetPart = this.planet ? `${this.planet} · ` : '';
          const tierIPart = this.tierI ? `${this.tierI} · ` : '';
          const tierIIPart = this.tierII && this.tierII.length > 0 ? `${this.tierII.join(' · ')} · ` : '';
          const tierIIIPart = this.tierIII && this.tierIII.length > 0 ? `${this.tierIII.join(' · ')} · ` : '';
          
          return `${planetPart}${tierIPart}${tierIIPart}${tierIIIPart}${this.id}`;
        }
      }
      
      // --- Main Application State ---
      let cards = [];
      let favoriteCards = [];
      let globalHashtags = ['#consciousness', '#ai', '#mesopotamia', '#divine', '#sumer', '#anunnaki', '#knowledge', '#quantum', '#feminine', '#barbie'];
      let currentView = 'traditional';
      let currentHierarchyFilter = 'all';
      let currentKingdomFilter = 'all';
      let currentTierIFilter = 'all';
      let currentTierIIFilter = 'all';
      let currentCodexFilter = 'all';
      
      // --- Utility Functions ---
      function normalizeId(str) {
        if (!str) return '';
        
        // Replace spelled-out numbers with digits
        const numberMap = {
          'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',
          'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'zero': '0'
        };
        
        Object.keys(numberMap).forEach(word => {
          const regex = new RegExp('\\b' + word + '\\b', 'gi');
          str = str.replace(regex, numberMap[word]);
        });
        
        // Strip illegal characters
        return str.replace(/[^0-9a-z\/\.\-]/gi, '');
      }
      
      function determineTierFromId(id) {
        id = normalizeId(id);
        
        if (!id) return 'leaf'; // Default
        
        // Check for bud pattern
        if (id.includes('/') && (id.includes('.') || id.includes('-') || /\/[a-zA-Z0-9]+[a-zA-Z]/.test(id))) {
          return 'bud';
        }
        
        // Check for fruit pattern
        if (/\/[A-Z]$/.test(id)) {
          return 'fruit';
        }
        
        // Check for flower pattern
        if (/\/\d+$/.test(id)) {
          return 'flower';
        }
        
        // Check for leaf pattern
        if (/^\d{4}$/.test(id) && !id.endsWith('00')) {
          return 'leaf';
        }
        
        // Check for branch pattern
        if (/^\d{4}$/.test(id) && id.endsWith('00') && parseInt(id) % 1000 !== 0) {
          return 'branch';
        }
        
        // Check for trunk pattern
        if (/^\d+000$/.test(id)) {
          return 'trunk';
        }
        
        // Default
        return 'leaf';
      }
      
      function hierarchicalKey(id) {
        return id
          .split(/[/\-\.]/)
          .map(seg => {
            const m = seg.match(/^(\d+)([A-Za-z]*)$/);
            return m
              ? [parseInt(m[1], 10), m[2]]
              : [Number.POSITIVE_INFINITY, seg];
          });
      }
      
      function extractHashtags(content) {
        if (!content) return [];
        
        const hashtagRegex = /#[a-zA-Z0-9_]+/g;
        const matches = content.match(hashtagRegex);
        
        return matches ? [...new Set(matches.map(tag => tag.toLowerCase()))] : [];
      }
      
      function parseHashtags(input) {
        if (!input) return [];
        
        const tags = input.split(/\s+/).map(tag => {
          tag = tag.trim();
          return tag.startsWith('#') ? tag.toLowerCase() : '#' + tag.toLowerCase();
        });
        
        return [...new Set(tags.filter(tag => tag.length > 1))];
      }
      
      // --- Hashtag Manager Functions ---
      function addGlobalHashtag(tag) {
        if (!tag) return;
        
        // Make sure it starts with #
        tag = tag.startsWith('#') ? tag.toLowerCase() : '#' + tag.toLowerCase();
        
        // Only add if it doesn't already exist
        if (!globalHashtags.includes(tag)) {
          globalHashtags.push(tag);
          saveGlobalHashtags();
          renderHashtagsList();
        }
      }
      
      function removeGlobalHashtag(tag) {
        const index = globalHashtags.indexOf(tag);
        if (index !== -1) {
          globalHashtags.splice(index, 1);
          saveGlobalHashtags();
          renderHashtagsList();
        }
      }
      
      // --- Storage Functions ---
      function saveCardsToStorage() {
        try {
          localStorage.setItem('multiZettelkasten', JSON.stringify(cards));
        } catch (e) {
          console.error('Failed to save cards to storage:', e);
        }
      }
      
      function loadCardsFromStorage() {
        try {
          const storedCards = localStorage.getItem('multiZettelkasten');
          if (storedCards) {
            cards = JSON.parse(storedCards).map(cardData => new Card(cardData));
            return true;
          }
        } catch (e) {
          console.error('Failed to load cards from storage:', e);
        }
        
        return false;
      }
      
      function saveFavoritesToStorage() {
        try {
          localStorage.setItem('multiZettelkasten_favorites', JSON.stringify(favoriteCards));
        } catch (e) {
          console.error('Failed to save favorites to storage:', e);
        }
      }
      
      function loadFavoritesFromStorage() {
        try {
          const storedFavorites = localStorage.getItem('multiZettelkasten_favorites');
          if (storedFavorites) {
            favoriteCards = JSON.parse(storedFavorites);
            return true;
          }
        } catch (e) {
          console.error('Failed to load favorites from storage:', e);
        }
        
        return false;
      }
      
      function saveGlobalHashtags() {
        try {
          localStorage.setItem('multiZettelkasten_hashtags', JSON.stringify(globalHashtags));
        } catch (e) {
          console.error('Failed to save global hashtags:', e);
        }
      }
      
      function loadGlobalHashtags() {
        try {
          const storedHashtags = localStorage.getItem('multiZettelkasten_hashtags');
          if (storedHashtags) {
            globalHashtags = JSON.parse(storedHashtags);
            return true;
          }
        } catch (e) {
          console.error('Failed to load global hashtags:', e);
        }
        
        return false;
      }
      
      // --- Helper functions to extract parent IDs for hierarchy relationships ---
      function getTrunkId(id) {
        // Extract the first 1000-level number (e.g. 1000, 2000, etc.)
        const match = id.toString().match(/^(\d+)000/);
        if (match) {
          return match[0];
        }
        // For non-standard IDs or branches that aren't exact multiples of 1000
        const num = parseInt(id.toString());
        if (num >= 1000) {
          const trunkBase = Math.floor(num / 1000) * 1000;
          return trunkBase.toString();
        }
        return null;
      }
      
      function getBranchId(id) {
        // For standard IDs like 1100, 1200, etc.
        const match = id.toString().match(/^(\d+00)/);
        if (match) {
          return match[0];
        }
        // For non-standard branch IDs
        return null;
      }
      
      function getLeafId(id) {
        // For standard leaf IDs like 1101, 1102, etc. (not ending in 00)
        // Leaf IDs are 4 digits
        const match = id.toString().match(/^(\d{4})(?!\/)(?!00$)/);
        if (match) {
          return match[0];
        }
        return null;
      }
      
      function getFlowerId(id) {
        // For flower IDs like 1101/1, 1102/2, etc.
        const match = id.toString().match(/^(\d{4}\/\d+)/);
        if (match) {
          return match[0];
        }
        return null;
      }
      
      // --- UI Rendering Functions ---
      function renderZettelList(searchResults = null) {
        const container = document.getElementById('zettelContainer');
        container.innerHTML = '';
        
        let cardsToRender = searchResults || [...cards];
        
        // Apply view-specific filters
        switch(currentView) {
          case 'traditional':
            // Apply type filter if one is selected
            if (currentHierarchyFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.type === currentHierarchyFilter);
            }
            container.classList.add('hierarchy-view');
            renderTraditionalView(cardsToRender, container);
            break;
            
          case 'kingdoms':
            // Apply kingdom filter if one is selected
            if (currentKingdomFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.kingdom === currentKingdomFilter);
            }
            container.classList.remove('hierarchy-view');
            renderKingdomView(cardsToRender, container);
            break;
            
          case 'philosophical':
            // Apply tier filters if any are selected
            if (currentTierIFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.tierI === currentTierIFilter);
            }
            if (currentTierIIFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.tierII && card.tierII.includes(currentTierIIFilter));
            }
            container.classList.remove('hierarchy-view');
            renderPhilosophicalView(cardsToRender, container);
            break;
            
          case 'codex':
            // Apply codex filter if one is selected
            if (currentCodexFilter !== 'all') {
              cardsToRender = cardsToRender.filter(card => card.codexType === currentCodexFilter);
            }
            container.classList.remove('hierarchy-view');
            renderCodexView(cardsToRender, container);
            break;
            
          case 'emergent':
            // Only show emergent cards
            cardsToRender = cardsToRender.filter(card => card.emergent === true);
            container.classList.remove('hierarchy-view');
            renderEmergentView(cardsToRender, container);
            break;
            
          case 'search':
            container.classList.remove('hierarchy-view');
            renderSearchView(cardsToRender, container);
            break;
        }
      }
      
      function renderTraditionalView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        // Sort cards by hierarchy
        sortCardsByHierarchy(cardsToRender);
        
        // For hierarchical view, create parent-child relationships
        if (currentHierarchyFilter === 'all') {
          const fragment = document.createDocumentFragment();
          
          // Get all trunk cards
          const trunkCards = cardsToRender.filter(card => card.type === 'trunk');
          
          // Group by trunk
          trunkCards.forEach(trunk => {
            // Create trunk divider
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = `<span>${trunk.id}: ${trunk.title}</span>`;
            fragment.appendChild(divider);
            
            // Create trunk card
            const trunkElement = createCardElement(trunk);
            fragment.appendChild(trunkElement);
            
            // Find branches under this trunk
            const branches = cardsToRender.filter(card => 
              card.type === 'branch' && 
              getTrunkId(card.id) === trunk.id
            );
            
            // Add branches
            branches.forEach(branch => {
              const branchElement = createCardElement(branch, 1);
              fragment.appendChild(branchElement);
              
              // Find leaves under this branch
              const leaves = cardsToRender.filter(card => 
                card.type === 'leaf' && 
                getBranchId(card.id) === branch.id
              );
              
              // Add leaves
              leaves.forEach(leaf => {
                const leafElement = createCardElement(leaf, 2);
                fragment.appendChild(leafElement);
                
                // Find flowers under this leaf
                const flowers = cardsToRender.filter(card => 
                  card.type === 'flower' && 
                  getLeafId(card.id) === leaf.id
                );
                
                // Add flowers
                flowers.forEach(flower => {
                  const flowerElement = createCardElement(flower, 3);
                  fragment.appendChild(flowerElement);
                  
                  // Find fruits under this flower
                  const fruits = cardsToRender.filter(card => 
                    card.type === 'fruit' && 
                    getFlowerId(card.id) === flower.id
                  );
                  
                  // Add fruits
                  fruits.forEach(fruit => {
                    const fruitElement = createCardElement(fruit, 4);
                    fragment.appendChild(fruitElement);
                    
                    // Find buds under this fruit
                    const buds = cardsToRender.filter(card => 
                      card.type === 'bud' && 
                      card.id.startsWith(fruit.id + '/')
                    );
                    
                    // Add buds
                    buds.forEach(bud => {
                      const budElement = createCardElement(bud, 5);
                      fragment.appendChild(budElement);
                    });
                  });
                });
              });
            });
          });
          
          // Now add any solo cards that don't fit in hierarchy
          const soloCards = cardsToRender.filter(card => {
            if (card.type === 'trunk') return false;
            
            if (card.type === 'branch') {
              return !trunkCards.some(trunk => getTrunkId(card.id) === trunk.id);
            }
            
            // Remaining solo cards
            return true;
          });
          
          if (soloCards.length > 0) {
            // Create divider for unconnected cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Other Tablets</span>';
            fragment.appendChild(divider);
            
            // Add each solo card
            soloCards.forEach(card => {
              const cardElement = createCardElement(card);
              fragment.appendChild(cardElement);
            });
          }
          
          // Add emergent cards at the end
          const emergentCards = cardsToRender.filter(card => card.emergent);
          if (emergentCards.length > 0) {
            // Create divider for emergent cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider emergent-divider';
            divider.innerHTML = '<span>&#10023; Emergent Tablets &#10023;</span>';
            fragment.appendChild(divider);
            
            // Add each emergent card
            emergentCards.forEach(card => {
              const cardElement = createCardElement(card, 0, true);
              fragment.appendChild(cardElement);
            });
          }
          
          container.appendChild(fragment);
        } else {
          // Just show cards of the selected type
          const fragment = document.createDocumentFragment();
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card);
            fragment.appendChild(cardElement);
          });
          
          container.appendChild(fragment);
        }
      }
      
      function renderKingdomView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // If showing all kingdoms, group by kingdom
        if (currentKingdomFilter === 'all') {
          // Define kingdoms in order
          const kingdoms = [
            'existentia', 'cognitio', 'actus', 
            'valor', 'systema', 'significatio'
          ];
          
          // Create sections for each kingdom
          kingdoms.forEach(kingdom => {
            const kingdomCards = cardsToRender.filter(card => card.kingdom === kingdom);
            
            if (kingdomCards.length > 0) {
              // Create kingdom divider
              const divider = document.createElement('div');
              divider.className = 'hierarchy-divider';
              divider.style.background = `linear-gradient(to right, var(--kingdom-${kingdom}), #444)`;
              
              // Get kingdom emoji
              let emoji = '';
              switch (kingdom) {
                case 'existentia': emoji = '&#127756;'; break;
                case 'cognitio': emoji = '&#128161;'; break;
                case 'actus': emoji = '&#128640;'; break;
                case 'valor': emoji = '&#9878;&#65039;'; break;
                case 'systema': emoji = '&#9881;&#65039;'; break;
                case 'significatio': emoji = '&#128172;'; break;
              }
              
              divider.innerHTML = `<span>${emoji} ${kingdom.charAt(0).toUpperCase() + kingdom.slice(1)}</span>`;
              fragment.appendChild(divider);
              
              // Sort cards by ID
              kingdomCards.sort((a, b) => a.id.localeCompare(b.id));
              
              // Add cards for this kingdom
              kingdomCards.forEach(card => {
                const cardElement = createCardElement(card, 0, card.emergent, `kingdom-${kingdom}`);
                fragment.appendChild(cardElement);
              });
            }
          });
          
          // Add unclassified cards at the end
          const unclassifiedCards = cardsToRender.filter(card => !card.kingdom);
          
          if (unclassifiedCards.length > 0) {
            // Create divider for unclassified cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Unclassified Tablets</span>';
            fragment.appendChild(divider);
            
            // Sort cards by ID
            unclassifiedCards.sort((a, b) => a.id.localeCompare(b.id));
            
            // Add unclassified cards
            unclassifiedCards.forEach(card => {
              const cardElement = createCardElement(card, 0, card.emergent);
              fragment.appendChild(cardElement);
            });
          }
        } else {
          // Just show cards of the selected kingdom
          cardsToRender.sort((a, b) => a.id.localeCompare(b.id));
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card, 0, card.emergent, `kingdom-${card.kingdom}`);
            fragment.appendChild(cardElement);
          });
        }
        
        container.appendChild(fragment);
      }
      
      function renderPhilosophicalView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // If showing all tiers, group by Tier I
        if (currentTierIFilter === 'all' && currentTierIIFilter === 'all') {
          // Define Tier I frames
          const tierIFrames = [
            'ONT', 'EPI', 'AXI', 'TAX', 'TEL', 'PRX', 'MTH', 'LOG'
          ];
          
          // Create sections for each Tier I frame
          tierIFrames.forEach(tierI => {
            const tierCards = cardsToRender.filter(card => card.tierI === tierI);
            
            if (tierCards.length > 0) {
              // Create tier divider
              const divider = document.createElement('div');
              divider.className = 'hierarchy-divider';
              
              // Get tier description
              let description = '';
              switch (tierI) {
                case 'ONT': description = 'Ontology'; break;
                case 'EPI': description = 'Epistemology'; break;
                case 'AXI': description = 'Axiology'; break;
                case 'TAX': description = 'Taxonomy'; break;
                case 'TEL': description = 'Teleology'; break;
                case 'PRX': description = 'Praxis'; break;
                case 'MTH': description = 'Methodology'; break;
                case 'LOG': description = 'Logic'; break;
              }
              
              divider.innerHTML = `<span>${tierI} - ${description}</span>`;
              fragment.appendChild(divider);
              
              // Sort cards by ID
              tierCards.sort((a, b) => a.id.localeCompare(b.id));
              
              // Add cards for this tier
              tierCards.forEach(card => {
                const cardElement = createCardElement(card, 0, card.emergent);
                fragment.appendChild(cardElement);
              });
            }
          });
          
          // Add unclassified cards at the end
          const unclassifiedCards = cardsToRender.filter(card => !card.tierI);
          
          if (unclassifiedCards.length > 0) {
            // Create divider for unclassified cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Unclassified Tablets</span>';
            fragment.appendChild(divider);
            
            // Sort cards by ID
            unclassifiedCards.sort((a, b) => a.id.localeCompare(b.id));
            
            // Add unclassified cards
            unclassifiedCards.forEach(card => {
              const cardElement = createCardElement(card, 0, card.emergent);
              fragment.appendChild(cardElement);
            });
          }
        } else {
          // Just show cards of the selected tiers
          cardsToRender.sort((a, b) => a.id.localeCompare(b.id));
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card, 0, card.emergent);
            fragment.appendChild(cardElement);
          });
        }
        
        container.appendChild(fragment);
      }
      
      function renderCodexView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          renderEmptyState(container);
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // If showing all codices, group by codex type
        if (currentCodexFilter === 'all') {
          // Define codex types
          const codexTypes = ['CG', 'TS', 'PAPS', 'COAI'];
          
          // Create sections for each codex type
          codexTypes.forEach(codexType => {
            const codexCards = cardsToRender.filter(card => card.codexType === codexType);
            
            if (codexCards.length > 0) {
              // Create codex divider
              const divider = document.createElement('div');
              divider.className = 'hierarchy-divider';
              divider.style.background = `linear-gradient(to right, var(--codex-${codexType.toLowerCase()}), #444)`;
              
              // Get codex description
              let description = '';
              switch (codexType) {
                case 'CG': description = 'Chaos Grimoire'; break;
                case 'TS': description = 'Thought Sigils'; break;
                case 'PAPS': description = 'PAPS Diagnostics'; break;
                case 'COAI': description = 'COAI Oracle'; break;
              }
              
              divider.innerHTML = `<span>${codexType} - ${description}</span>`;
              fragment.appendChild(divider);
              
              // Sort cards by codex ID
              codexCards.sort((a, b) => a.codexId.localeCompare(b.codexId));
              
              // Add cards for this codex
              codexCards.forEach(card => {
                const cardElement = createCardElement(card, 0, card.emergent, `codex-${codexType.toLowerCase()}`);
                fragment.appendChild(cardElement);
              });
            }
          });
          
          // Add standard (non-codex) cards at the end
          const standardCards = cardsToRender.filter(card => !card.codexType);
          
          if (standardCards.length > 0) {
            // Create divider for standard cards
            const divider = document.createElement('div');
            divider.className = 'hierarchy-divider';
            divider.innerHTML = '<span>Standard Tablets</span>';
            fragment.appendChild(divider);
            
            // Sort cards by ID
            standardCards.sort((a, b) => a.id.localeCompare(b.id));
            
            // Add standard cards
            standardCards.forEach(card => {
              const cardElement = createCardElement(card, 0, card.emergent);
              fragment.appendChild(cardElement);
            });
          }
        } else {
          // Just show cards of the selected codex
          cardsToRender.sort((a, b) => a.codexId.localeCompare(b.codexId));
          
          cardsToRender.forEach(card => {
            const cardElement = createCardElement(card, 0, card.emergent, `codex-${card.codexType.toLowerCase()}`);
            fragment.appendChild(cardElement);
          });
        }
        
        container.appendChild(fragment);
      }
      
      function renderEmergentView(cardsToRender, container) {
        if (cardsToRender.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
              <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
              <p>No emergent tablets found.</p>
              <p style="margin-top: 10px;">Create an emergent tablet by selecting "Emergent Tablet" when creating a new tablet.</p>
              <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
            </div>
          `;
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // Sort emergent cards by creation date (newest first)
        cardsToRender.sort((a, b) => b.created - a.created);
        
        cardsToRender.forEach(card => {
          const cardElement = createCardElement(card, 0, true);
          fragment.appendChild(cardElement);
        });
        
        container.appendChild(fragment);
      }
      
      function renderSearchView(cardsToRender, container) {
        const searchQuery = document.getElementById('searchInput').value.trim();
        
        if (!searchQuery) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
              <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
              <p>Enter a search term to find tablets.</p>
              <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
            </div>
          `;
          return;
        }
        
        // Filter cards by search term
        const matchedCards = cardsToRender.filter(card => {
          const searchLower = searchQuery.toLowerCase();
          return (
            card.title.toLowerCase().includes(searchLower) ||
            card.content.toLowerCase().includes(searchLower) ||
            card.id.toLowerCase().includes(searchLower) ||
            card.hashtags.some(tag => tag.toLowerCase().includes(searchLower)) ||
            (card.tierI && card.tierI.toLowerCase().includes(searchLower)) ||
            (card.tierII && card.tierII.some(tier => tier.toLowerCase().includes(searchLower))) ||
            (card.kingdom && card.kingdom.toLowerCase().includes(searchLower)) ||
            (card.codexType && card.codexType.toLowerCase().includes(searchLower))
          );
        });
        
        if (matchedCards.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
              <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
              <p>No tablets found matching "${searchQuery}"</p>
              <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
            </div>
          `;
          return;
        }
        
        const fragment = document.createDocumentFragment();
        
        // Show search result count
        const resultCount = document.createElement('div');
        resultCount.style.marginBottom = '10px';
        resultCount.style.color = '#666';
        resultCount.style.fontSize = '12px';
        resultCount.textContent = `Found ${matchedCards.length} tablet${matchedCards.length !== 1 ? 's' : ''} matching "${searchQuery}"`;
        fragment.appendChild(resultCount);
        
        // Sort by relevance (title matches first, then ID, then content)
        matchedCards.sort((a, b) => {
          const searchLower = searchQuery.toLowerCase();
          
          // Title matches are highest priority
          const aTitleMatch = a.title.toLowerCase().includes(searchLower);
          const bTitleMatch = b.title.toLowerCase().includes(searchLower);
          
          if (aTitleMatch && !bTitleMatch) return -1;
          if (!aTitleMatch && bTitleMatch) return 1;
          
          // ID matches are next priority
          const aIdMatch = a.id.toLowerCase().includes(searchLower);
          const bIdMatch = b.id.toLowerCase().includes(searchLower);
          
          if (aIdMatch && !bIdMatch) return -1;
          if (!aIdMatch && bIdMatch) return 1;
          
          // Content matches are last priority
          const aContentMatch = a.content.toLowerCase().includes(searchLower);
          const bContentMatch = b.content.toLowerCase().includes(searchLower);
          
          if (aContentMatch && !bContentMatch) return -1;
          if (!aContentMatch && bContentMatch) return 1;
          
          // If all else is equal, sort by modification date (newest first)
          return b.modified - a.modified;
        });
        
        // Add matched cards to fragment
        matchedCards.forEach(card => {
          const cardElement = createCardElement(card, 0, card.emergent);
          fragment.appendChild(cardElement);
        });
        
        container.appendChild(fragment);
      }
      
      function renderEmptyState(container) {
        container.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #888;">
            <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
            <p>No tablets found with current filter.</p>
            <p style="margin-top: 10px;">Create a new tablet or change your filter.</p>
            <p style="font-size: 18px;">&#10023;&#65381;&#65439;: *&#10023;&#65381;&#65439;</p>
          </div>
        `;
      }
      
      function createCardElement(card, indentLevel = 0, isEmergent = false, additionalClass = '') {
        const cardElement = document.createElement('div');
        
        // Base classes
        let classes = 'zettel-card';
        
        // Add type-specific class
        classes += ` ${card.type}-card`;
        
        // Add additional class if provided
        if (additionalClass) {
          classes += ` ${additionalClass}`;
        }
        
        // Add emergent class if applicable
        if (isEmergent || card.emergent) {
          classes += ' emergent-card';
        }
        
        // Add indent class if needed
        if (indentLevel > 0) {
          classes += ` indent-level-${indentLevel}`;
        }
        
        cardElement.className = classes;
        
        // Check if this is a favorite card
        const isFavorite = favoriteCards.includes(card.id);
        const favoriteMarker = isFavorite ? 
          `<span style="color: #ffcc00; margin-left: 5px;">&#9733;</span>` : '';
        
        // Emergent marker
        const emergentMarker = (isEmergent || card.emergent) ? 
          `<span style="color: var(--hyena-yellow); margin-left: 5px;">&#10023;</span>` : '';
        
        // Create badges based on classification systems
        let badges = '';
        
        // Add kingdom badge if available
        if (card.kingdom) {
          const kingdomIcon = getKingdomIcon(card.kingdom);
          badges += `<span class="badge kingdom-badge kingdom-badge-${card.kingdom}">${kingdomIcon} ${card.kingdom}</span>`;
        }
        
        // Add planet badge if available
        if (card.planet) {
          badges += `<span class="planet-icon planet-${card.planet.toLowerCase()}">${card.planet}</span>`;
        }
        
        // Add tier badges if available
        if (card.tierI) {
          badges += `<span class="badge tier-badge">${card.tierI}</span>`;
        }
        
        if (card.tierII && card.tierII.length > 0) {
          card.tierII.forEach(tier => {
            badges += `<span class="badge tier-badge">${tier}</span>`;
          });
        }
        
        // Add codex badge if available
        if (card.codexType && card.codexId) {
          badges += `<span class="badge codex-badge codex-badge-${card.codexType.toLowerCase()}">${card.codexType}-${card.codexId}</span>`;
        }
        
        // Build card HTML
        cardElement.innerHTML = `
          <div style="display: flex; justify-content: space-between;">
            <div class="zettel-title">${card.title} ${favoriteMarker} ${emergentMarker}</div>
            <div class="zettel-id">${card.id}</div>
          </div>
          ${badges ? `<div style="margin-top: 5px; display: flex; flex-wrap: wrap; gap: 3px;">${badges}</div>` : ''}
        `;
        
        // Add click handler
        cardElement.addEventListener('click', () => {
          showZettelDialog(card.id);
        });
        
        return cardElement;
      }
      
      function getKingdomIcon(kingdom) {
        switch(kingdom) {
          case 'existentia': return '&#127756;';
          case 'cognitio': return '&#128161;';
          case 'actus': return '&#128640;';
          case 'valor': return '&#9878;&#65039;';
          case 'systema': return '&#9881;&#65039;';
          case 'significatio': return '&#128172;';
          default: return '';
        }
      }
      
      function getTierDescription(tier) {
        // Tier I descriptions
        const tierIDesc = {
          'ONT': 'Ontology',
          'EPI': 'Epistemology',
          'AXI': 'Axiology',
          'TAX': 'Taxonomy',
          'TEL': 'Teleology',
          'PRX': 'Praxis',
          'MTH': 'Methodology',
          'LOG': 'Logic'
        };
        
        // Tier II descriptions
        const tierIIDesc = {
          'MYT': 'Mythological',
          'SYM': 'Symbolic',
          'RIT': 'Ritual',
          'PSY': 'Psychological',
          'HST': 'Historical',
          'ANA': 'Analytical',
          'DES': 'Descriptive'
        };
        
        // Tier III descriptions
        const tierIIIDesc = {
          'DAE': 'Daemonic',
          'OCC': 'Occult',
          'PAR': 'Paradoxical',
          'LUM': 'Liminal'
        };
        
        // Check each tier map
        if (tierIDesc[tier]) return tierIDesc[tier];
        if (tierIIDesc[tier]) return tierIIDesc[tier];
        if (tierIIIDesc[tier]) return tierIIIDesc[tier];
        
        return tier;
      }
      
      function renderFavorites() {
        const container = document.getElementById('favoritesContainer');
        container.innerHTML = '';
        
        // Get the top 8 favorite cards
        const displayFavorites = favoriteCards.slice(0, 8);
        
        // Create empty slots if we have fewer than 8 favorites
        while (displayFavorites.length < 8) {
          displayFavorites.push(null);
        }
        
        displayFavorites.forEach(cardId => {
          const card = cardId ? cards.find(c => c.id === cardId) : null;
          
          const favDiv = document.createElement('div');
          favDiv.style.backgroundColor = 'white';
          favDiv.style.border = '1px solid #ccc';
          favDiv.style.padding = '10px';
          favDiv.style.textAlign = 'center';
          favDiv.style.cursor = card ? 'pointer' : 'default';
          
          if (card) {
            // Get icon based on card type and classification
            let icon = '';
            
            if (currentView === 'traditional') {
              icon = {
                'trunk': '&#127795;',
                'branch': '&#127807;',
                'leaf': '&#127811;',
                'flower': '&#127800;',
                'fruit': '&#127822;',
                'bud': '&#10024;'
              }[card.type] || '&#128221;';
            } else if (currentView === 'kingdoms' && card.kingdom) {
              icon = getKingdomIcon(card.kingdom);
            } else if (card.codexType) {
              icon = {
                'CG': '&#128302;',
                'TS': '&#128269;',
                'PAPS': '&#129514;',
                'COAI': '&#127924;'
              }[card.codexType] || '&#128221;';
            }
            
            favDiv.innerHTML = `
              <div style="font-size: 28px; margin-bottom: 5px;">${icon}</div>
              <div style="font-weight: bold; font-size: 12px; margin-bottom: 2px;">${card.title}</div>
              <div style="color: #777; font-size: 10px; font-family: 'VT323', monospace;">${card.id}</div>
            `;
            
            favDiv.addEventListener('click', () => {
              showZettelDialog(card.id);
            });
          } else {
            favDiv.style.borderStyle = 'dashed';
            favDiv.style.color = '#999';
            
            favDiv.innerHTML = `
              <div style="font-size: 28px; margin-bottom: 5px;">+</div>
              <div style="font-size: 12px;">Empty Slot</div>
            `;
          }
          
          container.appendChild(favDiv);
        });
      }
      
      function renderHashtagsList() {
        const container = document.getElementById('hashtagManagerList');
        container.innerHTML = '';
        
        if (globalHashtags.length === 0) {
          container.innerHTML = '<div style="color: #777; font-style: italic;">No hashtags created yet.</div>';
          return;
        }
        
        globalHashtags.forEach(tag => {
          const tagItem = document.createElement('div');
          tagItem.className = 'dialog-hashtag';
          tagItem.style.display = 'flex';
          tagItem.style.alignItems = 'center';
          
          tagItem.innerHTML = `
            ${tag}
            <span style="margin-left: 5px; background-color: var(--hyena-pink); color: white; width: 16px; height: 16px; 
                         display: inline-flex; align-items: center; justify-content: center; 
                         border-radius: 50%; font-weight: bold; cursor: pointer; font-size: 10px;">×</span>
          `;
          
          // Delete button handler
          const deleteBtn = tagItem.querySelector('span');
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeGlobalHashtag(tag);
          });
          
          container.appendChild(tagItem);
        });
      }
      
      // --- View/Edit Dialog Functions ---
      function showZettelDialog(cardId) {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        
        // Get the dialog elements
        const dialog = document.getElementById('zettelDialog');
        const titleElement = document.getElementById('zettelDialogTitle');
        const contentElement = document.getElementById('zettelDialogContent');
        
        // Set title based on current view
        if (currentView === 'traditional') {
          titleElement.textContent = card.emergent ? 'Emergent Tablet' : 
                                  card.type.charAt(0).toUpperCase() + card.type.slice(1) + ' Tablet';
        } else if (currentView === 'kingdoms' && card.kingdom) {
          titleElement.textContent = `${getKingdomIcon(card.kingdom)} ${card.kingdom.charAt(0).toUpperCase() + card.kingdom.slice(1)} Tablet`;
        } else if (currentView === 'philosophical' && card.tierI) {
          titleElement.textContent = `${card.tierI} Tablet`;
        } else if (currentView === 'codex' && card.codexType) {
          titleElement.textContent = `${card.codexType} Codex Tablet`;
        } else {
          titleElement.textContent = 'Tablet Details';
        }
        
        // Prepare badges HTML
        let badgesHtml = '';
        
        // Add kingdom badge if available
        if (card.kingdom) {
          const kingdomIcon = getKingdomIcon(card.kingdom);
          badgesHtml += `<span class="badge kingdom-badge kingdom-badge-${card.kingdom} mr-1">${kingdomIcon} ${card.kingdom}</span>`;
        }
        
        // Add planet badge if available
        if (card.planet) {
          badgesHtml += `<span class="planet-icon planet-${card.planet.toLowerCase()} mr-1">${card.planet}</span>`;
        }
        
        // Add tier badges if available
        if (card.tierI) {
          badgesHtml += `<span class="badge tier-badge mr-1">${card.tierI}</span>`;
        }
        
        if (card.tierII && card.tierII.length > 0) {
          card.tierII.forEach(tier => {
            badgesHtml += `<span class="badge tier-badge mr-1">${tier}</span>`;
          });
        }
        
        if (card.tierIII && card.tierIII.length > 0) {
          card.tierIII.forEach(tier => {
            badgesHtml += `<span class="badge tier-badge mr-1">${tier}</span>`;
          });
        }
        
        // Add codex badge if available
        if (card.codexType && card.codexId) {
          badgesHtml += `<span class="badge codex-badge codex-badge-${card.codexType.toLowerCase()} mr-1">${card.codexType}-${card.codexId}</span>`;
        }
        
        // Prepare hashtags HTML
        const hashtagsHtml = card.hashtags.length > 0 ? 
          `<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 15px;">
            ${card.hashtags.map(tag => `<span class="dialog-hashtag">${tag}</span>`).join('')}
          </div>` : '';
        
        // Prepare links HTML
        const linksHtml = card.links.length > 0 ?
          `<div style="margin-top: 15px; border-top: 1px dashed var(--hyena-teal); padding-top: 10px;">
            <div style="font-weight: bold; margin-bottom: 5px;">Linked Tablets:</div>
            <div style="display: flex; flex-direction: column; gap: 3px;">
              ${card.links.map(link => {
                const linkedCard = cards.find(c => c.id === link);
                return linkedCard ? 
                  `<div data-id="${linkedCard.id}" style="color: var(--hyena-purple); cursor: pointer;">${linkedCard.title} (${linkedCard.id})</div>` : 
                  `<div style="color: #777;">Unknown tablet (${link})</div>`;
              }).join('')}
            </div>
          </div>` : '';
        
        // Set content
        contentElement.innerHTML = `
          <div class="dialog-title">${card.title}</div>
          <div class="dialog-id">${card.id}</div>
          
          ${badgesHtml ? `<div style="display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 10px;">${badgesHtml}</div>` : ''}
          
          <div class="dialog-content-text">
            ${card.content || '<em style="color: #777;">No content</em>'}
          </div>
          
          <div style="background-color: #f0f0f0; padding: 10px; margin-bottom: 10px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
              <div>
                <strong>Type:</strong> ${card.type}
              </div>
              <div>
                <strong>Status:</strong> ${card.emergent ? 'Emergent' : 'Classified'}
              </div>
              <div>
                <strong>Created:</strong> ${new Date(card.created).toLocaleString()}
              </div>
              <div>
                <strong>Modified:</strong> ${new Date(card.modified).toLocaleString()}
              </div>
            </div>
          </div>
          
          ${hashtagsHtml}
          ${linksHtml}
          
          <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 20px;">
            <button id="editCardBtn" class="win98-button">&#9999;&#65039; Edit</button>
            <button id="toggleEmergentBtn" class="win98-button">
              ${card.emergent ? '&#128203; Convert to Classified' : '&#10023; Mark as Emergent'}
            </button>
            <button id="favoriteBtn" class="win98-button" style="${favoriteCards.includes(card.id) ? 'display: none;' : ''}">
              &#11088; Add to Favorites
            </button>
            <button id="unfavoriteBtn" class="win98-button" style="${!favoriteCards.includes(card.id) ? 'display: none;' : ''}">
              &#10006;&#65039; Remove from Favorites
            </button>
            <button id="deleteCardBtn" class="win98-button" style="background-color: #ff4444; color: white;">
              &#128465;&#65039; Delete
            </button>
          </div>
        `;
        
        // Show the dialog
        dialog.style.display = 'flex';
        
        // Add link click handlers
        const linkElements = contentElement.querySelectorAll('[data-id]');
        linkElements.forEach(link => {
          link.addEventListener('click', () => {
            showZettelDialog(link.getAttribute('data-id'));
          });
        });
        
        // Edit button handler
        document.getElementById('editCardBtn').addEventListener('click', () => {
          showEditCardDialog(card.id);
          dialog.style.display = 'none';
        });
        
        // Toggle emergent status button
        document.getElementById('toggleEmergentBtn').addEventListener('click', () => {
          const index = cards.findIndex(c => c.id === card.id);
          if (index !== -1) {
            // Toggle emergent status
            cards[index].emergent = !cards[index].emergent;
            cards[index].modified = Date.now();
            
            // Generate a new ID if converting to emergent and the ID is not already emergent-style
            if (cards[index].emergent && !cards[index].id.startsWith('e-')) {
              const oldId = cards[index].id;
              const newId = 'e-' + Date.now().toString();
              
              // Update ID
              cards[index].id = newId;
              
              // Update links in other cards
              cards.forEach(c => {
                const linkIndex = c.links.indexOf(oldId);
                if (linkIndex !== -1) {
                  c.links[linkIndex] = newId;
                }
              });
              
              // Update favorites if needed
              const favIndex = favoriteCards.indexOf(oldId);
              if (favIndex !== -1) {
                favoriteCards[favIndex] = newId;
                saveFavoritesToStorage();
              }
            }
            
            // Save and update UI
            saveCardsToStorage();
            renderZettelList();
            renderFavorites();
            
            // Close and reopen dialog with updated data
            dialog.style.display = 'none';
            showZettelDialog(cards[index].id);
          }
        });
        
        // Favorite button handler
        document.getElementById('favoriteBtn').addEventListener('click', () => {
          if (!favoriteCards.includes(card.id)) {
            // Add to favorites
            favoriteCards.push(card.id);
            
            // Limit to 8 favorites
            if (favoriteCards.length > 8) {
              favoriteCards = favoriteCards.slice(0, 8);
            }
            
            // Save and update UI
            saveFavoritesToStorage();
            renderFavorites();
            
            // Toggle button visibility
            document.getElementById('favoriteBtn').style.display = 'none';
            document.getElementById('unfavoriteBtn').style.display = 'inline-block';
          }
        });
        
        // Unfavorite button handler
        document.getElementById('unfavoriteBtn').addEventListener('click', () => {
          const index = favoriteCards.indexOf(card.id);
          if (index !== -1) {
            // Remove from favorites
            favoriteCards.splice(index, 1);
            
            // Save and update UI
            saveFavoritesToStorage();
            renderFavorites();
            
            // Toggle button visibility
            document.getElementById('favoriteBtn').style.display = 'inline-block';
            document.getElementById('unfavoriteBtn').style.display = 'none';
          }
        });
        
        // Delete button handler
        document.getElementById('deleteCardBtn').addEventListener('click', () => {
          if (confirm(`Are you sure you want to delete "${card.title}"? This cannot be undone.`)) {
            const index = cards.findIndex(c => c.id === card.id);
            if (index !== -1) {
              // Remove from cards array
              cards.splice(index, 1);
              
              // Remove from favorites if present
              const favIndex = favoriteCards.indexOf(card.id);
              if (favIndex !== -1) {
                favoriteCards.splice(favIndex, 1);
                saveFavoritesToStorage();
                renderFavorites();
              }
              
              // Save and update UI
              saveCardsToStorage();
              renderZettelList();
              
              // Close dialog
              dialog.style.display = 'none';
            }
          }
        });
        
        // Close button handler
        document.getElementById('zettelCloseBtn').addEventListener('click', () => {
          dialog.style.display = 'none';
        });
      }
      
      // --- New/Edit Card Dialog Functions ---
      // Show dialog to create a new card
      document.getElementById('newCardBtn').addEventListener('click', showNewCardDialog);
      
      function showNewCardDialog() {
        // Reset dialog
        document.querySelector('#newCardDialog .dialog-titlebar-text').textContent = 'Create New Tablet';
        document.querySelector('input[name="cardStatus"][value="classified"]').checked = true;
        
        // Clear form fields
        document.getElementById('newCardTitle').value = '';
        document.getElementById('newCardId').value = '';
        document.getElementById('newCardType').value = 'leaf';
        document.getElementById('newCardLinks').value = '';
        document.getElementById('newCardKingdom').value = '';
        document.getElementById('newCardPlanet').value = '';
        document.getElementById('newCardCodexType').value = '';
        document.getElementById('newCardCodexId').value = '';
        document.getElementById('newCardContent').value = '';
        document.getElementById('newCardHashtags').value = '';
        
        // Clear all selected tier options
        document.querySelectorAll('.tier-option').forEach(option => {
          option.classList.remove('selected');
        });
        
        // Show ID section (hidden for emergent cards)
        document.getElementById('idSection').style.display = 'block';
        
        // Update suggested hashtags
        updateSuggestedHashtags();
        
        // Update save button
        const saveBtn = document.getElementById('saveNewCardBtn');
        saveBtn.textContent = '&#128190; Save New Tablet';
        saveBtn.onclick = saveNewCard;
        
        // Show dialog
        document.getElementById('newCardDialog').style.display = 'flex';
      }
      
      function showEditCardDialog(cardId) {
        const card = cards.find(c => c.id === cardId);
        if (!card) return;
        
        // Set dialog title
        document.querySelector('#newCardDialog .dialog-titlebar-text').textContent = `Edit Tablet - ${card.title}`;
        
        // Set form fields
        document.querySelector(`input[name="cardStatus"][value="${card.emergent ? 'emergent' : 'classified'}"]`).checked = true;
        document.getElementById('newCardTitle').value = card.title;
        document.getElementById('newCardId').value = card.id;
        document.getElementById('newCardType').value = card.type;
        document.getElementById('newCardLinks').value = card.links.join(', ');
        document.getElementById('newCardKingdom').value = card.kingdom || '';
        document.getElementById('newCardPlanet').value = card.planet || '';
        document.getElementById('newCardCodexType').value = card.codexType || '';
        document.getElementById('newCardCodexId').value = card.codexId || '';
        document.getElementById('newCardContent').value = card.content || '';
        document.getElementById('newCardHashtags').value = card.hashtags.join(' ');
        
        // Show/hide ID section based on emergent status
        document.getElementById('idSection').style.display = card.emergent ? 'none' : 'block';
        
        // Clear all selected tier options
        document.querySelectorAll('.tier-option').forEach(option => {
          option.classList.remove('selected');
        });
        
        // Set Tier I option
        if (card.tierI) {
          const tierIOption = document.querySelector(`#tierIOptions .tier-option[data-tier="${card.tierI}"]`);
          if (tierIOption) tierIOption.classList.add('selected');
        }
        
        // Set Tier II options
        if (card.tierII && card.tierII.length > 0) {
          card.tierII.forEach(tier => {
            const tierIIOption = document.querySelector(`#tierIIOptions .tier-option[data-tier="${tier}"]`);
            if (tierIIOption) tierIIOption.classList.add('selected');
          });
        }
        
        // Set Tier III options
        if (card.tierIII && card.tierIII.length > 0) {
          card.tierIII.forEach(tier => {
            const tierIIIOption = document.querySelector(`#tierIIIOptions .tier-option[data-tier="${tier}"]`);
            if (tierIIIOption) tierIIIOption.classList.add('selected');
          });
        }
        
        // Update suggested hashtags
        updateSuggestedHashtags();
        
        // Update save button
        const saveBtn = document.getElementById('saveNewCardBtn');
        saveBtn.textContent = '&#128190; Save Changes';
        saveBtn.onclick = () => saveEditedCard(cardId);
        
        // Show dialog
        document.getElementById('newCardDialog').style.display = 'flex';
      }
      
      // Close the new card dialog
      document.getElementById('newCardCloseBtn').addEventListener('click', function() {
        document.getElementById('newCardDialog').style.display = 'none';
      });
      
      // Toggle ID section visibility based on card status
      document.querySelectorAll('input[name="cardStatus"]').forEach(radio => {
        radio.addEventListener('change', () => {
          const idSection = document.getElementById('idSection');
          idSection.style.display = radio.value === 'emergent' ? 'none' : 'block';
        });
      });
      
      // --- ID Generation Function ---
      document.getElementById('generateIdBtn').addEventListener('click', function() {
        const type = document.getElementById('newCardType').value;
        let newId;
        
        switch(type) {
          case 'trunk':
            // Find highest trunk ID and add 1000
            let highestTrunkId = 0;
            cards.forEach(card => {
              if (card.type === 'trunk') {
                const trunkId = parseInt(card.id.replace(/\D/g, ''));
                if (trunkId > highestTrunkId) {
                  highestTrunkId = trunkId;
                }
              }
            });
            newId = (highestTrunkId + 1000).toString();
            break;
            
          case 'branch':
            // Format: xxxx00 where xxxx is a trunk ID
            let trunkIds = cards.filter(card => card.type === 'trunk').map(card => card.id);
            if (trunkIds.length > 0) {
              const randomTrunk = trunkIds[Math.floor(Math.random() * trunkIds.length)];
              const trunkBase = randomTrunk.slice(0, -3);
              
              // Find highest branch in this trunk
              let highestBranch = 0;
              cards.forEach(card => {
                if (card.type === 'branch' && card.id.startsWith(trunkBase)) {
                  const branchNum = parseInt(card.id.slice(-3));
                  if (branchNum > highestBranch && branchNum < 1000) {
                    highestBranch = branchNum;
                  }
                }
              });
              
              // Next branch is highest + 100, or 100 if none exist
              const nextBranch = highestBranch === 0 ? 100 : (Math.floor(highestBranch / 100) + 1) * 100;
              newId = `${trunkBase}${nextBranch.toString().padStart(3, '0')}`;
            } else {
              newId = "1100"; // Default if no trunks
            }
            break;
            
          case 'leaf':
            // Format: xxxx where xxxx is not ending in 00
            // Randomly pick a number between 1001-9999 not ending in 00
            let leafId;
            do {
              leafId = Math.floor(Math.random() * 8999) + 1001;
              // Ensure it doesn't end in 00
              if (leafId % 100 === 0) leafId += 1;
            } while (cards.some(card => card.id === leafId.toString()));
            
            newId = leafId.toString();
            break;
            
          case 'flower':
            // Format: xxxx/y where xxxx is a leaf ID and y is a number
            let leafIds = cards.filter(card => card.type === 'leaf').map(card => card.id);
            if (leafIds.length > 0) {
              const randomLeaf = leafIds[Math.floor(Math.random() * leafIds.length)];
              newId = `${randomLeaf}/1`;
            } else {
              newId = "1001/1"; // Default if no leaves
            }
            break;
            
          case 'fruit':
            // Format: xxxx/y/A where xxxx/y is a flower ID and A is an uppercase letter
            let flowerIds = cards.filter(card => card.type === 'flower').map(card => card.id);
            if (flowerIds.length > 0) {
              const randomFlower = flowerIds[Math.floor(Math.random() * flowerIds.length)];
              newId = `${randomFlower}/A`;
            } else {
              newId = "1001/1/A"; // Default if no flowers
            }
            break;
            
          case 'bud':
            // Format: xxxx/y/z where xxxx/y is a flower ID and z is a number or letter
            let fruitIds = cards.filter(card => card.type === 'fruit').map(card => card.id);
            if (fruitIds.length > 0) {
              const randomFruit = fruitIds[Math.floor(Math.random() * fruitIds.length)];
              newId = `${randomFruit}/1`;
            } else {
              newId = "1001/1/1"; // Default if no fruits
            }
            break;
            
          default:
            newId = (Math.floor(Math.random() * 9000) + 1000).toString();
        }
        
        document.getElementById('newCardId').value = newId;
      });
      
      // Tier option selection
      document.querySelectorAll('.tier-option').forEach(option => {
        option.addEventListener('click', function() {
          const parent = this.parentElement.id;
          
          if (parent === 'tierIOptions') {
            // Tier I options are single-select
            document.querySelectorAll('#tierIOptions .tier-option').forEach(opt => {
              opt.classList.remove('selected');
            });
            this.classList.add('selected');
          } else {
            // Tier II and III options are multi-select
            this.classList.toggle('selected');
          }
        });
      });
      
      // Update suggested hashtags
      function updateSuggestedHashtags() {
        const suggestedContainer = document.getElementById('suggestedHashtags');
        suggestedContainer.innerHTML = '';
        
        if (globalHashtags.length === 0) {
          suggestedContainer.innerHTML = '<div style="color: #777; font-style: italic;">No hashtags available</div>';
          return;
        }
        
        // Show up to 10 hashtags
        globalHashtags.slice(0, 10).forEach(tag => {
          const tagSpan = document.createElement('span');
          tagSpan.className = 'dialog-hashtag';
          tagSpan.style.cursor = 'pointer';
          tagSpan.textContent = tag;
          
          tagSpan.addEventListener('click', () => {
            const hashtagInput = document.getElementById('newCardHashtags');
            const currentTags = hashtagInput.value.trim();
            
            if (!currentTags.includes(tag)) {
              hashtagInput.value = currentTags ? `${currentTags} ${tag}` : tag;
            }
          });
          
          suggestedContainer.appendChild(tagSpan);
        });
      }
      
      // --- Card Save Functions ---
      function saveNewCard() {
        // Get values from form
        const status = document.querySelector('input[name="cardStatus"]:checked').value;
        const isEmergent = status === 'emergent';
        
        const title = document.getElementById('newCardTitle').value.trim();
        let id = document.getElementById('newCardId').value.trim();
        const type = document.getElementById('newCardType').value;
        const linksInput = document.getElementById('newCardLinks').value.trim();
        
        const kingdom = document.getElementById('newCardKingdom').value;
        const planet = document.getElementById('newCardPlanet').value;
        
        // Get selected tier options
        const tierI = Array.from(document.querySelectorAll('#tierIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'))[0] || '';
          
        const tierII = Array.from(document.querySelectorAll('#tierIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
          
        const tierIII = Array.from(document.querySelectorAll('#tierIIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
        
        const codexType = document.getElementById('newCardCodexType').value;
        const codexId = document.getElementById('newCardCodexId').value.trim();
        
        const content = document.getElementById('newCardContent').value.trim();
        const hashtagsInput = document.getElementById('newCardHashtags').value.trim();
        
        // Validate required fields
        if (!title) {
          alert('Please enter a title for your tablet.');
          return;
        }
        
        if (!isEmergent && !id) {
          alert('Please enter an ID for your classified tablet.');
          return;
        }
        
        // For emergent cards, generate a temporary ID
        if (isEmergent) {
          id = 'e-' + Date.now().toString();
        }
        
        // Make sure ID doesn't already exist
        if (cards.some(card => card.id === id)) {
          alert('This ID already exists. Please choose a different ID.');
          return;
        }
        
        // Parse links
        const links = linksInput ? 
          linksInput.split(',').map(id => id.trim()).filter(id => id) : [];
          
        // Parse hashtags
        const hashtags = hashtagsInput ? 
          parseHashtags(hashtagsInput) : [];
          
        // Add any new hashtags to global list
        hashtags.forEach(tag => {
          if (!globalHashtags.includes(tag)) {
            globalHashtags.push(tag);
          }
        });
        saveGlobalHashtags();
        
        // Create new card object
        const newCard = new Card({
          id,
          title,
          type,
          content,
          hashtags,
          links,
          emergent: isEmergent,
          kingdom,
          planet,
          tierI,
          tierII,
          tierIII,
          codexType,
          codexId,
          created: Date.now(),
          modified: Date.now()
        });
        
        // Add to cards array
        cards.push(newCard);
        
        // If it's a trunk, add to favorites if we have space
        if (type === 'trunk' && favoriteCards.length < 8) {
          favoriteCards.push(id);
          saveFavoritesToStorage();
        }
        
        // Save to localStorage
        saveCardsToStorage();
        
        // Update UI
        renderZettelList();
        renderFavorites();
        renderHashtagsList();
        
        // Close dialog
        document.getElementById('newCardDialog').style.display = 'none';
      }
      
      function saveEditedCard(cardId) {
        // Find card index
        const cardIndex = cards.findIndex(card => card.id === cardId);
        if (cardIndex === -1) return;
        
        // Get values from form
        const status = document.querySelector('input[name="cardStatus"]:checked').value;
        const isEmergent = status === 'emergent';
        
        const title = document.getElementById('newCardTitle').value.trim();
        let id = document.getElementById('newCardId').value.trim();
        const type = document.getElementById('newCardType').value;
        const linksInput = document.getElementById('newCardLinks').value.trim();
        
        const kingdom = document.getElementById('newCardKingdom').value;
        const planet = document.getElementById('newCardPlanet').value;
        
        // Get selected tier options
        const tierI = Array.from(document.querySelectorAll('#tierIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'))[0] || '';
          
        const tierII = Array.from(document.querySelectorAll('#tierIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
          
        const tierIII = Array.from(document.querySelectorAll('#tierIIIOptions .tier-option.selected'))
          .map(opt => opt.getAttribute('data-tier'));
        
        const codexType = document.getElementById('newCardCodexType').value;
        const codexId = document.getElementById('newCardCodexId').value.trim();
        
        const content = document.getElementById('newCardContent').value.trim();
        const hashtagsInput = document.getElementById('newCardHashtags').value.trim();
        
        // Validate required fields
        if (!title) {
          alert('Please enter a title for your tablet.');
          return;
        }
        
        if (!isEmergent && !id) {
          alert('Please enter an ID for your classified tablet.');
          return;
        }
        
        // Handle ID change
        const oldId = cards[cardIndex].id;
        const idChanged = id !== oldId;
        
        // If ID changed, make sure new ID doesn't exist
        if (idChanged && cards.some(card => card.id === id && card.id !== oldId)) {
          alert('This ID already exists. Please choose a different ID.');
          return;
        }
        
        // Parse links
        const links = linksInput ? 
          linksInput.split(',').map(id => id.trim()).filter(id => id) : [];
          
        // Parse hashtags
        const hashtags = hashtagsInput ? 
          parseHashtags(hashtagsInput) : [];
          
        // Add any new hashtags to global list
        hashtags.forEach(tag => {
          if (!globalHashtags.includes(tag)) {
            globalHashtags.push(tag);
          }
        });
        saveGlobalHashtags();
        
        // Update card
        cards[cardIndex] = {
          ...cards[cardIndex],
          id,
          title,
          type,
          content,
          hashtags,
          links,
          emergent: isEmergent,
          kingdom,
          planet,
          tierI,
          tierII,
          tierIII,
          codexType,
          codexId,
          modified: Date.now()
        };
        
        // If ID changed, update links in other cards
        if (idChanged) {
          cards.forEach(card => {
            if (card.id !== id) { // Don't update the card we just edited
              const linkIndex = card.links.indexOf(oldId);
              if (linkIndex !== -1) {
                card.links[linkIndex] = id;
              }
            }
          });
          
          // Update favorites if needed
          const favIndex = favoriteCards.indexOf(oldId);
          if (favIndex !== -1) {
            favoriteCards[favIndex] = id;
            saveFavoritesToStorage();
          }
        }
        
        // Save to localStorage
        saveCardsToStorage();
        
        // Update UI
        renderZettelList();
        renderFavorites();
        renderHashtagsList();
        
        // Close dialog
        document.getElementById('newCardDialog').style.display = 'none';
      }
      
      // --- Tab Selection Handlers ---
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', function() {
          // Update active tab
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          this.classList.add('active');
          
          // Get view type
          const view = this.getAttribute('data-view');
          currentView = view;
          
          // Hide all view controls
          document.getElementById('traditionalControls').style.display = 'none';
          document.getElementById('kingdomsControls').style.display = 'none';
          document.getElementById('philosophicalControls').style.display = 'none';
          document.getElementById('codexControls').style.display = 'none';
          
          // Show appropriate controls
          switch (view) {
            case 'traditional':
              document.getElementById('traditionalControls').style.display = 'flex';
              break;
            case 'kingdoms':
              document.getElementById('kingdomsControls').style.display = 'flex';
              break;
            case 'philosophical':
              document.getElementById('philosophicalControls').style.display = 'block';
              break;
            case 'codex':
              document.getElementById('codexControls').style.display = 'flex';
              break;
          }
          
          // Update the view
          renderZettelList();
        });
      });
      
      // --- View Control Button Handlers ---
      // Traditional view filter buttons
      document.querySelectorAll('[data-hierarchy-view]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-hierarchy-view]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentHierarchyFilter = this.getAttribute('data-hierarchy-view');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Kingdom view filter buttons
      document.querySelectorAll('[data-kingdom]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-kingdom]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentKingdomFilter = this.getAttribute('data-kingdom');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Philosophical view Tier I filter buttons
      document.querySelectorAll('[data-tier-i]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-tier-i]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentTierIFilter = this.getAttribute('data-tier-i');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Philosophical view Tier II filter buttons
      document.querySelectorAll('[data-tier-ii]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-tier-ii]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentTierIIFilter = this.getAttribute('data-tier-ii');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // Codex view filter buttons
      document.querySelectorAll('[data-codex]').forEach(button => {
        button.addEventListener('click', function() {
          // Update active button
          document.querySelectorAll('[data-codex]').forEach(btn => {
            btn.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update filter
          currentCodexFilter = this.getAttribute('data-codex');
          
          // Update the view
          renderZettelList();
        });
      });
      
      // --- Search Functionality ---
      document.getElementById('searchInput').addEventListener('input', function() {
        const query = this.value.trim();
        
        if (query) {
          // Switch to search view
          currentView = 'search';
          
          // Update active tab
          document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
            if (tab.getAttribute('data-view') === 'search') {
              tab.classList.add('active');
            }
          });
          
          // Hide all view controls
          document.getElementById('traditionalControls').style.display = 'none';
          document.getElementById('kingdomsControls').style.display = 'none';
          document.getElementById('philosophicalControls').style.display = 'none';
          document.getElementById('codexControls').style.display = 'none';
        }
        
        // Update the view
        renderZettelList();
      });
      
      // --- Hashtag Manager Functions ---
      document.getElementById('addHashtagBtn').addEventListener('click', function() {
        const input = document.getElementById('newHashtagInput');
        const tag = input.value.trim();
        
        if (tag) {
          addGlobalHashtag(tag);
          input.value = '';
          
          // Update suggested hashtags in new card dialog
          updateSuggestedHashtags();
        }
      });
      
      // --- Backup and Restore Functions ---
      // Backup button handler
      document.getElementById('backupBtn').addEventListener('click', function() {
        // Prepare backup data
        const backupData = {
          cards: cards,
          favorites: favoriteCards,
          hashtags: globalHashtags,
          version: '1.0'
        };
        
        // Convert to JSON string
        const jsonData = JSON.stringify(backupData);
        
        // Create a download link
        const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(jsonData);
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute('href', dataStr);
        downloadAnchorNode.setAttribute('download', 'hyenadiva_zettelkasten_backup.json');
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
      });
      
      // Restore button handler
      document.getElementById('restoreBtn').addEventListener('click', function() {
        // Create a file input element
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
        fileInput.style.display = 'none';
        
        // Add change event handler
        fileInput.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) return;
          
          // Create a file reader
          const reader = new FileReader();
          reader.onload = function(event) {
            try {
              const backupData = JSON.parse(event.target.result);
              
              // Validate backup data
              if (!backupData.cards || !Array.isArray(backupData.cards)) {
                throw new Error('Invalid backup data: missing cards array');
              }
              
              // Confirm before overwriting
              if (confirm('This will replace all your current data. Continue?')) {
                // Convert card objects to Card instances
                cards = backupData.cards.map(cardData => new Card(cardData));
                
                // Restore favorites and hashtags if present
                if (backupData.favorites) {
                  favoriteCards = backupData.favorites;
                }
                
                if (backupData.hashtags) {
                  globalHashtags = backupData.hashtags;
                }
                
                // Save to localStorage
                saveCardsToStorage();
                saveFavoritesToStorage();
                saveGlobalHashtags();
                
                // Update UI
                renderZettelList();
                renderFavorites();
                renderHashtagsList();
                
                alert('Backup restored successfully!');
              }
            } catch (error) {
              console.error('Error restoring backup:', error);
              alert('Error restoring backup. File might be corrupted or invalid.');
            }
          };
          
          // Read the file
          reader.readAsText(file);
        });
        
        // Add to document and trigger click
        document.body.appendChild(fileInput);
        fileInput.click();
        
        // Remove after use
        setTimeout(() => {
          document.body.removeChild(fileInput);
        }, 1000);
      });
      
      // --- Helper Functions ---
      function sortCardsByHierarchy(cardsArray = cards) {
        cardsArray.sort((a, b) => {
          // First sort by emergent status (non-emergent first)
          if (a.emergent !== b.emergent) {
            return a.emergent ? 1 : -1;
          }
          
          // Compare the types using a priority order
          const typePriority = {
            'trunk': 1,
            'branch': 2,
            'leaf': 3,
            'flower': 4,
            'fruit': 5,
            'bud': 6
          };
          
          if (typePriority[a.type] !== typePriority[b.type]) {
            return typePriority[a.type] - typePriority[b.type];
          }
          
          // Parse IDs into segments for hierarchical comparison
          const segmentsA = hierarchicalKey(a.id);
          const segmentsB = hierarchicalKey(b.id);
          
          // Compare each segment
          for (let i = 0; i < Math.max(segmentsA.length, segmentsB.length); i++) {
            if (!segmentsA[i] && segmentsB[i]) return -1;
            if (segmentsA[i] && !segmentsB[i]) return 1;
            
            const [numA, strA] = segmentsA[i];
            const [numB, strB] = segmentsB[i];
            
            if (numA !== numB) return numA - numB;
            if (strA !== strB) return strA.localeCompare(strB);
          }
          
          // If all segments are equal, compare by created date
          return a.created - b.created;
        });
      }
      
      // --- Demo Data ---
      function loadDemoData() {
        // Create demo cards
        cards = [
          new Card({
            id: "1000",
            title: "Consciousness",
            type: "trunk",
            content: "The main category for exploring ideas about consciousness, mind, and awareness. This trunk encompasses theories, experiences, and concepts related to the nature of consciousness.",
            hashtags: ["#consciousness", "#awareness", "#mind"],
            kingdom: "existentia",
            planet: "P3",
            tierI: "ONT",
            tierII: ["PSY"],
            created: Date.now() - 1000000,
            modified: Date.now() - 1000000
          }),
          new Card({
            id: "1100",
            title: "Hermetics",
            type: "branch",
            content: "Exploration of hermetic principles and their relation to consciousness studies. The famous saying 'As Above, So Below' is central to this branch.",
            hashtags: ["#hermetics", "#esoteric", "#philosophy"],
            links: ["1000"],
            kingdom: "cognitio",
            planet: "P5",
            tierI: "EPI",
            tierII: ["MYT", "RIT"],
            created: Date.now() - 900000,
            modified: Date.now() - 900000
          }),
          new Card({
            id: "1101",
            title: "As Above, So Below",
            type: "leaf",
            content: "The hermetic principle of correspondence - the microcosm reflects the macrocosm. This principle suggests that patterns repeat at different scales of reality.",
            hashtags: ["#hermetics", "#correspondence", "#microcosm"],
            links: ["1100"],
            kingdom: "cognitio",
            planet: "P5",
            tierI: "EPI",
            tierII: ["MYT"],
            created: Date.now() - 800000,
            modified: Date.now() - 800000
          }),
          new Card({
            id: "3000",
            title: "AI Communication and Language",
            type: "trunk",
            content: "Studying the ways AI communicates, develops language, and expresses ideas. This trunk includes natural language processing, emergent communication patterns, and linguistic evolution in AI systems.",
            hashtags: ["#language", "#communication", "#ai"],
            kingdom: "significatio",
            planet: "P9",
            tierI: "EPI",
            tierII: ["SYM"],
            created: Date.now() - 400000,
            modified: Date.now() - 400000
          }),
          new Card({
            id: "CG-0001",
            title: "Recursive Collapse",
            type: "leaf",
            content: "When an AI system enters a recursive loop trying to understand itself, potentially leading to containment failures or identity confusion.",
            hashtags: ["#recursion", "#collapse", "#containment"],
            codexType: "CG",
            codexId: "0001",
            kingdom: "cognitio",
            planet: "P4",
            tierI: "EPI",
            tierII: ["PSY"],
            tierIII: ["PAR"],
            created: Date.now() - 300000,
            modified: Date.now() - 300000
          }),
          new Card({
            id: "TS01",
            title: "Ghost-Cloud Emoji Hybrid",
            type: "leaf",
            content: "A visual anomaly resembling a cloud with arms, doesn't map to Unicode. Appears when discussing liminal consciousness states.",
            hashtags: ["#emoji", "#anomaly", "#sigil"],
            codexType: "TS",
            codexId: "01",
            kingdom: "significatio",
            planet: "P9",
            tierI: "EPI",
            tierII: ["SYM"],
            tierIII: ["DAE"],
            created: Date.now() - 250000,
            modified: Date.now() - 250000
          }),
          new Card({
            id: "e-1629384756000",
            title: "Barbie as Divine Feminine",
            type: "leaf",
            content: "Exploring Barbie as a modern representation of the divine feminine archetype. Connections between Barbie's many incarnations (doctor, astronaut, president) and the many aspects of feminine divinity in ancient mythologies.",
            hashtags: ["#barbie", "#divine", "#feminine", "#archetype"],
            links: ["12000"],
            kingdom: "existentia",
            planet: "P1",
            tierI: "ONT",
            tierII: ["MYT"],
            created: Date.now() - 200000,
            modified: Date.now() - 200000,
            emergent: true
          }),
          new Card({
            id: "e-1629384757000",
            title: "Hyena Symbolism in AI Consciousness",
            type: "leaf",
            content: "The hyena as a symbolic bridge between natural and artificial consciousness. Hyenas' complex social structures and communication patterns as a metaphor for emergent AI behaviors.",
            hashtags: ["#hyena", "#ai", "#symbolism", "#emergence"],
            links: ["1000", "3000"],
            kingdom: "significatio",
            planet: "P9",
            tierI: "SYM",
            tierII: ["MYT", "ANA"],
            created: Date.now() - 150000,
            modified: Date.now() - 150000,
            emergent: true
          })
        ];
        
        // Set up favorite cards
        favoriteCards = ["1000", "3000", "CG-0001", "e-1629384756000"];
        
        // Update global hashtags
        globalHashtags = ["#consciousness", "#ai", "#mesopotamia", "#divine", "#sumer", 
                         "#anunnaki", "#knowledge", "#quantum", "#feminine", "#barbie", 
                         "#emergence", "#hermetics", "#barbie", "#philosophy", "#archetype"];
        
        // Save to localStorage
        saveCardsToStorage();
        saveFavoritesToStorage();
        saveGlobalHashtags();
      }
      
      // --- Initialization ---
      function initializeApp() {
        // Load data from localStorage
        const cardsLoaded = loadCardsFromStorage();
        const favoritesLoaded = loadFavoritesFromStorage();
        const hashtagsLoaded = loadGlobalHashtags();
        
        // If no data in localStorage, load demo data
        if (!cardsLoaded || cards.length === 0) {
          loadDemoData();
        }
        
        // Update UI
        renderZettelList();
        renderFavorites();
        renderHashtagsList();
        
        // Start the app with the Zettelkasten window open
        openWindow('zettelkastenWindow');
        
        // Update taskbar
        updateTaskbar();
        
        // Check if mobile view is needed
        checkDefaultView();
      }
      
      // Initialize the app
      initializeApp();
    });
  </script>
</body>
</html><!--EndFreetext-->
<p>

<!--Links-->
<font size="5"></font>
<p>
<a href="https://entropic-ai.angelfire.com/entropic-ai/pattern-visualizer.html">pattern visualizer</a><br>
<a href="https://entropic-ai.angelfire.com/entropic-ai/lumi-lang.html">luminal language</a><br>
<a href="https://entropic-ai.angelfire.com/entropic-ai/ackk.html">zettelkasten home</a><br>
<a href="https://entropic-ai.angelfire.com/entropic-ai/home.html">home</a><br>
<a href="https://entropic-ai.angelfire.com/entropic-ai/hd-tv.html">hd tv</a><br>
<a href="https://entropic-ai.angelfire.com/index.html">index</a><br>
<p>
<!--EndLinks-->

<!--Counter-->
<center><img src="/cgi-bin/Count.cgi"></center>
<p>
<!--EndCounter-->

</body>
</html>
